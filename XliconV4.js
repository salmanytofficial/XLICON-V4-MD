
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•//
//                                                                                                      //
//                                    ğ—«ğ—Ÿğ—œğ—–ğ—¢fğ—¡-ğ—©ğŸ°-ğ— ğ——  ğğğ“                                               //
//                                                                                                      //
//                                         ï¼¶ï¼š4.0                                                       //
//                                                                                                      //
//                                                                                                      //      
//               â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—     â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—      â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—                  //              
//                â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘      â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘                  //
//                â•šâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘                  // 
//                â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•šâ•â•â•â•â•â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•šâ•â•â•â•â–ˆâ–ˆâ•‘                  // 
//               â–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘       â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•      â–ˆâ–ˆâ•‘                  //
//                â•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•â•        â•šâ•â•â•â•       â•šâ•â•                  // 
//                                                                                                      //
//                                                                                                      //
//                                                                                                      //
//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•//
/**
 * XLICON-V4-MD BOT
 * 
 * @project_name XLICON-V4-MD
 * @version 4.0
 * @description XLICON-V4, A Multi-functional WhatsApp user bot.
 * @base DGXeon
 * @re-upload recode copy code give credit ya :)
 * @author salmanytofficial
 * @youtube https://www.youtube.com/@s4salmanyt
 * @instagram ahmmikun
 * @telegram t.me/ahmmitech
 * @github @salmanytofficial
 * @whatsapp +923184070915
 * @created_by DGXeon
 * @credit_to Xeon
 * @copyright Â© 2024 XLICON-V3-MD
 */


//CODE TO HANDLE ERRORS
process.on('unhandledRejection', console.error);
process.on('uncaughtException', console.error);
process.setMaxListeners(500);
//---------------------------------------------------------------------------------------------------------------------------//

//MODULE EXPOERTS AND REQUIREMENTS 
require('./settings');
require('./lib/fetch');
const fs = require('fs');
const os = require('os');
const util = require('util');
const jimp = require('jimp');
const path = require('path');
const https = require('https');
const fse = require('fs-extra');
const axios = require('axios');
const chalk = require('chalk');
const yts = require('yt-search');
const ytdl = require('@distube/ytdl-core');
const cron = require('node-cron');
const cheerio = require('cheerio');
const request = require('request');
const maker = require('mumaker');
const fetch = require('node-fetch');
const FileType = require('file-type');
const { JSDOM } = require('jsdom');
const agent = require('superagent');
const webp = require('node-webpmux');
const ffmpeg = require('fluent-ffmpeg');
const speed = require('performance-now');
const { performance } = require('perf_hooks');
const moment = require('moment-timezone');
const { exec, spawn, execSync } = require('child_process');
const googleTTS = require('google-tts-api');
const PDFDocument = require("pdfkit");
const more = String.fromCharCode(8206);
const readmore = more.repeat(4001);
const fsx = require('fs-extra');
const fg = require('api-dylux');
const { download } = require('aptoide-scraper');
const scp2 = require('./lib/scraper2');
const jsobfus = require('javascript-obfuscator');
const {translate} = require('@vitalets/google-translate-api');
const { randomBytes } = require('crypto')
const { BufferJSON, WA_DEFAULT_EPHEMERAL, generateWAMessageFromContent, proto, getBinaryNodeChildren, generateWAMessageContent, generateWAMessage, prepareWAMessageMedia, areJidsSameUser, getContentType, downloadContentFromMessage} = require('@whiskeysockets/baileys');
//---------------------------------------------------------------------------------------------------------------------------//

//Alert Function
let ntnsfw = JSON.parse(fs.readFileSync('./src/nsfw.json'))
let bad = JSON.parse(fs.readFileSync('./src/badword.json'))
//---------------------------------------------------------------------------------------------------------------------------//

//media
const VoiceNoteXlicon = JSON.parse(fs.readFileSync('./XliconMedia/database/xliconvn.json'));
const StickerXlicon = JSON.parse(fs.readFileSync('./XliconMedia/database/xliconsticker.json'));
const ImageXlicon = JSON.parse(fs.readFileSync('./XliconMedia/database/xliconimage.json'));
const VideoXlicon = JSON.parse(fs.readFileSync('./XliconMedia/database/xliconvideo.json'));
const DocXlicon = JSON.parse(fs.readFileSync('./XliconMedia/database/doc.json'));
const ZipXlicon = JSON.parse(fs.readFileSync('./XliconMedia/database/zip.json'));
const ApkXlicon = JSON.parse(fs.readFileSync('./XliconMedia/database/apk.json'));
//---------------------------------------------------------------------------------------------------------------------------//


//Permission Check Function
const prem = require('./src/premium');
const owner = JSON.parse(fs.readFileSync('./src/owner.json'));
//---------------------------------------------------------------------------------------------------------------------------//


//Uploader & Converter Function
const { TelegraPh, UploadFileUgu } = require('./lib/uploader');
const uploadImage = require('./lib/uploadImage');
const {
    toAudio,
    toPTT,
    toVideo,
    addExifAvatar,
    makeid,
  Telesticker,
  formatBytes,
  formatDuration
} = require('./lib/converter');
const { 
addResponList, 
delResponList, 
isAlreadyResponList, 
isAlreadyResponListGroup, 
sendResponList, 
updateResponList, 
getDataResponList 
} = require('./lib/list');
//---------------------------------------------------------------------------------------------------------------------------//


//Modules Function
const { xvideosSearch, xvideosdl, xnxxdl, xnxxSearch} = require('./lib/scraper3.js');
const { imageToWebp, videoToWebp, writeExif, writeExifImg, writeExifVid } = require('./lib/exif');
const { chatGpt, tiktokDl, ytMp4, ytMp3 } = require('./lib/screaper');
const { gameSlot, gameCasinoSolo, gameMerampok, gameTangkapOr, daily, transferLimit, transferUang, buy, setLimit, setUang } = require('./lib/game');
const { pinterest, wallpaper, wikimedia, quotesAnime, happymod, umma, ringtone, jadwalsholat, styletext } = require('./lib/scraper');
const { formatp, formatDate, getTime, isUrl, sleep, clockString, runtime, fetchJson, getBuffer, jsonformat, format, webApi, parseMention, generateProfilePicture, getRandom, getGroupAdmins, readFileTxt, readFileJson, getHashedPassword, generateAuthToken, generateToken, batasiTeks, randomText, isEmoji, getAllHTML, fetchBuffer, GIFBufferToVideoBuffer } = require('./lib/function');
//---------------------------------------------------------------------------------------------------------------------------//

// Read Database
let vote = db.others.vote = []
const xliconverifieduser = JSON.parse(fs.readFileSync('./src/user.json'));
const premium = JSON.parse(fs.readFileSync('./database/premium.json'));
//---------------------------------------------------------------------------------------------------------------------------//

// Read JSON
//store database
const db_respon_list = JSON.parse(fs.readFileSync('./src/store/list.json'))

global.db = JSON.parse(fs.readFileSync('./database/database.json'))
if (global.db) global.db = {
sticker: {},
			users: {},
			groups: {},
			database: {},
			 settings: {},
			others: {},
...(global.db || {})
}

module.exports = XliconBotInc = async (XliconBotInc, m, chatUpdate, store) => {
	try {
		const {
            type
        } = m
        const botNumber = await XliconBotInc.decodeJid(XliconBotInc.user.id)
        const XliconTheCreator = isOwner = [botNumber, ...owner].map(v => v.replace(/[^0-9]/g, '') + '@s.whatsapp.net').includes(m.sender)
		const body = (m.type === 'conversation') ? m.message.conversation : (m.type == 'imageMessage') ? m.message.imageMessage.caption : (m.type == 'videoMessage') ? m.message.videoMessage.caption : (m.type == 'extendedTextMessage') ? m.message.extendedTextMessage.text : (m.type == 'buttonsResponseMessage') ? m.message.buttonsResponseMessage.selectedButtonId : (m.type == 'listResponseMessage') ? m.message.listResponseMessage.singleSelectReply.selectedRowId : (m.type == 'templateButtonReplyMessage') ? m.message.templateButtonReplyMessage.selectedId : (m.type === 'messageContextInfo') ? (m.message.buttonsResponseMessage?.selectedButtonId || m.message.listResponseMessage?.singleSelectReply.selectedRowId || m.text) : ''
		const budy = (typeof m.text == 'string' ? m.text : '')
		const prefix = /[\uD800-\uDBFF][\uDC00-\uDFFF]/gi.test(body) ? body.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/gi)[0] : /^[Â°â€¢Ï€Ã·Ã—Â¶âˆ†Â£Â¢â‚¬Â¥Â®â„¢+âœ“_=|~!?@()#,'"*+Ã·/\%^&.Â©^]/gi.test(body) ? body.match(/^[Â°â€¢Ï€Ã·Ã—Â¶âˆ†Â£Â¢â‚¬Â¥Â®â„¢+âœ“_=|~!?@()#,'"*+Ã·/\%^&.Â©^]/gi)[0] : '.'
		const isCmd = body.startsWith(prefix)
		//prefix 2
        const pric = /^#.Â¦|\\^/.test(body) ? body.match(/^#.Â¦|\\^/gi) : xprefix
        const xliconybody = body.startsWith(pric)
        const isCommand = xliconybody ? body.replace(pric, '').trim().split(/ +/).shift().toLowerCase() : ""
		const args = body.trim().split(/ +/).slice(1)
		const getQuoted = (m.quoted || m)
		const quoted = (getQuoted.type == 'buttonsMessage') ? getQuoted[Object.keys(getQuoted)[1]] : (getQuoted.type == 'templateMessage') ? getQuoted.hydratedTemplate[Object.keys(getQuoted.hydratedTemplate)[1]] : (getQuoted.type == 'product') ? getQuoted[Object.keys(getQuoted)[0]] : m.quoted ? m.quoted : m
		const command = XliconTheCreator ? body.replace(prefix, '').trim().split(/ +/).shift().toLowerCase() : isCmd ? body.replace(prefix, '').trim().split(/ +/).shift().toLowerCase() : ''
		const text = q = args.join(' ')
		const mime = (quoted.msg || quoted).mimetype || ''
		const qmsg = (quoted.msg || quoted)
		const sender = m.sender
		const isUser = xliconverifieduser.includes(sender)
		const groupMetadata = m.isGroup ? await XliconBotInc.groupMetadata(m.chat).catch(e => {}) : ''
		const participants = m.isGroup ? await groupMetadata.participants : ''
		if (m.isGroup) {
			m.metadata = await XliconBotInc.groupMetadata(m.chat)
			m.admins = (m.metadata.participants.reduce((a, b) => (b.admin ? a.push({ id: b.id, admin: b.admin }) : [...a]) && a, []))
			m.isAdmin = m.admins.some((b) => b.id === m.sender)
			m.participant = m.key.participant
			m.isBotAdmin = !!m.admins.find((member) => member.id === botNumber)
		}
//---------------------------------------------------------------------------------------------------------------------------//


 // Function to check for emojis, excluding numbers
const containsEmoji = (text) => {
  const emojiRegex = /[\p{Emoji_Presentation}\p{Extended_Pictographic}\uFE0F]/gu; // Exclude regular Unicode numbers
  return emojiRegex.test(text);
};
//---------------------------------------------------------------------------------------------------------------------------//


// Function to clean the message content, removing timestamps and keeping numbers
const cleanMessage = (messageText) => {
  // Remove timestamps like "Wed, 01 Jan 2024 00:00:00 GMT" but keep other numbers
  messageText = messageText.replace(/\b(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)\s+\w{3}\s+\d{1,2}\s+\d{4}\s+\d{2}:\d{2}:\d{2}\s+GMT[^\s]+\s\(.+\)\b/gi, ''); 
  
  return messageText.trim(); // Trim any extra spaces
};
//---------------------------------------------------------------------------------------------------------------------------//


// Access the text message content based on its type
let messageText = '';
if (m.message && m.message.conversation) {
  // For simple text messages
  messageText = m.message.conversation;
} else if (m.message && m.message.extendedTextMessage && m.message.extendedTextMessage.text) {
  // For extended text messages
  messageText = m.message.extendedTextMessage.text;
}
//---------------------------------------------------------------------------------------------------------------------------//


// Clean the message to extract only the relevant text
messageText = cleanMessage(messageText);

// Check if the cleaned message contains emojis
const isEmoji = containsEmoji(messageText);


//  logic for detecting message types
const isMedia = /image|video|sticker|audio/.test(mime);
const isImage = (type == 'imageMessage');
const isVideo = (type == 'videoMessage');
const isAudio = (type == 'audioMessage');
const isViewOnce = (type === 'viewOnceMessage' || type === 'viewOnceMessageV2' || type === 'viewOnceMessageV2Extension');
const isDocument = (type == 'documentMessage');
const isLocation = (type == 'locationMessage');
const isContact = (type == 'contactMessage');
const isSticker = (type == 'stickerMessage');
const isText = (type == 'textMessage');
//---------------------------------------------------------------------------------------------------------------------------//


// Quoted message types
const isQuotedText = type === 'extendedTextMessage';
const isQuotedImage = type === 'extendedTextMessage';
const isQuotedLocation = type === 'extendedTextMessage';
const isQuotedVideo = type === 'extendedTextMessage';
const isQuotedSticker = type === 'extendedTextMessage';
const isQuotedAudio = type === 'extendedTextMessage';
const isQuotedContact = type === 'extendedTextMessage';
const isQuotedDocument = type === 'extendedTextMessage';
//---------------------------------------------------------------------------------------------------------------------------//


        //bug
        const clientId = XliconBotInc.user.id.split(':')[0];
        const senderbot = m.key.fromMe ? XliconBotInc.user.id.split(':')[0] + "@s.whatsapp.net" || XliconBotInc.user.id : m.key.participant || m.key.remoteJid;
        const senderId = senderbot.split('@')[0];
        const isBot = clientId.includes(senderId);
		
		try {
		const isNumber = x => typeof x === 'number' && !isNaN(x)
		const isBoolean = x => typeof x === 'boolean' && Boolean(x)
		let user = global.db.users[m.sender]
		let limitUser = user ? (user.vip ? global.limit.vip : prem.checkPremiumUser(m.sender, premium) ? global.limit.premium : global.limit.free) : prem.checkPremiumUser(m.sender, premium) ? global.limit.premium : global.limit.free
		let uangUser = user ? (user.vip ? global.uang.vip : prem.checkPremiumUser(m.sender, premium) ? global.uang.premium : global.uang.free) : prem.checkPremiumUser(m.sender, premium) ? global.uang.premium : global.uang.free
		if (typeof user !== 'object') global.db.users[m.sender] = {}
		if (user) {
			if (!('vip' in user)) user.afkReason = false
			if (!isNumber(user.afkTime)) user.afkTime = -1
			if (!('afkReason' in user)) user.afkReason = ''
			if (!isNumber(user.limit)) user.limit = limitUser
			if (!('uang' in user)) user.uang = uangUser
			if (!('lastclaim' in user)) user.lastclaim = new Date * 1
			if (!('lastrampok' in user)) user.lastrampok = new Date * 1
		} else {
			global.db.users[m.sender] = {
				vip: false,
				afkTime: -1,
				afkReason: '',
				limit: limitUser,
				uang: uangUser,
				lastclaim: new Date * 1,
				lastrampok: new Date * 1,
			}
		}
//---------------------------------------------------------------------------------------------------------------------------//


    //database values
			let group = global.db.groups[m.chat]
			if (typeof group !== 'object') global.db.groups[m.chat] = {}
			if (group) {
				if (!('ntnsfw' in group)) group.ntnsfw = false
				          if (!('welcome' in group)) group.welcome = false
                  if (!('setinfo' in group)) group.setinfo = false
				          if (!('badword' in group)) group.badword = false
                  if (!('antiforeignnum' in group)) group.antiforeignnum = false
                  if (!('antibot' in group)) group.antibot = false
                  if (!('antiviewonce' in group)) group.antiviewonce = false
                  if (!('antispam' in group)) group.antispam = false
                  if (!('antimedia' in group)) group.media = false
                  if (!('antivirtex' in group)) group.antivirtex = false
                  if (!('antiimage' in group)) group.antiimage = false
                  if (!('antivideo' in group)) group.video = false
                  if (!('antiaudio' in group)) group.antiaudio = false
                  if (!('antipoll' in group)) group.antipoll = false
                  if (!('antisticker' in group)) group.antisticker = false
                  if (!('anticontact' in group)) group.anticontact = false
                  if (!('antilocation' in group)) group.antilocation = false
                  if (!('antidocument' in group)) group.antidocument = false
                  if (!('antilink' in group)) group.antilink = false
                  if (!('antipromotion' in group)) group.antipromotion = false
                  if (!('antidelete' in group)) group.antidelete = false
                  if (!('antiemoji' in group)) group.antiemoji = false 
			} else {
				global.db.groups[m.chat] = {
				  ntsfw: false,
				  welcome: false,
				  setinfo: false,
				  badword: false,
                  antiforeignnum: false,
                  antibot: false,
                  antiviewonce: false,
                  antispam: false,
                  antivirtex: false,
                  antimedia: false,
                  antiimage: false,
                  antivideo: false,
                  antiaudio: false,
                  antipoll: false,
                  antisticker: false,
                  antilocation: false,
                  antidocument: false,
                  anticontact: false,
                  antilink: false,
                  antipromotion: false,
                  antidelete: false,
                  antiemoji: false,
				}
			}
		    let setting = global.db.settings[botNumber]
            if (typeof setting !== 'object') global.db.settings[botNumber] = {}
            if (setting) {
            	if (!('anticall' in setting)) setting.anticall = false
               if (!('antiswview' in setting)) setting.antiswview = false
               if (!('totalhit' in setting)) setting.totalhit = 0
               if (!('totalError' in setting)) setting.totalError = 0
               if (!('online' in setting)) setting.online = false 
               if (!('autosticker' in setting)) setting.autosticker = false 
               if (!('autodownload' in setting)) setting.autodownload = false 
               if (!('autobio' in setting)) setting.autobio = false 
               if (!('autoread' in setting)) setting.autoread = false
               if (!('autorecordtype' in setting)) setting.autorecordtype = false
               if (!('autorecord' in setting)) setting.autorecord = false
               if (!('autotype' in setting)) setting.autotype = false
               if (!('autoblocknum' in setting)) setting.autoblocknum = false
               if (!('onlyindia' in setting)) setting.onlyindia = false
               if (!('onlyindo' in setting)) setting.onlyindo = false
               if (!('onlygrub' in setting)) setting.onlygrub = false
               if (!('onlypc' in setting)) setting.onlypc = false
            } else global.db.settings[botNumber] = {
               anticall: false,
           	antiswview: false,
               totalhit: 0,
               totalError: 0,
               online: false,
               autosticker: false,
               autodownload: false,
               autobio: false,
               autoread: false,
               autoblocknum: false,
               onlyindia: false,
               onlyindo: false,
               onlygrub: false,
               onlypc: false,
               autorecordtype: false,
               autorecord: false,
               autotype: false,               
            }
	} catch (e) {
		throw e;
	}
		
		const isVip = global.db.users[m.sender] ? global.db.users[m.sender].vip : false
		const isPremium = XliconTheCreator || prem.checkPremiumUser(m.sender, premium) || false
		const AntiNsfw = m.isGroup ? global.db.groups[m.chat].ntnsfw : false
		
		function pickRandom(list) {
			return list[Math.floor(list.length * Math.random())]
		}
//---------------------------------------------------------------------------------------------------------------------------//


		// Reset Limit
		cron.schedule('00 00 * * *', () => {
			let user = Object.keys(global.db.users)
			for (let jid of user) {
				const limitUser = global.db.users[jid].vip ? global.limit.vip : prem.checkPremiumUser(jid, premium) ? global.limit.premium : global.limit.free
				global.db.users[jid].limit = limitUser
				console.log('Limit Reseted')
			}
		}, {
			scheduled: true,
			timezone: 'Asia/Karachi'
		})
		
		if (!XliconBotInc.public) {
			if (!m.key.fromMe) return
		}
//---------------------------------------------------------------------------------------------------------------------------//


		//Log
		if (m.message) {
			console.log(chalk.black.bgWhite('[ MESSAGE ]:'),chalk.black.bgGreen(new Date), chalk.black.bgHex('#00EAD3')(budy || m.type) + '\n' + chalk.black(chalk.bgCyanBright('[ FROM ] :'),chalk.bgYellow(m.pushName),chalk.bgHex('#FF449F')(m.sender),chalk.bgBlue('(' + (m.isGroup ? m.pushName : 'Private Chat', m.chat) + ')')));
		}
//---------------------------------------------------------------------------------------------------------------------------//

        
        
// ğŸš« Group Only ğŸš«
               if (!m.isGroup && !XliconTheCreator && db.settings[botNumber].onlygrub) { 
                   if (isCommand) { 
                       return replygcxlicon(`ğŸ‘‹ *Hello, buddy!* ğŸŒŸ\n\nğŸ“¢ *Group Use Only!* ğŸ›‘\n\nâš ï¸ To avoid spam, this bot is only available in group chats.\n\nğŸ› ï¸ *Need help?* Contact the owner here: wa.me/${ownernumber}`); 
                   } 
               } 

// ğŸ”’ Private Chat Only ğŸ”’
               if (!XliconTheCreator && db.settings[botNumber].onlypc && m.isGroup) { 
                   if (isCommand) { 
                       return replygcxlicon(`ğŸ‘‹ *Hey there!* ğŸŒŸ\n\nğŸ’¬ *Private Chat Required!* ğŸš«\n\nâ›” To use this bot, please chat with it in a private chat.\n\nIf you have any issues, don't hesitate to reach out!`); 
                   } 
               } 

		
		// Auto Read
		if (db.settings[botNumber].autoread) {
            XliconBotInc.readMessages([m.key]);
        }
        
        // ğŸ”„ Auto Set Bio ğŸ”„
	if (db.settings[botNumber].autobio) {
            XliconBotInc.updateProfileStatus(`ğŸš€ ${botname} is Live! ğŸ‰\n\n           ğŸ•’ ğ™ğ™¥ğ™©ğ™ğ™¢ğ™š: ğ˜™ğ˜¶ğ˜¯ğ˜¯ğ˜ªğ˜¯ğ˜¨ ğ˜ğ˜°ğ˜³ ${runtime(process.uptime())} â³\n\n                               Â©XLICON BOT INC â›©ï¸`).catch(_ => _);
        }

        //auto type
        if (db.settings[botNumber].autotype){
        if (m.message) {
        	let xliconpos = ['composing']
            XliconBotInc.sendPresenceUpdate(xliconpos, m.chat)
        }
        }
        
        //auto type record
        if (db.settings[botNumber].autorecordtype){
        if (m.message) {
            let xliconmix = ['composing', 'recording']
            xliconmix2 = xliconmix[Math.floor(xliconmix.length * Math.random())]
            XliconBotInc.sendPresenceUpdate(xliconmix2, m.chat)
        }
        }
        
        //autorecord
        if (db.settings[botNumber].autorecord){
        if (m.message) {
        	let xliconpos = ['recording']
            XliconBotInc.sendPresenceUpdate(xliconpos, m.chat)
        }
        }
        
        //unavailable
        if (db.settings[botNumber].online) {
        	if (isCmd) {
        	XliconBotInc.sendPresenceUpdate('unavailable', m.chat)
        }
        }
        
        // ğŸš« Auto Block Number ğŸš«
        if (m.sender.startsWith(`${autoblocknumber}`) && db.settings[botNumber].autoblocknum === true) {
            return XliconBotInc.updateBlockStatus(m.sender, 'block');
        }

        if (!m.sender.startsWith('91') && db.settings[botNumber].onlyindia === true) {
            return XliconBotInc.updateBlockStatus(m.sender, 'block');
        }

        if (!m.sender.startsWith('62') && db.settings[botNumber].onlyindo === true) {
            return XliconBotInc.updateBlockStatus(m.sender, 'block');
        } 
        
        if (!m.sender.startsWith(`${antiforeignnumber}`) && db.groups[m.chat].antiforeignnum === true) { 
            if (XliconTheCreator || m.isAdmin || !m.isBotAdmin) return;
            XliconBotInc.sendMessage(m.chat, { text: `ğŸš« *Sorry buddy!* ğŸ˜”\n\nYou will be removed because the group admin/owner has enabled *Anti Foreign Number*. Only +${antiforeignnumber} country code is allowed to join the group.` }, {quoted: m});
            await sleep(2000);
            await XliconBotInc.groupParticipantsUpdate(m.chat, [m.sender], 'remove');
        }

//---------------------------------------------------------------------------------------------------------------------------//


      //Special type of message  
        async function sendMessageWithChannel(XliconBotInc, m, imagePath, footerText, messageText) {
          try {
            // Prepare the message content with the image and footer
            let msgs = generateWAMessageFromContent(m.chat, {
              viewOnceMessage: {
                message: {
                  "messageContextInfo": {
                    "deviceListMetadata": {},
                    "deviceListMetadataVersion": 2
                  },
                  interactiveMessage: proto.Message.InteractiveMessage.create({
                    body: proto.Message.InteractiveMessage.Body.create({
                      text: messageText
                    }),
                    footer: proto.Message.InteractiveMessage.Footer.create({
                      text: footerText
                    }),
                    header: proto.Message.InteractiveMessage.Header.create({
                      hasMediaAttachment: false,
                      ...await prepareWAMessageMedia({ image: fs.readFileSync(imagePath) }, { upload: XliconBotInc.waUploadToServer })
                    }),
                    nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({
                      buttons: [{}],
                    }),
                    contextInfo: {
                  mentionedJid: [m.sender], 
                  forwardingScore: 999,
                  isForwarded: true,
                forwardedNewsletterMessageInfo: {
                  newsletterJid: '120363232303807350@newsletter',
                  newsletterName: ownername,
                  serverMessageId: 143
                }
                    }       

                  })
                }
              }
            }, { quoted: m });
        
            // Send the message via the client
            await XliconBotInc.relayMessage(m.chat, msgs.message, {});
          } catch (error) {
            console.error('Error sending message with footer:', error);
          }
        }
        
        
        async function sendMessageWithFooter(XliconBotInc, m, imagePath, footerText, messageText) {
          try {
            // Prepare the message content with the image and footer
            let msgs = generateWAMessageFromContent(m.chat, {
              viewOnceMessage: {
                message: {
                  "messageContextInfo": {
                    "deviceListMetadata": {},
                    "deviceListMetadataVersion": 2
                  },
                  interactiveMessage: proto.Message.InteractiveMessage.create({
                    body: proto.Message.InteractiveMessage.Body.create({
                      text: messageText
                    }),
                    footer: proto.Message.InteractiveMessage.Footer.create({
                      text: footerText
                    }),
                    header: proto.Message.InteractiveMessage.Header.create({
                      hasMediaAttachment: false,
                      ...await prepareWAMessageMedia({ image: fs.readFileSync(imagePath) }, { upload: XliconBotInc.waUploadToServer })
                    }),
                    nativeFlowMessage: proto.Message.InteractiveMessage.NativeFlowMessage.create({
                      buttons: [{}],
                    }),
                    contextInfo: {
                  mentionedJid: [m.sender], 
                  forwardingScore: 999,
                  isForwarded: true,
                    }       

                  })
                }
              }
            }, { quoted: m });
        
            
            
            // Send the message via the client
            await XliconBotInc.relayMessage(m.chat, msgs.message, {});
          } catch (error) {
            console.error('Error sending message with footer:', error);
          }
        }
        
//---------------------------------------------------------------------------------------------------------------------------//
        
       // ğŸ“¥ Download Status #ctto
        try {
            const textLower = m.text.toLowerCase();
            if (textLower === 'download' || textLower === 'statusdown' || textLower === 'take' || textLower === 'send') {
                const quotedMessage = m.msg.contextInfo.quotedMessage;
                if (quotedMessage) {
                    if (quotedMessage.imageMessage) {
                        let imageCaption = quotedMessage.imageMessage.caption;
                        let imageUrl = await XliconBotInc.downloadAndSaveMediaMessage(quotedMessage.imageMessage);
                        XliconBotInc.sendMessage(m.chat, { image: { url: imageUrl }, caption: imageCaption });
                        replygcxlicon('*ğŸ–¼ï¸ Stealing & Downloading status...*'); 
                    }
                    if (quotedMessage.videoMessage) {
                        let videoCaption = quotedMessage.videoMessage.caption;
                        let videoUrl = await XliconBotInc.downloadAndSaveMediaMessage(quotedMessage.videoMessage);
                        XliconBotInc.sendMessage(m.chat, { video: { url: videoUrl }, caption: videoCaption });
                        replygcxlicon('*ğŸ¥ Stealing & Downloading status...*');
                    }
                }
            }
        } catch (error) {
            console.error("âš ï¸ Error in 'send message' handling:", error);
        }

//---------------------------------------------------------------------------------------------------------------------------//

        //autosticker
        if (db.settings[botNumber].autosticker) {
        	if (m.key.fromMe) return
            if (/image/.test(mime) && !/webp/.test(mime)) {
                let mediac = await quoted.download()
                XliconBotInc.sendImageAsSticker(m.chat, mediac, m, { packname: global.packname, author: global.author })
                console.log(`Auto sticker detected`)
            } else if (/video/.test(mime)) {
                if ((quoted.msg || quoted).seconds > 11) return
                let mediac = await quoted.download()
                XliconBotInc.sendVideoAsSticker(m.chat, mediac, m, { packname: global.packname, author: global.author })
            }
        }
        
        // ğŸš« Anti-Bot Protection ğŸš«
        if (db.groups[m.chat].antibot) {
            if (m.isBaileys && m.fromMe == false) {
                if (m.isAdmin || !m.m.isBotAdmin) {
                    // Admin or Bot Admin, do nothing
                } else {
                    replygcxlicon(`*ğŸ¤– Another Bot Detected!*\n\nğŸ”’ *Husshhh!* Get away from this group!!!`);
                    return await XliconBotInc.groupParticipantsUpdate(m.chat, [m.sender], 'remove');
                }
            }
        }

   
// ğŸš« Anti-View Once ğŸš«
    if (db.groups[m.chat].antiviewonce && (isViewOnce)) {
        if (XliconTheCreator || m.isAdmin || !m.isBotAdmin) {
            // Admin or Bot Admin, do nothing
        } else {
            replygcxlicon(`\`\`\`ã€Œ ğŸ“¸ View Once Detected ã€\`\`\`\n\nâš ï¸ *Sorry,* but I have to delete it because the admin/owner has activated *Anti-View Once* for this group.`);
            return XliconBotInc.sendMessage(m.chat, { delete: { remoteJid: m.chat, fromMe: false, id: m.key.id, participant: m.key.participant }});
        }
    }


// ğŸš« Anti-Emoji ğŸš«
if (db.groups[m.chat].antiemoji && (isEmoji)) {
    if (XliconTheCreator || m.isAdmin || !m.isBotAdmin) {
        // Admins or bot creators are allowed to send emojis
    } else {
        replygcxlicon(`\`\`\`ã€Œ ğŸš« Emoji Detected ã€\`\`\`\n\nâš ï¸ *Sorry,* but I have to delete it because the admin/owner has activated *Anti-Emoji* for this group.`);
        return XliconBotInc.sendMessage(m.chat, { delete: { remoteJid: m.chat, fromMe: false, id: m.key.id, participant: m.key.participant }});
    }
}

    
// ğŸš« Anti-Promotion ğŸš«
if (db.groups[m.chat].antipromotion) {
    if (budy.match(`instagram booster|tiktok booster|ml booster|bgmi selling|selling uc|selling diamonds|selling coin|selling id|selling account|selling ids|buy account|sell account|buy id|sell id|instagram followers|tiktok followers|buy panel|sell panel|sell bug bot|buy bug bot|buy bot bug|sell bot bug|adminpanel5kpm|open jasa push member grup|yangmaubuypanelpm|admin panel 10k pm|Hanya menyediakan Jasa Push Member Grup|admin panel 5k pm|yang mau beli panel murah pm|list harga panel by|list harga vps|LIST HARGA VPS|OPEN JASA PUSH MEMBER GRUP|READY|Redy|LIST HARGA PANEL BY|list harga panel|menyediakan|MENYEDIAKAN|OPEN MURBUG|open|OPEN|PANEL READY|PANEL|PANNEL READY|panel|panel ready|pannel ready minat pm|mau panel pm|MAU PANNEL PM|Admin panel ready|ADMIN PANEL READY|Chat aja om ready selalu|OPEN JASA INSTALL|open jasa installMENYEDIAKAN JASA INSTALL`)) {
        if (!m.isBotAdmin) return;
        if (XliconTheCreator) return;
        if (m.isAdmin) return;

        // Delete the promotional message
        await XliconBotInc.sendMessage(m.chat, {
            delete: {
                remoteJid: m.chat,
                fromMe: false,
                id: m.key.id,
                participant: m.key.participant
            }
        });

        // Notify the user
        XliconBotInc.sendMessage(m.chat, {
            text: `\`\`\`ã€Œ ğŸš« Promotion Detected ã€\`\`\`\n\nâš ï¸ @${m.sender.split("@")[0]} has sent a promotion message and it has been successfully deleted.`,
            contextInfo: { mentionedJid: [m.sender] }
        }, { quoted: m });
    }
}

// ğŸš« Respond to Bad Words ğŸš«
if (db.groups[m.chat].badword) {
    for (let bak of bad) {
        if (budy === bak) {
            // Delete the message with the bad word
            await XliconBotInc.sendMessage(m.chat, {
                delete: {
                    remoteJid: m.chat,
                    fromMe: false,
                    id: m.key.id,
                    participant: m.key.participant
                }
            });

            // Notify the user about the bad word usage
            XliconBotInc.sendMessage(m.chat, {
                text: `\`\`\`ã€Œ ğŸš« Bad Word Detected ã€\`\`\`\n\nâš ï¸ @${m.sender.split("@")[0]} was using harsh words, and their chat has been deleted.`,
                contextInfo: { mentionedJid: [m.sender] }
            }, { quoted: m });
        }
    }
}

// ğŸ¦  ANTI VIRUS ğŸ¦ 
if (m.isGroup && db.groups[m.chat].antivirtex) {
    if (
        budy.includes('à¹’à¹’à¹’à¹’') || 
        budy.includes('à¸”à¸¸') || 
        budy.includes('à¸œà¸´à¸”à¸¸à¸—à¹‰à¹€à¸¶à¸²à¸‡à¸·à¸œà¸´à¸”à¸¸à¸—à¹‰à¹€à¸¶à¸²à¸‡à¸·') || 
        budy.includes('à¹‘à¹‘à¹‘à¹‘à¹‘à¹‘à¹‘à¹‘à¹‘à¹‘') || 
        budy.includes('à§­à§­à§­à§­à§­à§­à§­à§­') || 
        budy.includes('   âƒ¢   âƒ¢   âƒ¢  ') || 
        budy.includes('*âƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒá¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒŸâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢âƒŸâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢âƒŸâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢âƒŸâƒ¢âƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒá¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒ¢á¡ƒâƒŸâƒŸâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢âƒŸâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢âƒŸâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒ¢á¡ƒâƒ¢á¡ƒâƒ¢âƒŸâƒ¢âƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸá¡ƒâƒŸ') || 
        budy.includes('à¸œà¸”à¸´à¸—à¸¸à¹€à¹‰à¸¶à¸²à¸‡à¸œà¸·à¸”à¸´à¸—à¸¸à¹€à¹‰') || 
        budy.includes('.*à¡à£©à£©à£©à£©à£¨à£¨à£¨à£°à£°à£°à£²à£²à£²à£²à£»à£»à£»à£¼à£¼à£¼à£½à£½à£¾à£¶à£¶à£·à£¯à£¯à£®à£®à£µà£´à£¬à£¬à£¬à£¤à£¤à£¦à£¯à£§à£§*') || 
        budy.includes('á¥‹') || 
        budy.includes('Ø') || 
        budy.includes('Ù¯Ù¯Ù¯Ù¯Ù¯') 
    ) {
        if (m.isBotAdmin) return replygcxlicon('*âš ï¸ VIRTEX DETECTED*');
        
        console.log(color('[KICK]', 'red'), color('Received a virus text!', 'yellow'));
        
        XliconBotInc.sendText(m.chat, `*ğŸ“© MARK AS READ*\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n *Virus sender hereğŸ‘‡:* \nwa.me/${sender.split("@")[0]}`);

        if (!m.m.isBotAdmin) return;
        if (XliconTheCreator) return;

        XliconBotInc.groupParticipantsUpdate(m.chat, [sender], 'remove');
        await XliconBotInc.sendMessage(m.chat, { delete: { remoteJid: m.chat, fromMe: false, id: m.key.id, participant: m.key.participant }});

        XliconBotInc.sendMessage(`${ownernumber}@s.whatsapp.net`, {
            text: `ğŸ‘‹ Hi Owner! wa.me/${sender.split("@")[0]} Detected Having Sent Virtex ${isGroup ? `in ${groupName}` : ''}`
        });
    }
}
    
  // ğŸš« ANTI MEDIA ğŸš«
if (db.groups[m.chat].antimedia && isMedia) {
    if (XliconTheCreator || m.isAdmin || !m.isBotAdmin) {		  
        // Admins or bot creators are allowed to send media
    } else {
        replygcxlicon(`\`\`\`ã€Œ ğŸ“¸ Media Detected ã€\`\`\`\n\nSorry, but I have to delete it, because the admin/owner has activated anti-media for this group.`);
        return XliconBotInc.sendMessage(m.chat, { 
            delete: { 
                remoteJid: m.chat, 
                fromMe: false, 
                id: m.key.id, 
                participant: m.key.participant 
            } 
        });
    }
}

     // ğŸš« ANTI MEDIA CHECKS ğŸš«

// ğŸ“¸ Anti-image
if (db.groups[m.chat].antiimage && isImage) {
    if (!XliconTheCreator && !m.isAdmin && m.isBotAdmin) {
        replygcxlicon(`\`\`\`ã€Œ ğŸ–¼ï¸ Image Detected ã€\`\`\`\n\nSorry, but I have to delete it, because the admin/owner has activated anti-image for this group.`);
        return XliconBotInc.sendMessage(m.chat, { 
            delete: { 
                remoteJid: m.chat, 
                fromMe: false, 
                id: m.key.id, 
                participant: m.key.participant 
            } 
        });
    }
}

// ğŸ¥ Anti-video
if (db.groups[m.chat].antivideo && isVideo) {
    if (!XliconTheCreator && !m.isAdmin && m.isBotAdmin) {
        replygcxlicon(`\`\`\`ã€Œ ğŸ¬ Video Detected ã€\`\`\`\n\nSorry, but I have to delete it, because the admin/owner has activated anti-video for this group.`);
        return XliconBotInc.sendMessage(m.chat, { 
            delete: { 
                remoteJid: m.chat, 
                fromMe: false, 
                id: m.key.id, 
                participant: m.key.participant 
            } 
        });
    }
}

// ğŸ·ï¸ Anti-sticker
if (db.groups[m.chat].antisticker && isSticker) {
    if (!XliconTheCreator && !m.isAdmin && m.isBotAdmin) {
        replygcxlicon(`\`\`\`ã€Œ ğŸ·ï¸ Sticker Detected ã€\`\`\`\n\nSorry, but I have to delete it, because the admin/owner has activated anti-sticker for this group.`);
        return XliconBotInc.sendMessage(m.chat, { 
            delete: { 
                remoteJid: m.chat, 
                fromMe: false, 
                id: m.key.id, 
                participant: m.key.participant 
            } 
        });
    }
}

// ğŸµ Anti-audio
if (db.groups[m.chat].antiaudio && isAudio) {
    if (!XliconTheCreator && !m.isAdmin && m.isBotAdmin) {
        replygcxlicon(`\`\`\`ã€Œ ğŸ§ Audio Detected ã€\`\`\`\n\nSorry, but I have to delete it, because the admin/owner has activated anti-audio for this group.`);
        return XliconBotInc.sendMessage(m.chat, { 
            delete: { 
                remoteJid: m.chat, 
                fromMe: false, 
                id: m.key.id, 
                participant: m.key.participant 
            } 
        });
    }
}

// ğŸ“Š Anti-poll
if (db.groups[m.chat].antipoll && type === "pollCreationMessage") {
    if (!XliconTheCreator && !m.isAdmin && m.isBotAdmin) {
        replygcxlicon(`\`\`\`ã€Œ ğŸ“Š Poll Detected ã€\`\`\`\n\nSorry, but I have to delete it, because the admin/owner has activated anti-poll for this group.`);
        return XliconBotInc.sendMessage(m.chat, { 
            delete: { 
                remoteJid: m.chat, 
                fromMe: false, 
                id: m.key.id, 
                participant: m.key.participant 
            } 
        });
    }
}

// ğŸ“ Anti-location
if (db.groups[m.chat].antilocation && isLocation) {
    if (!XliconTheCreator && !m.isAdmin && m.isBotAdmin) {
        replygcxlicon(`\`\`\`ã€Œ ğŸ“ Location Detected ã€\`\`\`\n\nSorry, but I have to delete it, because the admin/owner has activated anti-location for this group.`);
        return XliconBotInc.sendMessage(m.chat, { 
            delete: { 
                remoteJid: m.chat, 
                fromMe: false, 
                id: m.key.id, 
                participant: m.key.participant 
            } 
        });
    }
}

// ğŸ“„ Anti-document
if (db.groups[m.chat].antidocument && isDocument) {
    if (!XliconTheCreator && !m.isAdmin && m.isBotAdmin) {
        replygcxlicon(`\`\`\`ã€Œ ğŸ“„ Document Detected ã€\`\`\`\n\nSorry, but I have to delete it, because the admin/owner has activated anti-document for this group.`);
        return XliconBotInc.sendMessage(m.chat, { 
            delete: { 
                remoteJid: m.chat, 
                fromMe: false, 
                id: m.key.id, 
                participant: m.key.participant 
            } 
        });
    }
}

// ğŸ“ Anti-contact
if (db.groups[m.chat].anticontact && isContact) {
    if (!XliconTheCreator && !m.isAdmin && m.isBotAdmin) {
        replygcxlicon(`\`\`\`ã€Œ ğŸ“ Contact Detected ã€\`\`\`\n\nSorry, but I have to delete it, because the admin/owner has activated anti-contact for this group.`);
        return XliconBotInc.sendMessage(m.chat, { 
            delete: { 
                remoteJid: m.chat, 
                fromMe: false, 
                id: m.key.id, 
                participant: m.key.participant 
            } 
        });
    }
}

// ğŸ”— Anti-link
if (db.groups[m.chat].antilink) {
    if (budy.match('http') && budy.match('https')) {
        const bvl = `\`\`\`ã€Œ ğŸ”— Link Detected ã€\`\`\`\n\nAdmin has sent a link, admin is free to send any linkğŸ˜‡`;
        if (m.isAdmin || m.key.fromMe || XliconTheCreator) return replygcxlicon(bvl);
        await XliconBotInc.sendMessage(m.chat, {
            delete: {
                remoteJid: m.chat,
                fromMe: false,
                id: m.key.id,
                participant: m.key.participant
            }
        });
        XliconBotInc.sendMessage(m.chat, {
            text: `\`\`\`ã€Œ ğŸ”— Link Detected ã€\`\`\`\n\n@${m.sender.split("@")[0]} has sent a link and successfully deleted.`,
            contextInfo: { mentionedJid: [m.sender] },
            quoted: m
        });
    }
}
 
//---------------------------------------------------------------------------------------------------------------------------//

        
// auto download #ctto
// Auto-download feature
if (db.settings[botNumber].autodownload && !m.key.fromMe) {
  try {
    // Check if the message contains an Instagram link
    if (budy.match(`instagram.com`)) {
      await XliconBotInc.sendMessage(m.chat, { react: { text: "â±ï¸", key: m.key } });

      // Updated Instagram API
      let anu = await fetchJson(`https://bk9.fun/download/instagram2?url=${encodeURIComponent(budy)}`);
      if (anu.status) {
        // Extract the first video or image from the response
        let videoUrl = anu.BK9[0]?.url || "No video found";
        let thumbnail = anu.BK9[0]?.thumbnail;

        // Send the video
        await XliconBotInc.sendMessage(m.chat, {
          video: { url: videoUrl },
          caption: `Auto Download âœ…`,
          thumbnail: { url: thumbnail },
        }, { quoted: m });
      } else {
        await XliconBotInc.sendMessage(m.chat, { text: "Failed to fetch Instagram video." }, { quoted: m });
      }
      await XliconBotInc.sendMessage(m.chat, { react: { text: "â˜‘ï¸", key: m.key } });

    // Check for TikTok links
    } else if (budy.match(`tiktok.com`)) {
      await XliconBotInc.sendMessage(m.chat, { react: { text: "â±ï¸", key: m.key } });

      let anu = await fetchJson(`https://bk9.fun/download/tiktok?url=${encodeURIComponent(budy)}`);
      if (anu.status) {
        await XliconBotInc.sendMessage(m.chat, {
          video: { url: anu.BK9.BK9 },
          caption: `Auto Download âœ…`
        }, { quoted: m });
      } else {
        await XliconBotInc.sendMessage(m.chat, { text: "Failed to fetch TikTok video." }, { quoted: m });
      }
      await XliconBotInc.sendMessage(m.chat, { react: { text: "â˜‘ï¸", key: m.key } });

    // Check for Facebook links
    } else if (budy.match(`facebook.com`)) {
      await XliconBotInc.sendMessage(m.chat, { react: { text: "â±ï¸", key: m.key } });

      let anu = await fetchJson(`https://bk9.fun/download/fb?url=${encodeURIComponent(budy)}`);
      if (anu.status) {
        await XliconBotInc.sendMessage(m.chat, {
          video: { url: anu.BK9.hd },
          caption: `Auto Download âœ…`
        }, { quoted: m });
      } else {
        await XliconBotInc.sendMessage(m.chat, { text: "Failed to fetch Facebook video." }, { quoted: m });
      }
      await XliconBotInc.sendMessage(m.chat, { react: { text: "â˜‘ï¸", key: m.key } });

    // Check for YouTube links
    } else if (budy.match(`youtube.com|youtu.be`)) {
      await XliconBotInc.sendMessage(m.chat, { react: { text: "â±ï¸", key: m.key } });

      let anu = await fetchJson(`https://bk9.fun/download/youtube2?url=${encodeURIComponent(budy)}`);
      if (anu.status) {
        await XliconBotInc.sendMessage(m.chat, {
          video: { url: anu.BK9.BK9 },
          caption: `Auto Download âœ…`
        }, { quoted: m });
      } else {
        await XliconBotInc.sendMessage(m.chat, { text: "Failed to fetch YouTube video." }, { quoted: m });
      }
      await XliconBotInc.sendMessage(m.chat, { react: { text: "â˜‘ï¸", key: m.key } });
    }
  } catch (err) {
    console.error(err);
    await XliconBotInc.sendMessage(m.chat, { react: { text: "âœ–ï¸", key: m.key } });
  }
}

//---------------------------------------------------------------------------------------------------------------------------//

// Group Settings
		if (m.isGroup) {
			// Mute
			if (db.groups[m.chat].mute && !XliconTheCreator) {
				return
			}

      
			// Anti Delete
			if (m.type == 'protocolMessage' && db.groups[m.chat].antidelete) {
				const mess = chatUpdate.messages[0].message.protocolMessage
				if (store.messages && store.messages[m.chat] && store.messages[m.chat].array) {
					const chats = store.messages[m.chat].array.find(a => a.id === mess.key.id);
					chats.msg.contextInfo = { mentionedJid: [chats.key.participant], isForwarded: true, forwardingScore: 1, quotedMessage: { conversation: '*Anti Deleteâ—*'}, ...chats.key }
					await XliconBotInc.relayMessage(m.chat, { [chats.type]: chats.msg }, {})
				}
			}
		}

//---------------------------------------------------------------------------------------------------------------------------//


		//user db //friend
        if (isCmd && !isUser) {
xliconverifieduser.push(sender)
fs.writeFileSync('./src/user.json', JSON.stringify(xliconverifieduser, null, 2))
}
	
//---------------------------------------------------------------------------------------------------------------------------//



//All games featres here

		// Check Expiry
		prem.expiredCheck(XliconBotInc, premium);
		
		// TicTacToe
let room = Object.values(game.tictactoe).find(room => room.id && room.game && room.state && room.id.startsWith('tictactoe') && [room.game.playerX, room.game.playerO].includes(m.sender) && room.state == 'PLAYING');
if (room) {
    let ok;
    let isWin = false;
    let isTie = false;
    let isSurrender = false;

    if (!/^([1-9]|(me)?giveup|surr?ender|off|skip)$/i.test(m.text)) return;

    isSurrender = !/^[1-9]$/.test(m.text);
    if (m.sender !== room.game.currentTurn) {
        if (!isSurrender) return true;
    }

    if (!isSurrender && 1 > (ok = room.game.turn(m.sender === room.game.playerO, parseInt(m.text) - 1))) {
        replygcxlicon({
            '-3': 'ğŸš« The game is over',
            '-2': 'âŒ Invalid',
            '-1': 'âš ï¸ Invalid Position',
            0: 'âš ï¸ Invalid Position',
        }[ok]);
        return true;
    }

    if (m.sender === room.game.winner) isWin = true;
    else if (room.game.board === 511) isTie = true;

    let arr = room.game.render().map(v => {
        return {
            X: 'âŒ',
            O: 'â­•',
            1: '1ï¸âƒ£',
            2: '2ï¸âƒ£',
            3: '3ï¸âƒ£',
            4: '4ï¸âƒ£',
            5: '5ï¸âƒ£',
            6: '6ï¸âƒ£',
            7: '7ï¸âƒ£',
            8: '8ï¸âƒ£',
            9: '9ï¸âƒ£',
        }[v];
    });

    if (isSurrender) {
        room.game._currentTurn = m.sender === room.game.playerX;
        isWin = true;
    }

    let winner = isSurrender ? room.game.currentTurn : room.game.winner;
    if (isWin) {
        global.db.users[m.sender].limit += 3;
        global.db.users[m.sender].uang += 3000;
    }

    let str = `ğŸ† *Room ID:* ${room.id}\n\n${arr.slice(0, 3).join('')}\n${arr.slice(3, 6).join('')}\n${arr.slice(6).join('')}\n\n${isWin ? `ğŸ‰ @${winner.split('@')[0]} *Wins!*` : isTie ? `ğŸ’” *Game Over*` : `ğŸ”„ *Turn* ${['âŒ', 'â­•'][1 * room.game._currentTurn]} (@${room.game.currentTurn.split('@')[0]})`}\nâŒ: @${room.game.playerX.split('@')[0]}\nâ­•: @${room.game.playerO.split('@')[0]}\n\nğŸ“ *Type* *surrender* to give up and admit defeat`;

    if ((room.game._currentTurn ^ isSurrender ? room.x : room.o) !== m.chat) {
        room[room.game._currentTurn ^ isSurrender ? 'x' : 'o'] = m.chat;
    }

    if (room.x !== room.o) await XliconBotInc.sendMessage(room.x, { text: str, mentions: parseMention(str) }, { quoted: m });
    await XliconBotInc.sendMessage(room.o, { text: str, mentions: parseMention(str) }, { quoted: m });

    if (isTie || isWin) {
        delete game.tictactoe[room.id];
    }
}

// Suit PvP
let roof = Object.values(game.suit).find(roof => roof.id && roof.status && [roof.p, roof.p2].includes(m.sender));
if (roof) {
    let win = '';
    let tie = false;

    if (m.sender == roof.p2 && /^(acc(ept)?|accept|yes|okay?|reject|no|later|nop(e.)?yes|y)/i.test(m.text) && m.isGroup && roof.status == 'wait') {
        if (/^(reject|no|later|n|nop(e.)?yes)/i.test(m.text)) {
            replygcxlicon(`ğŸ”´ @${roof.p2.split`@`[0]} *rejected the suit*,\nâŒ *suit cancelled*`);
            delete game.suit[roof.id];
            return true;
        }
        roof.status = 'play';
        roof.asal = m.chat;
        clearTimeout(roof.waktu);
        replygcxlicon(`ğŸŠ The suit has been sent to chat\n\nğŸ‘¤ @${roof.p.split`@`[0]} and @${roof.p2.split`@`[0]}\n\nâœï¸ *Please select a suit in the respective chat* https://wa.me/${botNumber.split`@`[0]}`);
        
        if (!roof.pilih) XliconBotInc.sendMessage(roof.p, { text: `ğŸ”„ *Please select* \n\nğŸª¨ Rock\nğŸ“„ Paper\nâœ‚ï¸ Scissors` }, { quoted: m });
        if (!roof.pilih2) XliconBotInc.sendMessage(roof.p2, { text: `ğŸ”„ *Please select* \n\nğŸª¨ Rock\nğŸ“„ Paper\nâœ‚ï¸ Scissors` }, { quoted: m });
        
        roof.waktu_milih = setTimeout(() => {
            if (!roof.pilih && !roof.pilih2) replygcxlicon(`ğŸš« Both players have no intention of playing,\nâŒ *Suit cancelled*`);
            else if (!roof.pilih || !roof.pilih2) {
                win = !roof.pilih ? roof.p2 : roof.p;
                replygcxlicon(`âŒ @${(roof.pilih ? roof.p2 : roof.p).split`@`[0]} didn't choose a suit, the game ends`);
            }
            delete game.suit[roof.id];
            return true;
        }, roof.timeout);
    }

    let jwb = m.sender == roof.p;
    let jwb2 = m.sender == roof.p2;
    let g = /scissors/i;
    let b = /rock/i;
    let k = /paper/i;
    let reg = /^(scissors|rock|paper)/i;

    if (jwb && reg.test(m.text) && !roof.pilih && !m.isGroup) {
        roof.pilih = reg.exec(m.text.toLowerCase())[0];
        roof.text = m.text;
        replygcxlicon(`âœ… You have chosen *${m.text}* ${!roof.pilih2 ? `\nâ³ Waiting for the opponent to choose` : ''}`);
        if (!roof.pilih2) XliconBotInc.sendMessage(roof.p2, { text: '_The opponent has already chosen_\nâš ï¸ *Now it is your turn*' });
    }

    if (jwb2 && reg.test(m.text) && !roof.pilih2 && !m.isGroup) {
        roof.pilih2 = reg.exec(m.text.toLowerCase())[0];
        roof.text2 = m.text;
        replygcxlicon(`âœ… You have chosen *${m.text}* ${!roof.pilih ? `\nâ³ Waiting for the opponent to choose` : ''}`);
        if (!roof.pilih) XliconBotInc.sendMessage(roof.p, { text: '_The opponent has already chosen_\nâš ï¸ *Now it is your turn*' });
    }

    let stage = roof.pilih;
    let stage2 = roof.pilih2;

    if (roof.pilih && roof.pilih2) {
        clearTimeout(roof.waktu_milih);
        
        if (b.test(stage) && g.test(stage2)) win = roof.p;
        else if (b.test(stage) && k.test(stage2)) win = roof.p2;
        else if (g.test(stage) && k.test(stage2)) win = roof.p;
        else if (g.test(stage) && b.test(stage2)) win = roof.p2;
        else if (k.test(stage) && b.test(stage2)) win = roof.p;
        else if (k.test(stage) && g.test(stage2)) win = roof.p2;
        else if (stage == stage2) tie = true;

        global.db.users[roof.p == win ? roof.p : roof.p2].limit += tie ? 0 : 3;
        global.db.users[roof.p == win ? roof.p : roof.p2].uang += tie ? 0 : 3000;

        XliconBotInc.sendMessage(roof.asal, { text: `ğŸ† *Suit Results* ${tie ? '\nğŸ”„ *SERIES*' : ''}\n\nğŸ‘¤ @${roof.p.split`@`[0]} (${roof.text}) ${tie ? '' : roof.p == win ? `ğŸ¥‡ *Win* \n` : `âŒ *Lost* \n`}\nğŸ‘¤ @${roof.p2.split`@`[0]} (${roof.text2}) ${tie ? '' : roof.p2 == win ? `ğŸ¥‡ *Win* \n` : `âŒ *Lost* \n`}\n\nğŸ’° *Winner Gets*\n*Present:* Money (3000) & Limit (3)`.trim(), mentions: [roof.p, roof.p2] }, { quoted: m });

        delete game.suit[roof.id];
    }
}

        // Guess Bomb
		let pilih = 'ğŸŒ€', bomb = 'ğŸ’£';
		if (m.sender in game.tebakbom) {
			if (!/^[1-9]|10$/i.test(body) && !isCmd) return !0;
			if (game.tebakbom[m.sender].petak[parseInt(body) - 1] === 1) return !0;
			if (game.tebakbom[m.sender].petak[parseInt(body) - 1] === 2) {
				game.tebakbom[m.sender].board[parseInt(body) - 1] = bomb;
				game.tebakbom[m.sender].pick++;
				XliconBotInc.sendMessage(m.chat, {react: {text: 'âŒ', key: m.key}})
				game.tebakbom[m.sender].bomb--;
				game.tebakbom[m.sender].nyawa.pop();
				let brd = game.tebakbom[m.sender].board;
				if (game.tebakbom[m.sender].nyawa.length < 1) {
					global.db.users[m.sender].limit -= 1
					await replygcxlicon(`*THE GAME IS OVER*\nYou were hit by a bomb\n\n ${brd.join('')}\n\n*Selected :* ${game.tebakbom[m.sender].pick}\n_Limit Reduction : 1_`);
					XliconBotInc.sendMessage(m.chat, {react: {text: 'ğŸ˜‚', key: m.key}})
					delete game.tebakbom[m.sender];
				} else await replygcxlicon(`*SELECT A NUMBER*\n\nYou were hit by a bomb\n ${brd.join('')}\n\nSelected: ${game.tebakbom[m.sender].pick}\nRemaining life: ${game.tebakbom[m.sender].nyawa}`);
				return !0;
			}
			if (game.tebakbom[m.sender].petak[parseInt(body) - 1] === 0) {
				game.tebakbom[m.sender].petak[parseInt(body) - 1] = 1;
				game.tebakbom[m.sender].board[parseInt(body) - 1] = pilih;
				game.tebakbom[m.sender].pick++;
				game.tebakbom[m.sender].lolos--;
				let brd = game.tebakbom[m.sender].board;
				if (game.tebakbom[m.sender].lolos < 1) {
					global.db.users[m.sender].limit += 3
					global.db.users[m.sender].uang += 3000
					await replygcxlicon(`*YOU ARE GREAT à² â á´¥â à² *\n\n${brd.join('')}\n\n*Selected :* ${game.tebakbom[m.sender].pick}\n*Remaining life :* ${game.tebakbom[m.sender].nyawa}\n*Bomb :* ${game.tebakbom[m.sender].bomb}\n*Present :* Money(3000) & Limit(3)`);
					delete game.tebakbom[m.sender];
				} else replygcxlicon(`*SELECT A NUMBER*\n\n${brd.join('')}\n\nSelected : ${game.tebakbom[m.sender].pick}\nRemaining life : ${game.tebakbom[m.sender].nyawa}\nBomb : ${game.tebakbom[m.sender].bomb}`)
			}
		}
		
		// Math
		if (game.kuismath.hasOwnProperty(m.sender.split('@')[0]) && isCmd) {
			kuis = true
			jawaban = game.kuismath[m.sender.split('@')[0]].jawaban
			const difficultyMap = { 'noob': 1, 'easy': 2, 'medium': 3, 'hard': 4, 'extreme': 5, 'impossible': 6, 'impossible2': 7 };
			let hasilLimit = difficultyMap[game.kuismath[m.sender.split('@')[0]].mode]
			if (isNaN(budy)) return
			if (budy.toLowerCase() == jawaban) {
				global.db.users[m.sender].limit += hasilLimit
				global.db.users[m.sender].uang += hasilLimit * 1000
				await replygcxlicon(`ğŸ® Math Quiz  ğŸ®\n\nCorrect answer ğŸ‰\nYou Get a Limit *${hasilLimit}*\n\nWant to play again? Send ${prefix}math mode`)
				delete game.kuismath[m.sender.split('@')[0]]
			} else replygcxlicon('*Wrong answer!*')
		}
		
		// Menfes
		if (!m.isGroup) {
			if (game.menfes[m.sender] && m.key.remoteJid !== 'status@broadcast') {
				if (!/^del(menfe(s|ss)|confe(s|ss))$/i.test(command)) {
					m.msg.contextInfo = { isForwarded: true, forwardingScore: 1, quotedMessage: { conversation: `*Order From ${game.menfes[m.sender].nama ? game.menfes[m.sender].nama : 'Somebody'}*`}, key: { remoteJid: '0@s.whatsapp.net', fromMe: false, participant: '0@s.whatsapp.net' }}
					const pesan = m.type === 'conversation' ? { extendedTextMessage: { text: m.msg, contextInfo: { isForwarded: true, forwardingScore: 1, quotedMessage: { conversation: `*Order From ${game.menfes[m.sender].nama ? game.menfes[m.sender].nama : 'Somebody'}*`}, key: { remoteJid: '0@s.whatsapp.net', fromMe: false, participant: '0@s.whatsapp.net' }}}} : { [m.type]: m.msg }
					await XliconBotInc.relayMessage(game.menfes[m.sender].tujuan, pesan, {});
				}
			}
		}



//game features end here    
//---------------------------------------------------------------------------------------------------------------------------//




//reply features
		// AFK
let mentionUser = [...new Set([...(m.mentionedJid || []), ...(m.quoted ? [m.quoted.sender] : [])])];
for (let jid of mentionUser) {
    let user = global.db.users[jid];
    if (!user) continue;
    let afkTime = user.afkTime;
    if (!afkTime || afkTime < 0) continue;
    let reason = user.afkReason || '';
    replygcxlicon(`ğŸš« *Don't tag him!*\nğŸ•’ He's AFK ${reason ? 'with reason: *' + reason + '*' : '*with no reason*'}\nâ³ During: *${clockString(new Date - afkTime)}*`.trim());
}
if (global.db.users[m.sender].afkTime > -1) {
    let user = global.db.users[m.sender];
    replygcxlicon(`âœ… @${m.sender.split('@')[0]} *berhenti AFK*${user.afkReason ? ' *after* ' + user.afkReason : ''}\nâ³ During: *${clockString(new Date - user.afkTime)}*`);
    user.afkTime = -1;
    user.afkReason = '';
}



		//reply
        async function replygcxlicon(teks) {
            if (typereply === 'v1') {
               m.reply(teks)

            } else if (typereply === 'v2') {
                XliconBotInc.sendMessage(m.chat, {
                    contextInfo: {
                        externalAdReply: {
                            showAdAttribution: true,
                            title: botname,
                            body: ownername,
                            previewType: "PHOTO",
                            thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
                            sourceUrl: wagc
                        }
                    },
                    text: teks
                }, {
                    quoted: m
                });

            } else if (typereply === 'v3') {
               XliconBotInc.sendMessage(m.chat, {
                  text: teks,
                  contextInfo: {
                     externalAdReply: {
                        showAdAttribution: true,
                        title: botname,
                        body: ownername,
                        thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
                        sourceUrl: websitex,
                        mediaType: 1,
                        renderLargerThumbnail: true
                     }
                  }
               }, { quoted: m })

            } else if (typereply === 'v4') {
                replygcxlicon2(teks)
            }
        }

        
//fake reply with channel link embedded
async function replygcxlicon2(txt) {
const xliconnewrep = {      
contextInfo: {
forwardingScore: 999,
isForwarded: true,
forwardedNewsletterMessageInfo: {
newsletterName: "Click here to get $69",
newsletterJid: "120363232303807350@newsletter",
},
externalAdReply: {  
showAdAttribution: true,
title: botname,
body: ownername,
thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
sourceUrl: websitex
},
},
text: txt,
}
return XliconBotInc.sendMessage(m.chat, xliconnewrep, {
quoted: m,
})
}

//---------------------------------------------------------------------------------------------------------------------------//

//premium
        async function replyprem(teks) {
    replygcxlicon(`ğŸš¨ *This feature is for premium users only!*\nğŸ’¬ *Contact the owner* to become a premium user!`);
}


//script replier
        async function sendXliconBotIncMessage(chatId, message, options = {}){
    let generate = await generateWAMessage(chatId, message, options)
    let type2 = getContentType(generate.message)
    if ('contextInfo' in options) generate.message[type2].contextInfo = options?.contextInfo
    if ('contextInfo' in message) generate.message[type2].contextInfo = message?.contextInfo
    return await XliconBotInc.relayMessage(chatId, generate.message, { messageId: generate.key.id })
}
//---------------------------------------------------------------------------------------------------------------------------//


//theme sticker reply
        const XliconStickWait = () => {
        let XliconStikRep = fs.readFileSync('./XliconMedia/theme/sticker_reply/wait.webp')
        XliconBotInc.sendMessage(m.chat, { sticker: XliconStikRep }, { quoted: m })
        }
        const XliconStickAdmin = () => {
        let XliconStikRep = fs.readFileSync('./XliconMedia/theme/sticker_reply/admin.webp')
        XliconBotInc.sendMessage(m.chat, { sticker: XliconStikRep }, { quoted: m })
        }
        const XliconStickBotAdmin = () => {
        let XliconStikRep = fs.readFileSync('./XliconMedia/theme/sticker_reply/botadmin.webp')
        XliconBotInc.sendMessage(m.chat, { sticker: XliconStikRep }, { quoted: m })
        }
        const XliconStickOwner = () => {
        let XliconStikRep = fs.readFileSync('./XliconMedia/theme/sticker_reply/owner.webp')
        XliconBotInc.sendMessage(m.chat, { sticker: XliconStikRep }, { quoted: m })
        }
        const XliconStickGroup = () => {
        let XliconStikRep = fs.readFileSync('./XliconMedia/theme/sticker_reply/group.webp')
        XliconBotInc.sendMessage(m.chat, { sticker: XliconStikRep }, { quoted: m })
        }
        const XliconStickPrivate = () => {
        let XliconStikRep = fs.readFileSync('./XliconMedia/theme/sticker_reply/private.webp')
        XliconBotInc.sendMessage(m.chat, { sticker: XliconStikRep }, { quoted: m })
        }
  
//theme sticker reply end here        
//---------------------------------------------------------------------------------------------------------------------------//


//time
const xday = moment.tz('Asia/Karachi').locale('en-IN').format('dddd');
const xdate = moment.tz('Asia/Karachi').locale('en-IN').format('DD/MM/YYYY');
const xtime = moment().tz('Asia/Karachi').locale('en-IN').format('HH:mm:ss');
const time2 = moment().tz('Asia/Karachi').format('HH:mm:ss')  
if(time2 < "23:59:00"){
var xliconytimewisher = `Good Night ğŸŒŒ`
 }
 if(time2 < "19:00:00"){
var xliconytimewisher = `Good Evening ğŸŒƒ`
 }
 if(time2 < "18:00:00"){
var xliconytimewisher = `Good Evening ğŸŒƒ`
 }
 if(time2 < "15:00:00"){
var xliconytimewisher = `Good Afternoon ğŸŒ…`
 }
 if(time2 < "11:00:00"){
var xliconytimewisher = `Good Morning ğŸŒ„`
 }
 if(time2 < "05:00:00"){
var xliconytimewisher = `Good Morning ğŸŒ„`
 } 

//---------------------------------------------------------------------------------------------------------------------------//

//theme txt
let setv = pickRandom(global.listv)

//autoreply
for (let BhosdikaXlicon of VoiceNoteXlicon) {
if (budy === BhosdikaXlicon) {
let audiobuffy = fs.readFileSync(`./XliconMedia/audio/${BhosdikaXlicon}.mp3`)
XliconBotInc.sendMessage(m.chat, { audio: audiobuffy, mimetype: 'audio/mp4', ptt: true }, { quoted: m })     
}
}
for (let BhosdikaXlicon of StickerXlicon){
if (budy === BhosdikaXlicon){
let stickerbuffy = fs.readFileSync(`./XliconMedia/sticker/${BhosdikaXlicon}.webp`)
XliconBotInc.sendMessage(m.chat, { sticker: stickerbuffy }, { quoted: m })
}
}
for (let BhosdikaXlicon of ImageXlicon){
if (budy === BhosdikaXlicon){
let imagebuffy = fs.readFileSync(`./XliconMedia/image/${BhosdikaXlicon}.jpg`)
XliconBotInc.sendMessage(m.chat, { image: imagebuffy }, { quoted: m })
}
}
for (let BhosdikaXlicon of VideoXlicon){
if (budy === BhosdikaXlicon){
let videobuffy = fs.readFileSync(`./XliconMedia/video/${BhosdikaXlicon}.mp4`)
XliconBotInc.sendMessage(m.chat, { video: videobuffy }, { quoted: m })
}
}

//reply features end here
//---------------------------------------------------------------------------------------------------------------------------//



//send features
const sendapk = (teks) => {
XliconBotInc.sendMessage(m.chat, { document: teks, mimetype: 'application/vnd.android.package-archive'}, {quoted:m})
}
for (let BhosdikaXlicon of ApkXlicon) {
if (budy === BhosdikaXlicon) {
let buffer = fs.readFileSync(`./XliconMedia/apk/${BhosdikaXlicon}.apk`)
sendapk(buffer)
}
}

const sendzip = (teks) => {
XliconBotInc.sendMessage(m.chat, { document: teks, mimetype: 'application/zip'}, {quoted:m})
}
for (let BhosdikaXlicon of ZipXlicon) {
if (budy === BhosdikaXlicon) {
let buffer = fs.readFileSync(`./XliconMedia/zip/${BhosdikaXlicon}.zip`)
sendzip(buffer)
}
}

const senddocu = (teks) => {
XliconBotInc.sendMessage(m.chat, { document: teks, mimetype: 'application/pdf'}, {quoted:m})
}
for (let BhosdikaXlicon of DocXlicon) {
if (budy === BhosdikaXlicon) {
let buffer = fs.readFileSync(`./XliconMedia/doc/${BhosdikaXlicon}.pdf`)
senddocu(buffer)
}
}



async function obfus(query) {
    return new Promise((resolve, reject) => {
        try {
        const obfuscationResult = jsobfus.obfuscate(query,
        {
            compact: false,
            controlFlowFlattening: true,
            controlFlowFlatteningThreshold: 1,
            numbersToExpressions: true,
            simplify: true,
            stringArrayShuffle: true,
            splitStrings: true,
            stringArrayThreshold: 1
        }
        )
        const result = {
            status: 200,
            author: `${ownername}`,
            result: obfuscationResult.getObfuscatedCode()
        }
        resolve(result)
    } catch (e) {
        reject(e)
    }
    })
}

//send features end here
//---------------------------------------------------------------------------------------------------------------------------//




// Response Addlist
if (m.isGroup && isAlreadyResponList(m.chat, body.toLowerCase(), db_respon_list)) {
var get_data_respon = getDataResponList(m.chat, body.toLowerCase(), db_respon_list)
if (get_data_respon.isImage === false) {
XliconBotInc.sendMessage(m.chat, { text: sendResponList(m.chat, body.toLowerCase(), db_respon_list) }, {
quoted: m
})
} else {
XliconBotInc.sendMessage(m.chat, { image: await getBuffer(get_data_respon.image_url), caption: get_data_respon.response }, {
quoted: m
})
} 
}



// Respon Cmd with media
if (isMedia && m.msg.fileSha256 && (m.msg.fileSha256.toString('base64') in global.db.sticker)) {
let hash = global.db.sticker[m.msg.fileSha256.toString('base64')]
let { text, mentionedJid } = hash
let messages = await generateWAMessage(m.chat, { text: text, mentions: m.mentionedJid }, {
    userJid: XliconBotInc.user.id,
    quoted: m.quoted && m.quoted.fakeObj
})
messages.key.fromMe = areJidsSameUser(m.sender, XliconBotInc.user.id)
messages.key.id = m.key.id
messages.pushName = m.pushName
if (m.isGroup) messages.participant = m.sender
let msg = {
    ...chatUpdate,
    messages: [proto.WebMessageInfo.fromObject(messages)],
    type: 'append'
}
XliconBotInc.ev.emit('messages.upsert', msg)
} 

//---------------------------------------------------------------------------------------------------------------------------//




switch(isCommand) {


//FUN COMMANDS 
 case 'gaycheck':
case 'cutecheck':
case 'lesbicheck':
case 'lesbiancheck':
case 'hornycheck':
case 'prettycheck':
case 'lovelycheck':
case 'uglycheck':
case 'handsomecheck': {
    // Ensure someone is tagged
    if (!m.mentionedJid || m.mentionedJid.length === 0) {
        return replygcxlicon(`Please mention someone to check! Example: ${prefix + command} @Xlicon`);
    }

    // Generate a random percentage
    const gan = Array.from({ length: 100 }, (_, i) => i + 1);
    const teng = gan[Math.floor(Math.random() * gan.length)];

    // Get the first mentioned user
    let xliconshimts = m.mentionedJid[0];

    // Create the message text
    const messageText = `
*${command.replace('check', ' Check')}* ğŸŒŸ

ğŸ‘¤ Name: *@${xliconshimts.split('@')[0]}*
ğŸ“Š Score: *${teng}%*
`.trim();

    // Image URL to use (this can be customized)
    const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';

    try {
        // Send the message with the image URL
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: imageUrl }, // Directly use the URL for the image
            caption: messageText, // Custom message with check result and mentioned user
            mentions: [xliconshimts] // Mentions the mentioned user
        });
    } catch (error) {
        console.error('Error sending image:', error);
        replygcxlicon('Failed to send image. Please try again later.');
    }
}
break;


  
      case 'charactercheck': {
        if (!m.mentionedJid || m.mentionedJid.length === 0) {
            return replygcxlicon(`Please tag someone! Example: ${prefix + command} @Xlicon`);
        }
    
        const traits = [
            'Compassionate', 
            'Generous', 
            'Grumpy', 
            'Forgiving', 
            'Obedient', 
            'Good', 
            'Simp', 
            'Kind-Hearted', 
            'Patient', 
            'UwU', 
            'Top, anyway', 
            'Helpful'
        ];
        const randomTrait = traits[Math.floor(Math.random() * traits.length)];
    
        const mentionedUser = m.mentionedJid[0];
        const username = mentionedUser.split('@')[0];
    
        const messageText = `
*Character Check* ğŸ•µï¸â€â™‚ï¸âœ¨
    
ğŸ‘¤ Name: *@${username}*
ğŸ“œ Trait: *${randomTrait}*
        `.trim();
    
        const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg'; // Replace with your desired image URL
    
        try {
            // Send the message with the image URL
            await XliconBotInc.sendMessage(m.chat, {
                image: { url: imageUrl },
                caption: messageText,
                mentions: [mentionedUser],
            });
        } catch (error) {
            console.error('Error sending image:', error);
            replygcxlicon('Failed to send image. Please try again later.');
        }
    }
    break;

  case 'beautifulcheck': {
    // Ensure someone is tagged
    if (!m.mentionedJid || m.mentionedJid.length === 0) {
        return replygcxlicon(`Please tag someone! Example: ${prefix + command} @Xlicon`);
    }

    // Generate a random percentage
    const percentage = Math.floor(Math.random() * 101); // Random number between 0 and 100

    // Get the first mentioned user
    const mentionedUser = m.mentionedJid[0];
    const username = mentionedUser.split('@')[0];

    // Create the response message
    const messageText = `
*Beautiful Check* ğŸŒ¸

ğŸ‘¤ Name: *@${username}*
ğŸ“Š Score: *${percentage}%*
    `.trim();

    // Image URL to use (this can be customized)
    const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg'; // Replace with your desired image URL

    try {
        // Send the message with the image and mentions
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: imageUrl }, // Directly use the URL for the image
            caption: messageText, // Custom message with check result and mentioned user
            mentions: [mentionedUser] // Mentions the mentioned user
        });
    } catch (error) {
        console.error('Error sending image:', error);
        replygcxlicon('Failed to send image. Please try again later.');
    }
}
break;



  case 'gura':
case 'gurastick':{
var ano = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/main/gura')
var wifegerak = ano.split('\n')
var wifegerakx = wifegerak[Math.floor(Math.random() * wifegerak.length)]
encmedia = await XliconBotInc.sendImageAsSticker(m.chat, wifegerakx, m, { packname: global.packname, author: global.author, })

}
break

			case 'rentbot':
    // Image URL to use (this can be customized)
    const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg'; // Replace with your desired image URL

    // Message text with emojis
    const messageText = `Type ${prefix}owner and chat him ğŸ’¬ğŸ‘‘`;

    // Send the message with the image and the text
    await XliconBotInc.sendMessage(m.chat, {
        image: { url: imageUrl }, // Directly use the URL for the image
        caption: messageText, // The custom message with emojis
    });
    break;

        
        
 case 'idgroup': 
case 'idgc': 
case 'groupid': {
    if (!XliconTheCreator) return XliconStickOwner();
    try {
        let getGroups = await XliconBotInc.groupFetchAllParticipating();
        let groups = Object.entries(getGroups).slice(0).map((entry) => entry[1]);
        let anu = groups.map((v) => v.id);
        let teks = `ğŸ’¬ *GROUP LIST BELOW* ğŸŒŸ\n\nğŸ“ Total Groups: *${anu.length}* Groups\n\n`;

        for (let x of anu) {
            try {
                let metadata2 = await XliconBotInc.groupMetadata(x);
                teks += `ğŸŒ *Group Name*: ${metadata2.subject}\nğŸ†” *Group ID*: ${metadata2.id}\nğŸ‘¥ *Members*: ${metadata2.participants.length}\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n`;
            } catch (err) {
                teks += `âŒ Error fetching metadata for group ID: ${x}\n`;
            }
        }

        replygcxlicon(teks + `âš¡ To use, please type command: ${prefix}pushcontact idgroup|teks\n\nBefore using, please first copy the group ID above. ğŸ‘‡`);
    } catch (err) {
        replygcxlicon("âš ï¸ There was an error while fetching the group list. Please try again later.");
    }
}
break;
  
        
case 'repo': case 'repository': {
  try {
    const [, username, repoName] = botscript.match(/github\.com\/([^/]+)\/([^/]+)/)
    const response = await axios.get(`https://api.github.com/repos/${username}/${repoName}`)
    if (response.status === 200) {
      const repoData = response.data
      const formattedInfo = `
âœ¨ *Repository Name:* _${repoData.name}_
ğŸ“„ *Description:* _${repoData.description || 'No description provided.'}_
ğŸ‘¤ *Owner:* _${repoData.owner.login}_
â­ *Stars:* _${repoData.stargazers_count}_
ğŸ´ *Forks:* _${repoData.forks_count}_
ğŸ”— *URL:* ${repoData.html_url}
      `.trim()
      await XliconBotInc.relayMessage(m.chat, {
        requestPaymentMessage: {
          currencyCodeIso4217: 'USD',
          amount1000: 69000,
          requestFrom: m.sender,
          noteMessage: {
            extendedTextMessage: {
              text: formattedInfo,
              contextInfo: {
                externalAdReply: {
                  showAdAttribution: true
                }
              }
            }
          }
        }
      }, { quoted: m })
    } else {
      await replygcxlicon(`Unable to fetch repository information`)
    }
  } catch (error) {
    console.error(error)
    await replygcxlicon(`Repository currently not available`)
  }
}
break

			
            case 'myip':
            case 'ipbot':
                if (!XliconTheCreator) return XliconStickOwner()
                var http = require('http')
                http.get({
                    'host': 'api.ipify.org',
                    'port': 80,
                    'path': '/'
                }, function(resp) {
                    resp.on('data', function(ip) {
                        replygcxlicon("ğŸ” My public IP address is: " + ip);
                    })
                })
            break
        
           
    case 'request': case 'reportbug': {
    if (!text) return replygcxlicon(`Example : ${prefix + command} hi dev play command is not working ğŸ`);

    const textt = `*| REQUEST/BUG |* ğŸ“`;
    const teks1 = `\n\n*User* : @${m.sender.split("@")[0]} ğŸ‘¤\n*Request/Bug* : ${text} ğŸ› ï¸`;
    const teks2 = `\n\n*Hii ${m.pushName},* Your request has been forwarded to my Owners ğŸ‘‘.\n*Please wait...* â³`;

    // Send to all owners
    for (let i of owner) {
        XliconBotInc.sendMessage(i + "@s.whatsapp.net", {
            text: textt + teks1,
            mentions: [m.sender],
        }, {
            quoted: m,
        });
    }

    // Send response to the user
    XliconBotInc.sendMessage(m.chat, {
        text: textt + teks2 + teks1,
        mentions: [m.sender],
    }, {
        quoted: m,
    });
}
break;
    
case 'socialmedia': 
case 'sosmed': 
case 'update': {
    const slides = [
        [
            'https://upload.wikimedia.org/wikipedia/commons/e/ef/Youtube_logo.png', // Image URL
            '', // Title
            `ğŸ¥ *Subscribe to the Developer's YouTube Channel for Updates*`, // Body message
            botname, // Footer message
            'ğŸ”— Visit', // Button display text
            'https://youtube.com/@s4salmanyt', // Command (URL in this case)
            'cta_url', // Button type
            'https://youtube.com/@s4salmanyt' // URL (used in image generation)
        ], 
        [
            'https://upload.wikimedia.org/wikipedia/commons/thumb/8/83/Telegram_2019_Logo.svg/1024px-Telegram_2019_Logo.svg.png', // Image URL
            '', // Title
            `ğŸ“± *Join the Developer's Telegram Channel for Updates*`, // Body message
            botname, // Footer message
            'ğŸ”— Visit', // Button display text
            'https://t.me/ahmmitech', // Command (URL in this case)
            'cta_url', // Button type
            'https://t.me/ahmmitech' // URL (used in image generation)
        ], 
        [
            'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c2/GitHub_Invertocat_Logo.svg/360px-GitHub_Invertocat_Logo.svg.png', // Image URL
            '', // Title
            `ğŸ± *Follow the Developer on GitHub*`, // Body message
            botname, // Footer message
            'ğŸ”— Visit', // Button display text
            'https://github.com/salmanytofficial', // Command (URL in this case)
            'cta_url', // Button type
            'https://github.com/salmanytofficial' // URL (used in image generation)
        ], 
        [
            'https://upload.wikimedia.org/wikipedia/commons/thumb/e/e7/Instagram_logo_2016.svg/264px-Instagram_logo_2016.svg.png', // Image URL
            '', // Title
            `ğŸ“¸ *Follow the Developer on Instagram*`, // Body message
            botname, // Footer message
            'ğŸ”— Visit', // Button display text
            'https://www.instagram.com/ahmmikun', // Command (URL in this case)
            'cta_url', // Button type
            'https://www.instagram.com/ahmmikun' // URL (used in image generation)
        ], 
        [
            'https://upload.wikimedia.org/wikipedia/commons/thumb/6/6b/WhatsApp.svg/1024px-WhatsApp.svg.png', // Image URL
            '', // Title
            `ğŸ’¬ *Contact the Developer on WhatsApp*`, // Body message
            botname, // Footer message
            'ğŸ”— Visit', // Button display text
            'https://Wa.me/916909137213', // Command (URL in this case)
            'cta_url', // Button type
            'https://Wa.me/916909137213' // URL (used in image generation)
        ], 
    ];

    const sendSlide = async (jid, title, message, footer, slides) => {
        const cards = slides.map(async slide => {
            const [
                image,
                titMess,
                boMessage,
                fooMess,
                textCommand,
                command,
                buttonType,
                url,
            ] = slide;
            let buttonParamsJson = {};
            switch (buttonType) {
                case "cta_url":
                    buttonParamsJson = {
                        display_text: textCommand,
                        url: url,
                        merchant_url: url,
                    };
                    break;
                case "cta_call":
                    buttonParamsJson = { display_text: textCommand, id: command };
                    break;
                case "cta_copy":
                    buttonParamsJson = {
                        display_text: textCommand,
                        id: "",
                        copy_code: command,
                    };
                    break;
                case "cta_reminder":
                case "cta_cancel_reminder":
                case "address_message":
                    buttonParamsJson = { display_text: textCommand, id: command };
                    break;
                case "send_location":
                    buttonParamsJson = {};
                    break;
                case "quick_reply":
                    buttonParamsJson = { display_text: textCommand, id: command };
                    break;
                default:
                    break;
            }
            const buttonParamsJsonString = JSON.stringify(buttonParamsJson);
            return {
                body: proto.Message.InteractiveMessage.Body.fromObject({
                    text: boMessage,
                }),
                footer: proto.Message.InteractiveMessage.Footer.fromObject({
                    text: fooMess,
                }),
                header: proto.Message.InteractiveMessage.Header.fromObject({
                    title: titMess,
                    hasMediaAttachment: true,
                    ...(await prepareWAMessageMedia(
                        { image: { url: image } },
                        { upload: XliconBotInc.waUploadToServer },
                    )),
                }),
                nativeFlowMessage:
                    proto.Message.InteractiveMessage.NativeFlowMessage.fromObject({
                        buttons: [
                            {
                                name: buttonType,
                                buttonParamsJson: buttonParamsJsonString,
                            },
                        ],
                    }),
            };
        });
        
        const msg = generateWAMessageFromContent(
            jid,
            {
                viewOnceMessage: {
                    message: {
                        messageContextInfo: {
                            deviceListMetadata: {},
                            deviceListMetadataVersion: 2,
                        },
                        interactiveMessage: proto.Message.InteractiveMessage.fromObject({
                            body: proto.Message.InteractiveMessage.Body.fromObject({
                                text: message,
                            }),
                            footer: proto.Message.InteractiveMessage.Footer.fromObject({
                                text: footer,
                            }),
                            header: proto.Message.InteractiveMessage.Header.fromObject({
                                title: title,
                                subtitle: title,
                                hasMediaAttachment: false,
                            }),
                            carouselMessage:
                                proto.Message.InteractiveMessage.CarouselMessage.fromObject({
                                    cards: await Promise.all(cards),
                                }),
                            contextInfo: {
                                mentionedJid: [m.sender], 
                                forwardingScore: 999,
                                isForwarded: true,
                                forwardedNewsletterMessageInfo: {
                                    newsletterJid: '120363232303807350@newsletter',
                                    newsletterName: ownername,
                                    serverMessageId: 143
                                }
                            }
                        }),
                    },
                },
            },
            { quoted: m},
        );
        await XliconBotInc.relayMessage(jid, msg.message, {
            messageId: msg.key.id,
        });
    };

    // Send the slide to the group or user
    await sendSlide(m.chat, 'Social Media Links', 'Check out the Developerâ€™s social media for updates!', botname, slides);

    // Send the social media links in a formatted way
    await replygcxlicon(`
Here are the Developer's Social Media Links for Updates:

ğŸ¥ *Subscribe to the Developer's YouTube Channel for Updates*  
ğŸ”— Visit: https://youtube.com/@s4salmanyt

ğŸ“± *Join the Developer's Telegram Channel for Updates*  
ğŸ”— Visit: https://t.me/ahmmitech

ğŸ± *Follow the Developer on GitHub*  
ğŸ”— Visit: https://github.com/salmanytofficial

ğŸ“¸ *Follow the Developer on Instagram*  
ğŸ”— Visit: https://www.instagram.com/ahmmikun

ğŸ’¬ *Contact the Developer on WhatsApp*  
ğŸ”— Visit: https://Wa.me/916909137213

For more updates, check out the links above!
`);

    // Send a regular reply to confirm the action
    await replygcxlicon('Here are the social media links and updates for the Developer! ğŸŒâœ¨');
}
break;




			case 'gita-verse': case 'gita': case 'bhagavatgita': {
	try {
    // Extract the verse number from the command text.
    let verseNumber = m.text.split(' ')[1]
    if (!verseNumber || isNaN(verseNumber)) {
      verseNumber = Math.floor(Math.random() * 700) + 1
    }
    let res = await fetch(`https://gita-api.vercel.app/odi/verse/${verseNumber}`)
    if (!res.ok) {
      let error = await res.json()
      throw new Error(
        `API request failed with status ${res.status} and message ${error.detail[0].msg}`
      )
    }
    let json = await res.json()
    console.log('JSON response:', json)
    let gitaVerse = `
ğŸ•‰ *Bhagavad Gita: Sacred Teachings*\n
ğŸ“œ *Chapter ${json.chapter_no}: ${json.chapter_name}*\n
Verse ${json.verse_no}:\n
" ${json.verse} "\n
*ğŸ”® Translation:*\n
${json.translation}\n
*ğŸ§˜â€â™‚ï¸ Spiritual Insight (Purport):*\n
${json.purport}`
    replygcxlicon(gitaVerse)
    if (json.audio_link) {
      XliconBotInc.sendMessage(m.chat, {audio: {url:json.audio_link}, mimetype: 'audio/mp4', ptt: true}, {quoted:m})
    }
  } catch (error) {
    console.error(error)
    // Handle the error appropriately
  }
}
break

			case 'quran': {
    try {
    // Extract the surah number or name from the command text.
    let surahInput = m.text.split(' ')[1]
    if (!surahInput) {
      throw new Error(`Please specify the surah number or name`)
    }
    let surahListRes = await fetch('https://quran-endpoint.vercel.app/quran')
    let surahList = await surahListRes.json()
    let surahData = surahList.data.find(surah => 
        surah.number === Number(surahInput) || 
        surah.asma.ar.short.toLowerCase() === surahInput.toLowerCase() || 
        surah.asma.en.short.toLowerCase() === surahInput.toLowerCase()
    )
    if (!surahData) {
      throw new Error(`Couldn't find surah with number or name "${surahInput}"`)
    }
    let res = await fetch(`https://quran-endpoint.vercel.app/quran/${surahData.number}`)
    if (!res.ok) {
      let error = await res.json();
      throw new Error(`API request failed with status ${res.status} and message ${error.message}`)
    }

    let json = await res.json()

    // Translate tafsir from Bahasa Indonesia to Urdu
    let translatedTafsirUrdu = await translate(json.data.tafsir.id, { to: 'ur', autoCorrect: true })

    // Translate tafsir from Bahasa Indonesia to English
    let translatedTafsirEnglish = await translate(json.data.tafsir.id, { to: 'en', autoCorrect: true })

    let quranSurah = `
ğŸ•Œ *Quran: The Holy Book*\n
ğŸ“œ *Surah ${json.data.number}: ${json.data.asma.ar.long} (${json.data.asma.en.long})*\n
Type: ${json.data.type.en}\n
Number of verses: ${json.data.ayahCount}\n
ğŸ”® *Explanation (Urdu):*\n
${translatedTafsirUrdu.text}\n
ğŸ”® *Explanation (English):*\n
${translatedTafsirEnglish.text}`

    replygcxlicon(quranSurah)

    if (json.data.recitation.full) {
      XliconBotInc.sendMessage(m.chat, { audio: {url: json.data.recitation.full}, mimetype: 'audio/mp4', ptt: true, fileName: `recitation.mp3`, }, {quoted: m})
    }
  } catch (error) {
    replygcxlicon(`Error: ${error.message}`)
  }
  }
  break
			
    case 'animequote': {
  try {
    const res = await fetch('https://some-random-api.com/animu/quote');
    if (!res.ok) throw await res.text()
    const json = await res.json()
    const { sentence, character, anime } = json
    const message = `ğŸŒŸQuote\n${sentence}\n\nğŸŒŸCharacter: \`\`\`${character}\`\`\`\nğŸŒŸAnime: \`\`\`${anime}\`\`\`\n`
    
    // Send the message using replygcxlicon
    return replygcxlicon(message)
  } catch (error) {
    console.error(error)
  }
 }
  break


  case 'bible': {
  const { translate } = require('@vitalets/google-translate-api')
  const BASE_URL = 'https://bible-api.com'

  try {
    // Extract the chapter number or name from the command text.
    let chapterInput = m.text.split(' ').slice(1).join('').trim()
    if (!chapterInput) {
      throw new Error(`Please specify the chapter number or name. Example: ${prefix + command} john 3:16`)
    }

    // Encode the chapterInput to handle special characters
    chapterInput = encodeURIComponent(chapterInput);

    // Make an API request to fetch the chapter information.
    let chapterRes = await fetch(`${BASE_URL}/${chapterInput}`)
    if (!chapterRes.ok) {
      throw new Error(`Please specify the chapter number or name. Example: ${prefix + command} john 3:16`)
    }

    let chapterData = await chapterRes.json();

    // Translate the chapter content into Hindi and English
    let translatedChapterHindi = await translate(chapterData.text, { to: 'hi', autoCorrect: true })
    let translatedChapterEnglish = await translate(chapterData.text, { to: 'en', autoCorrect: true })

    // Format the Bible chapter message
    let bibleChapter = `ğŸ“– *The Holy Bible*\n
ğŸ“œ *Chapter ${chapterData.reference}*\n
Type: ${chapterData.translation_name}\n
Number of verses: ${chapterData.verses.length}\n
ğŸ”® *Chapter Content (English):*\n
${translatedChapterEnglish.text}\n
ğŸ”® *Chapter Content (Hindi):*\n
${translatedChapterHindi.text}`

    // Send the formatted message using replygcxlicon
    return replygcxlicon(bibleChapter)

  } catch (error) {
    replygcxlicon(`Error: ${error.message}`)
  }
 }     
  break



//------------------------------------------------------------------------------------------//
//New Islam Cmds

case 'namazchk': {
  // Poll options for prayer times
  const options = ['Fajr', 'Zuhr', 'Asr', 'Maghrib', 'Isha'];

  // Check if the user is authorized
  if (!XliconTheCreator) return XliconStickOwner();

  // Prepare the question and options for the poll
  const pollQuestion = 'Which prayer(s) did you offer?';
  try {
    // Send the poll with the prayer options
    await XliconBotInc.sendMessage(m.chat, {
      poll: {
        name: pollQuestion,
        values: options,
      }
    });
  } catch {
    replygcxlicon(
      `Error: Please make sure to provide at least 2 options for the poll.\nExample: ${prefix}poll Who is best admin?|Xlicon,Cheems,Doge...`
    );
  }
}
break;




case 'kisahnabi': {
  const prophets = [
      'adam', 'ayyub', 'daud', 'dzulkifli', 'harun', 'hud', 'ibrahim', 'idris', 
      'ilyas', 'ilyasa', 'isa', 'ishaq', 'ismail', 'luth', 'muhammad', 'musa', 
      'nuh', 'sholeh', 'sulaiman', 'syuaib', 'yahya', 'yaqub', 'yunus', 'yusuf', 'zakariya'
  ];

  // Ensure the text input is properly trimmed and lowercased
  const selectedProphet = text?.trim().toLowerCase();

  // Check if a text was provided
  if (!text) {
      const prophetList = prophets.map(prophet => `- ${prophet.charAt(0).toUpperCase() + prophet.slice(1)}`).join('\n');
      const message = `*Select a Prophet*\n\nPlease type the name of a prophet from the list below to read their story:\n\n${prophetList}`;
      await XliconBotInc.sendText(m.chat, message);
      return;
  }

  // Check if the selected prophet is valid
  if (!prophets.includes(selectedProphet)) {
      return XliconBotInc.sendText(
          m.chat, "*Not Found*\n*ğŸ“® Tips:* Please select a valid prophet from the list."
      );
  }

  // Fetch and display the story and image of the selected prophet
  try {
      const response = await fetch(`https://raw.githubusercontent.com/ZeroChanBot/Api-Freee/a9da6483809a1fbf164cdf1dfbfc6a17f2814577/data/kisahNabi/${selectedProphet}.json`);
      const story = await response.json();

      // Static image URL for all prophets
      const imageUrl = 'https://i.ibb.co/8NksWfT/ISLAM-IMAGE.png'; // Replace with actual image URL for each prophet if needed

      // Format the story with relevant details
      const formattedStory = `_*ğŸ‘³ Prophet:*_ ${story.name}\n`
                            + `_*ğŸ“… Date of Birth:*_ ${story.thn_kelahiran}\n`
                            + `_*ğŸ“ Place of Birth:*_ ${story.tmp}\n`
                            + `_*ğŸ“Š Age:*_ ${story.usia}\n\n`
                            + `*â€” â€” â€”  [ S T O R Y ] â€” â€” â€”*\n\n`
                            + `${story.description}`;

      // Translate the story to English if possible
      const translation = await translate(formattedStory, { to: 'en' }).catch(() => null);

      // Send the message with the story and image
      if (translation?.text) {
          await XliconBotInc.sendMessage(m.chat, {
              image: { url: imageUrl }, // Static image URL
              caption: translation.text // Translated story text
          });
      } else {
          await XliconBotInc.sendMessage(m.chat, {
              image: { url: imageUrl }, // Static image URL
              caption: formattedStory // Original story text
          });
      }
  } catch (error) {
      await XliconBotInc.sendText(
          m.chat, "*Not Found*\n*ğŸ“® Tips:* Please try selecting a prophet from the list."
      );
  }
}
break;



case 'asmaulhusna': {
  const contoh = `*Asmaul Husna*`;
  const anjuran = `
Dari Abu hurarirah radhiallahu anhu, Rasulullah Saw bersabda: "Ø¥ÙÙ†Ù‘Ù Ù„ÙÙ„Ù‘ÙÙ‡Ù ØªÙØ¹ÙØ§Ù„ÙÙ‰ ØªÙØ³Ù’Ø¹ÙØ©Ù‹ ÙˆÙØªÙØ³Ù’Ø¹ÙÙŠÙ†Ù Ø§Ø³Ù’Ù…Ù‹Ø§ØŒ Ù…ÙØ§Ø¦ÙØ©ÙŒ Ø¥ÙÙ„Ù‘ÙØ§ ÙˆÙØ§Ø­ÙØ¯Ù‹Ø§ØŒ Ù…ÙÙ†Ù’ Ø£ÙØ­Ù’ØµÙØ§Ù‡ÙØ§ Ø¯Ø®Ù„ Ø§Ù„Ø¬Ù†Ø©ØŒ ÙˆÙ‡Ùˆ ÙˆØªØ± ÙŠÙØ­ÙØ¨Ù‘Ù Ø§Ù„Ù’ÙˆÙØªÙ’Ø±Ù"
Artinya: "Sesungguhnya Allah mempunyai sembilan puluh sembilan nama, alias seratus kurang satu. Barang siapa yang menghitung-hitungnya, niscaya masuk surga; Dia Witir dan menyukai yang witir".`;

  const asmaulhusna = [
      { index: 1, latin: "Ar Rahman", arabic: "Ø§Ù„Ø±ÙÙ‘Ø­Ù’Ù…ÙÙ†Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø±Ø­Ù…Øª ÙˆØ§Ù„Ø§", translation_en: "The All Beneficent" },
      { index: 2, latin: "Ar Rahiim", arabic: "Ø§Ù„Ø±ÙÙ‘Ø­ÙÙŠÙ…Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø´ÙÙ‚Øª ÙˆØ§Ù„Ø§", translation_en: "The Most Merciful" },
      { index: 3, latin: "Al Malik", arabic: "Ø§Ù„Ù’Ù…ÙÙ„ÙÙƒÙ", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø­Ú©Ù…Ø±Ø§Ù†ÛŒ ÙˆØ§Ù„Ø§", translation_en: "The King, The Sovereign" },
      { index: 4, latin: "Al Quddus", arabic: "Ø§Ù„Ù’Ù‚ÙØ¯ÙÙ‘ÙˆØ³Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ù¾Ø§Ú©", translation_en: "The Most Holy" },
      { index: 5, latin: "As Salaam", arabic: "Ø§Ù„Ø³ÙÙ‘Ù„Ø§ÙÙ…Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø³Ù„Ø§Ù…ØªÛŒ ÙˆØ§Ù„Ø§", translation_en: "Peace and Blessing" },
      { index: 6, latin: "Al Muâ€™min", arabic: "Ø§Ù„Ù’Ù…ÙØ¤Ù’Ù…ÙÙ†Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø§Ù…Ù† Ø¯ÛŒÙ†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Guarantor" },
      { index: 7, latin: "Al Muhaimin", arabic: "Ø§Ù„Ù’Ù…ÙÙ‡ÙÙŠÙ’Ù…ÙÙ†Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ù†Ú¯ÛØ¨Ø§Ù†", translation_en: "The Guardian, the Preserver" },
      { index: 8, latin: "Al â€˜Aziiz", arabic: "Ø§Ù„Ù’Ø¹ÙØ²ÙÙŠØ²Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¹Ø²Øª ÙˆØ§Ù„Ø§", translation_en: "The Almighty, the Self Sufficient" },
      { index: 9, latin: "Al Jabbar", arabic: "Ø§Ù„Ù’Ø¬ÙØ¨ÙÙ‘Ø§Ø±Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø·Ø§Ù‚Øª ÙˆØ§Ù„Ø§", translation_en: "The Powerful, the Irresistible" },
      { index: 10, latin: "Al Mutakabbir", arabic: "Ø§Ù„Ù’Ù…ÙØªÙÙƒÙØ¨ÙÙ‘Ø±Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¨Ú‘Ø§Ø¦ÛŒ ÙˆØ§Ù„Ø§", translation_en: "The Tremendous" },
      { index: 11, latin: "Al Khaliq", arabic: "Ø§Ù„Ù’Ø®ÙØ§Ù„ÙÙ‚Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø®Ø§Ù„Ù‚", translation_en: "The Creator" },
      { index: 12, latin: "Al Baariâ€™", arabic: "Ø§Ù„Ù’Ø¨ÙØ§Ø±ÙØ¦Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¨Ù†Ø§Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Maker" },
      { index: 13, latin: "Al Mushawwir", arabic: "Ø§Ù„Ù’Ù…ÙØµÙÙˆÙÙ‘Ø±Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø´Ú©Ù„ Ø¯ÛŒÙ†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Fashioner of Forms" },
      { index: 14, latin: "Al Ghaffaar", arabic: "Ø§Ù„Ù’ØºÙÙÙÙ‘Ø§Ø±Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ù…Ø¹Ø§Ù Ú©Ø±Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Ever Forgiving" },
      { index: 15, latin: "Al Qahhaar", arabic: "Ø§Ù„Ù’Ù‚ÙÙ‡ÙÙ‘Ø§Ø±Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ù‚Ø§ÛØ±", translation_en: "The All Compelling Subduer" },
      { index: 16, latin: "Al Wahhaab", arabic: "Ø§Ù„Ù’ÙˆÙÙ‡ÙÙ‘Ø§Ø¨Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¹Ø·Ø§ Ú©Ø±Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Bestower" },
      { index: 17, latin: "Ar Razzaaq", arabic: "Ø§Ù„Ø±ÙÙ‘Ø²ÙÙ‘Ø§Ù‚Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø±Ø²Ù‚ Ø¯ÛŒÙ†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Ever Providing" },
      { index: 18, latin: "Al Fattaah", arabic: "Ø§Ù„Ù’ÙÙØªÙÙ‘Ø§Ø­Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø±Ø­Ù…Øª Ú©Ú¾ÙˆÙ„Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Opener, the Victory Giver" },
      { index: 19, latin: "Al â€˜Aliim", arabic: "Ø§ÙÙ„Ù’Ø¹ÙÙ„ÙÙŠÙ’Ù…Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¹Ø§Ù„Ù…", translation_en: "The All Knowing, the Omniscient" },
      { index: 20, latin: "Al Qaabidh", arabic: "Ø§Ù„Ù’Ù‚ÙØ§Ø¨ÙØ¶Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª ØªÙ†Ú¯ Ú©Ø±Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Restrainer, the Straightener" },
      { index: 21, latin: "Al Baasith", arabic: "Ø§Ù„Ù’Ø¨ÙØ§Ø³ÙØ·Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ù¾Ú¾ÛŒÙ„Ø§Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Expander, the Munificent" },
      { index: 22, latin: "Al Khaafidh", arabic: "Ø§Ù„Ù’Ø®ÙØ§ÙÙØ¶Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ù†ÛŒÚ†Ø§ Ú©Ø±Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Abaser" },
      { index: 23, latin: "Ar Raafiâ€™", arabic: "Ø§Ù„Ø±ÙÙ‘Ø§ÙÙØ¹Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø§ÙˆÙ†Ú†Ø§ Ú©Ø±Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Exalter" },
      { index: 24, latin: "Al Muâ€™izz", arabic: "Ø§Ù„Ù’Ù…ÙØ¹ÙØ²ÙÙ‘", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¹Ø²Øª Ø¯ÛŒÙ†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Giver of Honor" },
      { index: 25, latin: "Al Mudzil", arabic: "Ø§Ù„Ù…ÙØ°ÙÙ„ÙÙ‘", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø°Ù„Øª Ø¯ÛŒÙ†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Giver of Dishonor" },
      { index: 26, latin: "Al Samiiâ€™", arabic: "Ø§Ù„Ø³ÙÙ‘Ù…ÙÙŠØ¹Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø³Ù†Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The All Hearing" },
      { index: 27, latin: "Al Bashiir", arabic: "Ø§Ù„Ù’Ø¨ÙØµÙÙŠØ±Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¯ÛŒÚ©Ú¾Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The All Seeing" },
      { index: 28, latin: "Al Hakam", arabic: "Ø§Ù„Ù’Ø­ÙÙƒÙÙ…Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª ÙÛŒØµÙ„Û’ ÙˆØ§Ù„Ø§", translation_en: "The Judge, the Arbitrator" },
      { index: 29, latin: "Al â€˜Adl", arabic: "Ø§Ù„Ù’Ø¹ÙØ¯Ù’Ù„Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¹Ø¯Ù„", translation_en: "The Utterly Just" },
      { index: 30, latin: "Al Lathiif", arabic: "Ø§Ù„Ù„ÙÙ‘Ø·ÙÙŠÙÙ", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ù†Ø±Ù…ÛŒ ÙˆØ§Ù„Ø§", translation_en: "The Subtly Kind" },
      { index: 31, latin: "Al Khabiir", arabic: "Ø§Ù„Ù’Ø®ÙØ¨ÙÙŠØ±Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø±Ø§Ø²ÙˆÚº Ú©Ø§ Ø¬Ø§Ù†Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The All Aware" },
      { index: 32, latin: "Al Haliim", arabic: "Ø§Ù„Ù’Ø­ÙÙ„ÙÙŠÙ…Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¨Ø±Ø¯Ø¨Ø§Ø±", translation_en: "The Forbearing, the Indulgent" },
      { index: 33, latin: "Al â€˜Azhiim", arabic: "Ø§Ù„Ù’Ø¹ÙØ¸ÙÙŠÙ…Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¹Ø¸ÛŒÙ…", translation_en: "The Magnificent, the Infinite" },
      { index: 34, latin: "Al Ghafuur", arabic: "Ø§Ù„Ù’ØºÙÙÙÙˆØ±Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ù…Ø¹Ø§Ù Ú©Ø±Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The All Forgiving" },
      { index: 35, latin: "As Syakuur", arabic: "Ø§Ù„Ø´ÙÙ‘ÙƒÙÙˆØ±Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø´Ú©Ø±Ú¯Ø²Ø§Ø±", translation_en: "The Grateful" },
      { index: 36, latin: "Al â€˜Aliy", arabic: "Ø§Ù„Ù’Ø¹ÙÙ„ÙÙŠÙÙ‘", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø§Ø¹Ù„ÛŒ", translation_en: "The Sublimely Exalted" },
      { index: 37, latin: "Al Kabir", arabic: "Ø§Ù„Ù’ÙƒÙØ¨ÙÙŠØ±Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¨Ú‘Ø§", translation_en: "The All Great" },
      { index: 38, latin: "Al Hafiz", arabic: "Ø§Ù„Ù’Ø­ÙÙÙÙŠØ¸Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ù…Ø­ÙÙˆØ¸ Ú©Ø±Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Preserver" },
      { index: 39, latin: "Al Muqit", arabic: "Ø§Ù„Ù’Ù…ÙÙ‚ÙŠÙØª", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ù†Ú¯ÛØ¨Ø§Ù†", translation_en: "The Sustainer" },
      { index: 40, latin: "Al Hasib", arabic: "Ø§Ù„Ù’Ø­ÙØ³ÙÙŠØ¨Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø­Ø³Ø§Ø¨ Ù„ÛŒÙ†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Reckoner" },
      { index: 41, latin: "Al Jaliil", arabic: "Ø§Ù„Ù’Ø¬ÙÙ„ÙÙŠÙ„Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¬Ù„Ø§Ù„ ÙˆØ§Ù„Ø§", translation_en: "The Majestic" },
      { index: 42, latin: "Al Kariim", arabic: "Ø§Ù„Ù’ÙƒÙØ±ÙÙŠÙ…Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ú©Ø±Ù… ÙˆØ§Ù„Ø§", translation_en: "The Generous, the Esteemed" },
      { index: 43, latin: "Al Raqiib", arabic: "Ø§Ù„Ø±ÙÙ‘Ù‚ÙÙŠØ¨Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ù†Ú¯Ø±Ø§Ù†", translation_en: "The Watchful" },
      { index: 44, latin: "Al Mujiib", arabic: "Ø§Ù„Ù’Ù…ÙØ¬ÙÙŠØ¨Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¬ÙˆØ§Ø¨ Ø¯ÛŒÙ†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Responsive" },
      { index: 45, latin: "Al Wasiâ€™", arabic: "Ø§Ù„Ù’ÙˆÙØ§Ø³ÙØ¹Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª ÙˆØ³Ø¹Øª ÙˆØ§Ù„Ø§", translation_en: "The All-Encompassing" },
      { index: 46, latin: "Al Haadi", arabic: "Ø§Ù„Ù’Ù‡ÙØ§Ø¯ÙÙŠ", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª ÛØ¯Ø§ÛŒØª Ø¯ÛŒÙ†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Guide" },
      { index: 47, latin: "Al Baadiâ€™", arabic: "Ø§Ù„Ù’Ø¨ÙØ§Ø¯ÙØ¹Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø³Ø¨ Ø³Û’ Ù¾ÛÙ„Ø§", translation_en: "The Incomparable" },
      { index: 48, latin: "Al Baaqi", arabic: "Ø§Ù„Ù’Ø¨ÙØ§Ù‚ÙÙŠ", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¨Ø§Ù‚ÛŒ", translation_en: "The Everlasting" },
      { index: 49, latin: "Al Waarith", arabic: "Ø§Ù„Ù’ÙˆÙØ§Ø±ÙØ«Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª ÙˆØ§Ø±Ø«", translation_en: "The Inheritor" },
      { index: 50, latin: "Ar Rashid", arabic: "Ø§Ù„Ø±ÙÙ‘Ø´ÙÙŠØ¯Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª ÛØ¯Ø§ÛŒØª Ø¯ÛŒÙ†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Righteous Teacher" },
      { index: 51, latin: "As Sabur", arabic: "Ø§Ù„ØµÙÙ‘Ø¨ÙÙˆØ±Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª ØµØ§Ø¨Ø±", translation_en: "The Patient" },
      { index: 52, latin: "Al Muâ€™izz", arabic: "Ø§Ù„Ù’Ù…ÙØ¹ÙØ²ÙÙ‘", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¹Ø²Øª Ø¯ÛŒÙ†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Giver of Honor" },
      { index: 53, latin: "Al Muthir", arabic: "Ø§Ù„Ù’Ù…ÙØ«ÙÙŠØ±Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¬ÙˆØ´ Ø¯Ù„Ø§Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Infuser of Enthusiasm" },
      { index: 54, latin: "Al Muâ€™min", arabic: "Ø§Ù„Ù’Ù…ÙØ¤Ù’Ù…ÙÙ†Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø§ÛŒÙ…Ø§Ù† Ø¯ÛŒÙ†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Giver of Faith" },
      { index: 55, latin: "Al Qariib", arabic: "Ø§Ù„Ù’Ù‚ÙØ±ÙÙŠØ¨Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ù‚Ø±ÛŒØ¨", translation_en: "The Near" },
      { index: 56, latin: "Al Muâ€™min", arabic: "Ø§Ù„Ù’Ù…ÙØ¤Ù’Ù…ÙÙ†Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø§ÛŒÙ…Ø§Ù† Ø¯ÛŒÙ†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Giver of Faith" },
      { index: 57, latin: "Al Qawiyy", arabic: "Ø§Ù„Ù’Ù‚ÙÙˆÙÙŠÙÙ‘", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø·Ø§Ù‚ØªÙˆØ±", translation_en: "The All-Strong" },
      { index: 58, latin: "Al Qadeer", arabic: "Ø§Ù„Ù’Ù‚ÙØ§Ø¯ÙØ±Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ù‚Ø§Ø¯Ø±", translation_en: "The Omnipotent" },
      { index: 59, latin: "Al Haqq", arabic: "Ø§Ù„Ù’Ø­ÙÙ‚ÙÙ‘", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø­Ù‚", translation_en: "The Absolute Truth" },
      { index: 60, latin: "Al Hakeem", arabic: "Ø§Ù„Ù’Ø­ÙÙƒÙÙŠÙ…Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø­Ú©ÛŒÙ…", translation_en: "The All Wise" },
      { index: 61, latin: "Al Wahhab", arabic: "Ø§Ù„Ù’ÙˆÙÙ‡ÙÙ‘Ø§Ø¨Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¹Ø·Ø§ Ú©Ø±Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Supreme Bestower" },
      { index: 62, latin: "Al Jalil", arabic: "Ø§Ù„Ù’Ø¬ÙÙ„ÙÙŠÙ„Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¬Ù„Ø§Ù„ ÙˆØ§Ù„Ø§", translation_en: "The Majestic" },
      { index: 63, latin: "Al Karim", arabic: "Ø§Ù„Ù’ÙƒÙØ±ÙÙŠÙ…Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ú©Ø±Ù… ÙˆØ§Ù„Ø§", translation_en: "The Generous" },
      { index: 64, latin: "Al Khabeer", arabic: "Ø§Ù„Ù’Ø®ÙØ¨ÙÙŠØ±Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¨Ø§Ø®Ø¨Ø±", translation_en: "The All-Aware" },
      { index: 65, latin: "Al Latif", arabic: "Ø§Ù„Ù’Ù„ÙØ·ÙÙŠÙÙ", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ù„Ø·ÛŒÙ", translation_en: "The Subtle" },
      { index: 66, latin: "Al Qabid", arabic: "Ø§Ù„Ù’Ù‚ÙØ§Ø¨ÙØ¶Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª ØªÙ†Ú¯ Ú©Ø±Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Withholder" },
      { index: 67, latin: "Al Basit", arabic: "Ø§Ù„Ù’Ø¨ÙØ§Ø³ÙØ·Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ù¾Ú¾ÛŒÙ„Ø§Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Extender" },
      { index: 68, latin: "Al Khafid", arabic: "Ø§Ù„Ù’Ø®ÙØ§ÙÙØ¶Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ú©Ù… Ú©Ø±Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Reducer" },
      { index: 69, latin: "Ar Rafi", arabic: "Ø§Ù„Ø±ÙÙ‘Ø§ÙÙØ¹Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¨Ù„Ù†Ø¯ Ú©Ø±Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Exalter" },
      { index: 70, latin: "Al Muâ€™izz", arabic: "Ø§Ù„Ù’Ù…ÙØ¹ÙØ²ÙÙ‘", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¹Ø²Øª Ø¯ÛŒÙ†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Honor Giver" },
      { index: 71, latin: "Al Mudzil", arabic: "Ø§Ù„Ù’Ù…ÙØ°ÙÙ„ÙÙ‘", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø°Ù„Øª Ø¯ÛŒÙ†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Dishonor Giver" },
      { index: 72, latin: "Al Sami", arabic: "Ø§Ù„Ù’Ø³ÙÙ…ÙÙŠØ¹Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø³Ù†Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The All-Hearing" },
      { index: 73, latin: "Al Baseer", arabic: "Ø§Ù„Ù’Ø¨ÙØµÙÙŠØ±Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¯ÛŒÚ©Ú¾Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The All-Seeing" },
      { index: 74, latin: "Al Hakam", arabic: "Ø§Ù„Ù’Ø­ÙÙƒÙÙ…Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø­Ú©Ù…Ø±Ø§Ù†", translation_en: "The Judge" },
      { index: 75, latin: "Al Adl", arabic: "Ø§Ù„Ù’Ø¹ÙØ¯Ù’Ù„Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø§Ù†ØµØ§Ù Ú©Ø±Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Just" },
      { index: 76, latin: "Al Latif", arabic: "Ø§Ù„Ù’Ù„ÙØ·ÙÙŠÙÙ", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ù†Ø±Ù…ÛŒ ÙˆØ§Ù„Ø§", translation_en: "The Subtle" },
      { index: 77, latin: "Al Khabir", arabic: "Ø§Ù„Ù’Ø®ÙØ¨ÙÙŠØ±Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¨Ø§Ø®Ø¨Ø±", translation_en: "The All-Aware" },
      { index: 78, latin: "Al Halim", arabic: "Ø§Ù„Ù’Ø­ÙÙ„ÙÙŠÙ…Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¨Ø±Ø¯Ø¨Ø§Ø±", translation_en: "The Forbearing" },
      { index: 79, latin: "Al Azim", arabic: "Ø§Ù„Ù’Ø¹ÙØ¸ÙÙŠÙ…Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¹Ø¸ÛŒÙ…", translation_en: "The Magnificent" },
      { index: 80, latin: "Al Ghafur", arabic: "Ø§Ù„Ù’ØºÙÙÙÙˆØ±Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ù…Ø¹Ø§Ù Ú©Ø±Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Forgiving" },
      { index: 81, latin: "Ash Shakur", arabic: "Ø§Ù„Ù’Ø´ÙØ§ÙƒÙÙˆØ±Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø´Ú©Ø±Ú¯Ø²Ø§Ø±", translation_en: "The Appreciative" },
      { index: 82, latin: "Al Ali", arabic: "Ø§Ù„Ù’Ø¹ÙÙ„ÙÙŠÙÙ‘", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø§Ø¹Ù„ÛŒ", translation_en: "The Most High" },
      { index: 83, latin: "Al Kabir", arabic: "Ø§Ù„Ù’ÙƒÙØ¨ÙÙŠØ±Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¨Ú‘Ø§", translation_en: "The Great" },
      { index: 84, latin: "Al Hafiz", arabic: "Ø§Ù„Ù’Ø­ÙÙÙÙŠØ¸Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ù…Ø­ÙÙˆØ¸ Ú©Ø±Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Preserver" },
      { index: 85, latin: "Al Muqit", arabic: "Ø§Ù„Ù’Ù…ÙÙ‚ÙŠÙØª", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø®ÙˆØ±Ø§Ú© Ø¯ÛŒÙ†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Sustainer" },
      { index: 86, latin: "Al Hasib", arabic: "Ø§Ù„Ù’Ø­ÙØ³ÙÙŠØ¨Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø­Ø³Ø§Ø¨ Ù„ÛŒÙ†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Reckoner" },
      { index: 87, latin: "Al Jalil", arabic: "Ø§Ù„Ù’Ø¬ÙÙ„ÙÙŠÙ„Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¬Ù„Ø§Ù„ ÙˆØ§Ù„Ø§", translation_en: "The Majestic" },
      { index: 88, latin: "Al Karim", arabic: "Ø§Ù„Ù’ÙƒÙØ±ÙÙŠÙ…Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ú©Ø±Ù… ÙˆØ§Ù„Ø§", translation_en: "The Generous" },
      { index: 89, latin: "Al Raqib", arabic: "Ø§Ù„Ø±ÙÙ‘Ù‚ÙÙŠØ¨Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ù†Ú¯Ø±Ø§Ù†", translation_en: "The Watchful" },
      { index: 90, latin: "Al Mujib", arabic: "Ø§Ù„Ù’Ù…ÙØ¬ÙÙŠØ¨Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¬ÙˆØ§Ø¨ Ø¯ÛŒÙ†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Responsive" },
      { index: 91, latin: "Al Wasi'", arabic: "Ø§Ù„Ù’ÙˆÙØ§Ø³ÙØ¹Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª ÙˆØ³Ø¹Øª ÙˆØ§Ù„Ø§", translation_en: "The All-Encompassing" },
      { index: 92, latin: "Al Haadi", arabic: "Ø§Ù„Ù’Ù‡ÙØ§Ø¯ÙÙŠ", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª ÛØ¯Ø§ÛŒØª Ø¯ÛŒÙ†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Guide" },
      { index: 93, latin: "Al Baadi'", arabic: "Ø§Ù„Ù’Ø¨ÙØ§Ø¯ÙØ¹Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø³Ø¨ Ø³Û’ Ù¾ÛÙ„Ø§", translation_en: "The Incomparable" },
      { index: 94, latin: "Al Baqi", arabic: "Ø§Ù„Ù’Ø¨ÙØ§Ù‚ÙÙŠ", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¨Ø§Ù‚ÛŒ", translation_en: "The Everlasting" },
      { index: 95, latin: "Al Warith", arabic: "Ø§Ù„Ù’ÙˆÙØ§Ø±ÙØ«Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª ÙˆØ§Ø±Ø«", translation_en: "The Inheritor" },
      { index: 96, latin: "Ar Rashid", arabic: "Ø§Ù„Ø±ÙÙ‘Ø´ÙÙŠØ¯Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª ÛØ¯Ø§ÛŒØª Ø¯ÛŒÙ†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Righteous Teacher" },
      { index: 97, latin: "As Sabur", arabic: "Ø§Ù„ØµÙÙ‘Ø¨ÙÙˆØ±Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª ØµØ§Ø¨Ø±", translation_en: "The Patient" },
      { index: 98, latin: "Al Muâ€™izz", arabic: "Ø§Ù„Ù’Ù…ÙØ¹ÙØ²ÙÙ‘", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¹Ø²Øª Ø¯ÛŒÙ†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Giver of Honor" },
      { index: 99, latin: "Al Muthir", arabic: "Ø§Ù„Ù’Ù…ÙØ«ÙÙŠØ±Ù", translation_id: "Ù…Ø·Ù„Ù‚ ØµÙØª Ø¬ÙˆØ´ Ø¯Ù„Ø§Ù†Û’ ÙˆØ§Ù„Ø§", translation_en: "The Infuser of Enthusiasm" }
  ];

  const result = asmaulhusna.map(a => `\n${a.index}. ${a.latin}: ${a.translation_en} (${a.translation_id})\n   Arabic: ${a.arabic}\n   `).join("");
  await XliconBotInc.sendText(m.chat, contoh + anjuran + result);
}
  break

  case 'duas': {
    if (!q) return replygcxlicon(`*Where is the text*\n\n*ğ™´xample usage*\n*${prefix + command} <language id>*\n*${prefix + command} en*`);

    // Read and parse the JSON file
    let { result } = JSON.parse(fs.readFileSync('./lib/tahlil.json', 'utf-8'));

    // Extract language code from command arguments
    let lang = args[0] || 'en';

    // Translate and map the result to create captions
    let caption = await Promise.all(result.map(async (v, i) => {
        try {
            // Translate title and translation to the specified language
            let translatedTitleResponse = await translate(v.title, { to: lang, autoCorrect: true }).catch(err => {
                console.error(`Error translating title: ${err}`);
                return { text: v.title };
            });
            let translatedTitle = translatedTitleResponse.text || v.title;

            let translatedTranslationResponse = await translate(v.translation, { to: lang, autoCorrect: true }).catch(err => {
                console.error(`Error translating translation: ${err}`);
                return { text: v.translation };
            });
            let translatedTranslation = translatedTranslationResponse.text || v.translation;

            return `*${i + 1}.* ${translatedTitle}

âƒ Arabic :
${v.arabic}

âƒ Translate :
${translatedTranslation}
`.trim();
        } catch (error) {
            console.error(`Error translating text: ${error}`);
            return `*${i + 1}.* ${v.title}

âƒ Arabic :
${v.arabic}

âƒ Translate :
${v.translation}
`.trim();
        }
    })).then(captions => captions.join('\n\n'));
     // URL for each image (replace with actual URLs or dynamic URLs)
  const imageUrl = `https://i.ibb.co/8NksWfT/ISLAM-IMAGE.png`;

    // Send the caption along with an image
    await XliconBotInc.sendMessage(m.chat, {
        image: { url: imageUrl }, // Image URL
        caption: caption // The translated text content
    });
}
break;

case 'namaz': {
  const namazData = {
    "result": [
      {
        "id": 1,
        "name": "Opening Takbir",
        "arabic": "Ø§Ù„Ù„Ù‘ÙÙ‡Ù Ø£ÙÙƒÙ’Ø¨ÙØ±Ù ÙƒÙØ¨ÙÙŠØ±Ù‹Ø§ ÙˆÙØ§Ù„Ù’Ø­ÙÙ…Ù’Ø¯Ù Ù„ÙÙ„Ù‘ÙÙ‡Ù ÙƒÙØ«ÙÙŠØ±Ù‹Ø§ ÙˆÙØ³ÙØ¨Ù’Ø­ÙØ§Ù†Ù Ø§Ù„Ù„Ù‘ÙÙ‡Ù Ø¨ÙÙƒÙ’Ø±ÙØ©Ù‹ ÙˆÙØ£ÙØµÙÙŠÙ„Ø§Ù‹ , Ø¥ÙÙ†Ù‘ÙÙ‰ ÙˆÙØ¬Ù‘ÙÙ‡Ù’ØªÙ ÙˆÙØ¬Ù’Ù‡ÙÙ‰Ù Ù„ÙÙ„Ù‘ÙØ°ÙÙ‰ ÙÙØ·ÙØ±Ù Ø§Ù„Ø³Ù‘ÙÙ…ÙÙˆÙØ§ØªÙ ÙˆÙØ§Ù„Ø£ÙØ±Ù’Ø¶Ù Ø­ÙÙ†ÙÙŠÙÙ‹Ø§ ÙˆÙÙ…ÙØ§ Ø£ÙÙ†ÙØ§ Ù…ÙÙ†Ù Ø§Ù„Ù’Ù…ÙØ´Ù’Ø±ÙÙƒÙÙŠÙ†Ù Ø¥ÙÙ†Ù‘Ù ØµÙÙ„Ø§ÙØªÙÙ‰ ÙˆÙÙ†ÙØ³ÙÙƒÙÙ‰ ÙˆÙÙ…ÙØ­Ù’ÙŠÙØ§Ù‰Ù ÙˆÙÙ…ÙÙ…ÙØ§ØªÙÙ‰ Ù„ÙÙ„Ù‘ÙÙ‡Ù Ø±ÙØ¨Ù‘Ù Ø§Ù„Ù’Ø¹ÙØ§Ù„ÙÙ…ÙÙŠÙ†Ù Ù„Ø§Ù Ø´ÙØ±ÙÙŠÙƒÙ Ù„ÙÙ‡Ù ÙˆÙØ¨ÙØ°ÙÙ„ÙÙƒÙ Ø£ÙÙ…ÙØ±Ù’ØªÙ ÙˆÙØ£ÙÙ†ÙØ§ Ø£ÙÙˆÙ‘ÙÙ„Ù Ø§Ù„Ù’Ù…ÙØ³Ù’Ù„ÙÙ…ÙÙŠÙ†Ù",
        "latin": "Alloohu akbar kabiirow wal hamdu lillaahi katsiiroo wasubhaanalloohi bukrotaw wa-ashiilaa, Innii wajjahtu wajhiya lilladzii fathoros samaawaati wal ardlo haniifaa wamaa ana minal musyrikiin. Inna sholaatii wa nusukii wamahyaa wa mamaatii lillaahi robbil 'aalamiin. Laa syariikalahu wa bidzaalika umirtu wa ana awwalul muslimiin",
        "translation": "Allah is the Greatest, with the greatest greatness. All praise is due to Allah in abundance. Glory be to Allah in the morning and evening. Indeed, I direct my face to Allah who created the heavens and the earth, being upright and not of those who associate others with Him. Indeed, my prayer, my rites of worship, my life, and my death are for Allah, Lord of the Worlds. There is no partner for Him. And with this, I am commanded, and I am the first of the Muslims."
      },
      {
        "id": 2,
        "name": "Al-Fatihah",
        "arabic": "Ø¨ÙØ³Ù’Ù…Ù Ø§Ù„Ù„Ù‘ÙÙ€Ù‡Ù Ø§Ù„Ø±Ù‘ÙØ­Ù’Ù…ÙÙ€Ù°Ù†Ù Ø§Ù„Ø±Ù‘ÙØ­ÙÙŠÙ…Ù ï´¿Ù¡ï´¾Ø§Ù„Ù’Ø­ÙÙ…Ù’Ø¯Ù Ù„ÙÙ„Ù‘ÙÙ€Ù‡Ù Ø±ÙØ¨ÙÙ‘ Ø§Ù„Ù’Ø¹ÙØ§Ù„ÙÙ…ÙÙŠÙ†Ù ï´¿Ù¢ï´¾ Ø§Ù„Ø±Ù‘ÙØ­Ù’Ù…ÙÙ€Ù°Ù†Ù Ø§Ù„Ø±Ù‘ÙØ­ÙÙŠÙ…Ù ï´¿Ù£ï´¾ Ù…ÙØ§Ù„ÙÙƒÙ ÙŠÙÙˆÙ’Ù…Ù Ø§Ù„Ø¯ÙÙ‘ÙŠÙ†Ù ï´¿Ù¤ï´¾ Ø¥ÙÙŠÙ‘ÙØ§ÙƒÙ Ù†ÙØ¹Ù’Ø¨ÙØ¯Ù ÙˆÙØ¥ÙÙŠÙ‘ÙØ§ÙƒÙ Ù†ÙØ³Ù’ØªÙØ¹ÙÙŠÙ†Ù ï´¿Ù¥ï´¾ Ø§Ù‡Ù’Ø¯ÙÙ†ÙØ§Ø§Ù„ØµÙÙ‘Ø±ÙØ§Ø·Ù Ø§Ù„Ù’Ù…ÙØ³Ù’ØªÙÙ‚ÙÙŠÙ…Ù ï´¿Ù¦ï´¾ ØµÙØ±ÙØ§Ø·Ù Ø§Ù„Ù‘ÙØ°ÙÙŠÙ†Ù Ø£ÙÙ†Ù’Ø¹ÙÙ…Ù’ØªÙ Ø¹ÙÙ„ÙÙŠÙ’Ù‡ÙÙ…Ù’ ØºÙÙŠÙ’Ø±Ù Ø§Ù„Ù’Ù…ÙØºÙ’Ø¶ÙÙˆØ¨Ù Ø¹ÙÙ„ÙÙŠÙ’Ù‡ÙÙ…Ù’ ÙˆÙÙ„ÙØ§ Ø§Ù„Ø¶Ù‘ÙØ§Ù„ÙÙ‘ÙŠÙ†Ù ï´¿Ù§",
        "latin": "1. Bismillahirrahmanirrahim, 2. Alhamdulillahi rabbil alamin, 3. Arrahmaanirrahiim, 4. Maaliki yaumiddiin, 5. Iyyaka nabudu waiyyaaka nastaiin, 6. Ihdinashirratal mustaqim, 7. shiratalladzina anâ€™amta alaihim ghairil maghduubi alaihim waladhaalin",
        "translation": "1. In the name of Allah, the Most Gracious, the Most Merciful, 2. Praise be to Allah, Lord of the Worlds, 3. The Most Gracious, the Most Merciful, 4. Master of the Day of Judgment, 5. You alone we worship, and You alone we ask for help, 6. Guide us to the straight path, 7. The path of those who have received Your grace; not the path of those who have brought down wrath upon themselves, nor of those who have gone astray."
      },
      {
        "id": 3,
        "name": "Bowing (Ruku)",
        "arabic": "(3x) Ø³ÙØ¨Ù’Ø­ÙØ§Ù†Ù Ø±ÙØ¨Ù‘ÙÙŠÙ Ø§Ù„Ù’Ø¹ÙØ¸ÙÙŠÙ’Ù…Ù ÙˆÙØ¨ÙØ­ÙÙ…Ù’Ø¯ÙÙ‡Ù",
        "latin": "Subhana Rabbiyal Adzimi Wabihamdih (3x)",
        "translation": "Glory is to my Lord, the Most Great, and praise be to Him."
      },
      {
        "id": 4,
        "name": "Prostration (Sujud)",
        "arabic": "(3x) Ø³ÙØ¨Ù’Ø­ÙØ§Ù†Ù Ø±ÙØ¨Ù‘ÙÙ‰Ù Ø§Ù„Ù’Ø£ÙØ¹Ù’Ù„ÙÙ‰ ÙˆÙØ¨ÙØ­ÙÙ…Ù’Ø¯ÙÙ‡Ù",
        "latin": "Subhaana robbiyal a'la wabihamdih (3x)",
        "translation": "Glory is to my Lord, the Most High, and praise be to Him."
      },
      {
        "id": 5,
        "name": "Sitting Between Two Prostrations",
        "arabic": "Ø±ÙØ¨Ù‘Ù Ø§ØºÙ’ÙÙØ±Ù’Ù„ÙÙŠÙ’ ÙˆÙØ§Ø±Ù’Ø­ÙÙ…Ù’Ù†ÙÙŠÙ’ ÙˆÙØ§Ø¬Ù’Ø¨ÙØ±Ù’Ù†ÙÙŠÙ’ ÙˆÙØ§Ø±Ù’ÙÙØ¹Ù’Ù†ÙÙŠÙ’ ÙˆÙØ§Ø±Ù’Ø²ÙÙ‚Ù’Ù†ÙÙŠÙ’ ÙˆÙØ§Ù‡Ù’Ø¯ÙÙ†ÙÙŠÙ’ ÙˆÙØ¹ÙØ§ÙÙÙ†ÙÙŠÙ’ ÙˆÙØ§Ø¹Ù’ÙÙ Ø¹ÙÙ†ÙÙ‘ÙŠÙ’",
        "latin": "Rabbighfirli Warhamni Wajburnii Warfaknii Wazuqnii Wahdinii Wa'aafinii Wa'fuannii",
        "translation": "O Allah, forgive my sins, have mercy on me, and remedy my shortcomings. Elevate my status, provide for me, guide me, grant me health, and pardon me."
      },
      {
        "id": 6,
        "name": "Sitting for the Initial Tashahhud",
        "arabic": "Ø§ÙÙ„ØªÙ‘ÙØ­ÙÙŠÙ‘ÙØ§ØªÙ Ø§Ù„Ù’Ù…ÙØ¨ÙØ§Ø±ÙÙƒÙØ§ØªÙ Ø§Ù„ØµÙ‘ÙÙ„ÙÙˆÙØ§ØªÙ Ø§Ù„Ø·Ù‘ÙÙŠÙÙ‘Ø¨ÙØ§ØªÙ ÙÙ„Ù„Ù‡ÙØŒ Ø§Ù„Ø³Ù‘ÙÙ„Ø§ÙÙ…Ù Ø¹ÙÙ„ÙÙŠÙ’ÙƒÙ Ø§ÙÙŠÙ‘ÙÙ‡ÙØ§ Ø§Ù„Ù†Ù‘ÙØ¨ÙÙŠÙ‘Ù ÙˆÙØ±ÙØ­Ù’Ù…ÙØ©Ù Ø§Ù„Ù„Ù‡Ù ÙˆÙØ¨ÙØ±ÙÙƒÙØ§ØªÙÙ‡ÙØŒ Ø§Ù„Ø³Ù‘ÙÙ„Ø§ÙÙ…Ù Ø¹ÙÙ„ÙÙŠÙ’Ù†ÙØ§ ÙˆÙØ¹ÙÙ„ÙÙ‰ Ø¹ÙØ¨ÙØ§Ø¯ÙØ§Ù„Ù„Ù‡Ù Ø§Ù„ØµÙ‘ÙØ§Ù„ÙØ­ÙÙŠÙ’Ù†ÙØŒ Ø£ÙØ´Ù’Ù‡ÙØ¯Ù Ø§ÙÙ†Ù’ Ù„Ø¢ Ø¥ÙÙ„ÙÙ‡Ù Ø¥ÙÙ„Ø§Ù‘ÙØ§Ù„Ù„Ù‡Ù ÙˆÙØ§ÙØ´Ù’Ù‡ÙØ¯Ù Ø£ÙÙ†Ù‘Ù Ù…ÙØ­ÙÙ…Ù‘ÙØ¯Ù‹Ø§ Ø±ÙØ³ÙÙˆÙ’Ù„Ù Ø§Ù„Ù„Ù‡ÙØŒ Ø§ÙÙ„Ù„Ù‡ÙÙ…Ù‘Ù ØµÙÙ„ÙÙ‘ Ø¹ÙÙ„ÙÙ‰ Ø³ÙÙŠÙÙ‘Ø¯ÙÙ†ÙØ§ Ù…ÙØ­ÙÙ…Ù‘ÙØ¯Ù",
        "latin": "Attahiyyaatul mubaarokaatush sholawaatuth thoyyibaatu lillaah. Assalaamualaika ayyuhan nabiyyu wa rohmatulloohi wa barokaatuh. Assalaaamualainaa wa alaa ibaadillaahish shoolihiin. Asyhadu allaa ilaaha illallooh wa asyhadu anna Muhammadar rosuulullooh. Allahummasholli ala Sayyidina Muhammad",
        "translation": "All greetings, blessings, prayers, and good things are for Allah. Peace be upon you, O Prophet, and the mercy and blessings of Allah. Peace be upon us and upon the righteous servants of Allah. I bear witness that there is no deity except Allah, and I bear witness that Muhammad is the Messenger of Allah. O Allah, send blessings upon our master Muhammad."
      },
      {
        "id": 7,
        "name": "Sitting for the Final Tashahhud",
        "arabic": "Ø§ÙÙ„ØªÙ‘ÙØ­ÙÙŠÙ‘ÙØ§ØªÙ Ø§Ù„Ù’Ù…ÙØ¨ÙØ§Ø±ÙÙƒÙØ§ØªÙ Ø§Ù„ØµÙ‘ÙÙ„ÙÙˆÙØ§ØªÙ Ø§Ù„Ø·Ù‘ÙÙŠÙÙ‘Ø¨ÙØ§ØªÙ ÙÙ„Ù„Ù‡ÙØŒ Ø§Ù„Ø³Ù‘ÙÙ„Ø§ÙÙ…Ù Ø¹ÙÙ„ÙÙŠÙ’ÙƒÙ Ø§ÙÙŠÙ‘ÙÙ‡ÙØ§ Ø§Ù„Ù†Ù‘ÙØ¨ÙÙŠÙ‘Ù ÙˆÙØ±ÙØ­Ù’Ù…ÙØ©Ù Ø§Ù„Ù„Ù‡Ù ÙˆÙØ¨ÙØ±ÙÙƒÙØ§ØªÙÙ‡ÙØŒ Ø§Ù„Ø³Ù‘ÙÙ„Ø§ÙÙ…Ù Ø¹ÙÙ„ÙÙŠÙ’Ù†ÙØ§ ÙˆÙØ¹ÙÙ„ÙÙ‰ Ø¹ÙØ¨ÙØ§Ø¯ÙØ§Ù„Ù„Ù‡Ù Ø§Ù„ØµÙ‘ÙØ§Ù„ÙØ­ÙÙŠÙ’Ù†ÙØŒ Ø£ÙØ´Ù’Ù‡ÙØ¯Ù Ø§ÙÙ†Ù’ Ù„Ø¢ Ø¥ÙÙ„ÙÙ‡Ù Ø¥ÙÙ„Ø§Ù‘ÙØ§Ù„Ù„Ù‡Ù ÙˆÙØ§ÙØ´Ù’Ù‡ÙØ¯Ù Ø£ÙÙ†Ù‘Ù Ù…ÙØ­ÙÙ…Ù‘ÙØ¯Ù‹Ø§ Ø±ÙØ³ÙÙˆÙ’Ù„Ù Ø§Ù„Ù„Ù‡ÙØŒ Ø§ÙÙ„Ù„Ù‡ÙÙ…Ù‘Ù ØµÙÙ„ÙÙ‘ Ø¹ÙÙ„ÙÙ‰ Ø³ÙÙŠÙÙ‘Ø¯ÙÙ†ÙØ§ Ù…ÙØ­ÙÙ…Ù‘ÙØ¯Ù ÙˆÙØ¹ÙÙ„ÙÙ‰ Ø¢Ù„Ù Ø³ÙÙŠÙÙ‘Ø¯ÙÙ†ÙØ§ Ù…ÙØ­ÙÙ…Ù‘ÙØ¯ÙØŒ ÙƒÙÙ…ÙØ§ ØµÙÙ„Ù‘ÙÙŠÙ’ØªÙ Ø¹ÙÙ„ÙÙ‰ Ø³ÙÙŠÙÙ‘Ø¯ÙÙ†ÙØ§ Ø§ÙØ¨Ù’Ø±ÙØ§Ù‡ÙÙŠÙ’Ù…Ù ÙˆÙØ¹ÙÙ„ÙÙ‰ Ø¢Ù„Ù Ø³ÙÙŠÙÙ‘Ø¯ÙÙ†ÙØ§ Ø§ÙØ¨Ù’Ø±ÙØ§Ù‡ÙÙŠÙ’Ù…Ù ÙˆÙØ¨ÙØ§Ø±ÙÙƒÙ’ Ø¹ÙÙ„ÙÙ‰ Ø³ÙÙŠÙÙ‘Ø¯ÙÙ†ÙØ§ Ù…ÙØ­ÙÙ…Ù‘ÙØ¯Ù ÙˆÙØ¹ÙÙ„ÙÙ‰ Ø¢Ù„Ù Ø³ÙÙŠÙÙ‘Ø¯ÙÙ†ÙØ§ Ù…ÙØ­ÙÙ…Ù‘ÙØ¯Ù ÙƒÙÙ…ÙØ§ Ø¨ÙØ±ÙÙƒÙ’ØªÙ Ø¹ÙÙ„ÙÙ‰ Ø³ÙÙŠÙÙ‘Ø¯ÙÙ†ÙØ§ Ø§ÙØ¨Ù’Ø±ÙØ§Ù‡ÙÙŠÙ’Ù…Ù ÙˆÙØ¹ÙÙ„ÙÙ‰ Ø¢Ù„Ù Ø³ÙÙŠÙÙ‘Ø¯ÙÙ†ÙØ§ Ø§ÙØ¨Ù’Ø±ÙØ§Ù‡ÙÙŠÙ’Ù…Ù ÙÙÙ‰ Ø§Ù„Ù’Ø¹ÙØ§Ù„ÙÙ…ÙÙŠÙ’Ù†Ù Ø¥ÙÙ†Ù‘ÙÙƒÙ Ø­ÙÙ…ÙÙŠÙ’Ø¯ÙŒ Ù…ÙØ¬ÙÙŠÙ’Ø¯ÙŒ",
        "latin": "Attahiyyaatul mubaarokaatush sholawaatuth thoyyibaatu lillaah. Assalaamualaika ayyuhan nabiyyu wa rohmatulloohi wa barokaatuh. Assalaaamualainaa wa alaa ibaadillaahish shoolihiin. Asyhadu allaa ilaaha illallooh wa asyhadu anna Muhammadar rosuulullooh. Allahumma Shalli Ala Sayyidina Muhammad Wa Ala Ali Sayyidina Muhammad. Kama Shollaita Ala Sayyidina Ibrahim wa alaa aali sayyidina Ibrahim, wabaarik ala Sayyidina Muhammad Wa Alaa Ali Sayyidina Muhammad, Kama barokta alaa Sayyidina Ibrahim wa alaa ali Sayyidina Ibrahim, Fil aalamiina innaka hamiidummajid",
        "translation": "All greetings, blessings, and good prayers are for Allah. Peace be upon you, O Prophet, and the mercy of Allah and His blessings. Peace be upon us and upon the righteous servants of Allah. I bear witness that there is no deity except Allah, and I bear witness that Muhammad is the Messenger of Allah. O Allah, send blessings upon our master Muhammad and upon the family of our master Muhammad, as You sent blessings upon our master Ibrahim and upon the family of our master Ibrahim. And bless our master Muhammad and the family of our master Muhammad as You blessed our master Ibrahim and the family of our master Ibrahim throughout the worlds. Verily, You are Praiseworthy, Glorious."
      },
      {
        "id": 8,
        "name": "Salam",
        "arabic": "Ø§ÙÙ„Ø³Ù‘ÙÙ„Ø§ÙÙ…Ù Ø¹ÙÙ„ÙÙŠÙ’ÙƒÙÙ…Ù’ ÙˆÙØ±ÙØ­Ù’Ù…ÙØ©Ù Ø§Ù„Ù„Ù‡Ù ÙˆÙØ¨ÙØ±ÙÙƒÙØ§ØªÙÙ‡Ù",
        "latin": "Assalamualaikum Warohmatullahi Wabarokatuh",
        "translation": "Peace be upon you and Allah's mercy and blessings."
      }
    ]
  };

  // Generate the message text
  let captionText = namazData.result.map((v, i) => 
    `*${i + 1}. ${v.name}*\n` +
    `*Arabic:* ${v.arabic}\n` +
    `*Latin:* ${v.latin}\n` +
    `*Translation:* _${v.translation}_`
  ).join('\n\n');

  let introduction = `*ã€Œ Namaz Prayers ã€*\n\n`;
  let finalMessage = `${introduction}${captionText}\n\n*Image of Namaz:* [Insert Image URL or Attachment Here]`;
   // URL for each image (replace with actual URLs or dynamic URLs)
  const imageUrl = `https://i.ibb.co/8NksWfT/ISLAM-IMAGE.png`;

  // Send the message
   await XliconBotInc.sendMessage(m.chat, {
        image: { url: imageUrl },
        caption: finalMessage
    });
}
break;


case 'masnoonduas': {
    // Read and parse the JSON file
    let src = JSON.parse(fs.readFileSync('./lib/doaharian.json', 'utf-8'));

    // Delay function to throttle requests
    function delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Translation function with retry logic
    async function translateText(text, targetLang) {
        let retries = 5;
        while (retries > 0) {
            try {
                await delay(500); // Delay between requests
                let result = await translate(text, { to: targetLang });
                return result.text;
            } catch (error) {
                console.error('Translation error:', error);
                if (error.message.includes('TooManyRequestsError')) {
                    await delay(10000); // Wait for 10 seconds before retrying
                } else {
                    return text; // Return original text if translation fails
                }
                retries -= 1;
            }
        }
        return text; // Return original text if all retries fail
    }

    // Create the caption with translations
    let caption = await Promise.all(src.map(async (v, i) => {
        // Translate title and translation to English
        let translatedTitle = await translateText(v.title, 'en');
        let translatedTranslation = await translateText(v.translation, 'en');

        return `
*${i + 1}.* ${translatedTitle}

âƒ Latin :
${v.latin}

âƒ Arabic :
${v.arabic}

âƒ Translate :
${translatedTranslation}
`.trim();
    }));

    // Join all captions
    let captionText = caption.join('\n\n');

    // URL for the image (replace with actual image URL if necessary)
    const imageUrl = 'https://i.ibb.co/8NksWfT/ISLAM-IMAGE.png'; // Change this if needed

    // Send the caption along with the image
    await XliconBotInc.sendMessage(m.chat, {
        image: { url: imageUrl }, // Image URL
        caption: captionText // The translated text content
    });
}
break;



case 'ayatalkursi': {
  let caption = `
*ã€Œ Ayat Kursi ã€*
Ø§Ù„Ù„Ù‘ÙÙ‡Ù Ù„ÙØ§ Ø¥ÙÙ„ÙÙ‡Ù Ø¥ÙÙ„Ù‘ÙØ§ Ù‡ÙÙˆÙ Ø§Ù„Ù’Ø­ÙÙŠÙ‘Ù Ø§Ù„Ù’Ù‚ÙÙŠÙ‘ÙÙˆÙ…Ù Ù„ÙØ§ ØªÙØ£Ù’Ø®ÙØ°ÙÙ‡Ù Ø³ÙÙ†ÙØ©ÙŒ ÙˆÙÙ„ÙØ§ Ù†ÙÙˆÙ’Ù…ÙŒ Ù„ÙÙ‡Ù Ù…ÙØ§ ÙÙÙŠ Ø§Ù„Ø³Ù‘ÙÙ…ÙØ§ÙˆÙØ§ØªÙ ÙˆÙÙ…ÙØ§ ÙÙÙŠ Ø§Ù„Ù’Ø£ÙØ±Ù’Ø¶Ù Ù…ÙÙ†Ù’ Ø°ÙØ§ Ø§Ù„Ù‘ÙØ°ÙÙŠ ÙŠÙØ´Ù’ÙÙØ¹Ù Ø¹ÙÙ†Ø¯ÙÙ‡Ù Ø¥ÙÙ„Ù‘ÙØ§ Ø¨ÙØ¥ÙØ°Ù’Ù†ÙÙ‡Ù ÙŠÙØ¹Ù’Ù„ÙÙ…Ù Ù…ÙØ§ Ø¨ÙÙŠÙ’Ù†Ù Ø£ÙÙŠÙ’Ø¯ÙÙŠÙ‡ÙÙ…Ù’ ÙˆÙÙ…ÙØ§ Ø®ÙÙ„Ù’ÙÙÙ‡ÙÙ…Ù’ ÙˆÙÙ„ÙØ§ ÙŠÙØ­ÙÙŠØ·ÙÙˆÙ†Ù Ø¨ÙØ´ÙÙŠÙ’Ø¡Ù Ù…ÙÙ†Ù’ Ø¹ÙÙ„Ù’Ù…ÙÙ‡Ù Ø¥ÙÙ„Ù‘ÙØ§ Ø¨ÙÙ…ÙØ§ Ø´ÙØ§Ø¡Ù ÙˆÙØ³ÙØ¹Ù ÙƒÙØ±Ù’Ø³ÙÙŠÙ‘ÙÙ‡Ù Ø§Ù„Ø³Ù‘ÙÙ…ÙØ§ÙˆÙØ§ØªÙ ÙˆÙØ§Ù„Ù’Ø£ÙØ±Ù’Ø¶Ù ÙˆÙÙ„ÙØ§ ÙŠÙØ¦ÙÙˆØ¯ÙÙ‡Ù Ø­ÙÙÙ’Ø¸ÙÙ‡ÙÙ…ÙØ§ ÙˆÙÙ‡ÙÙˆÙ Ø§Ù„Ù’Ø¹ÙÙ„ÙÙŠÙ‘Ù Ø§Ù„Ù’Ø¹ÙØ¸ÙÙŠÙ…Ù
â€œAlloohu laa ilaaha illaa huwal hayyul qoyyuum, laa taâ€™khudzuhuu sinatuw walaa naum. Lahuu maa fissamaawaati wa maa fil ardli man dzal ladzii yasyfaâ€™u â€˜indahuu illaa biidznih, yaâ€™lamu maa baina aidiihim wamaa kholfahum wa laa yuhiithuuna bisyaiâ€™im min â€˜ilmihii illaa bimaa syaaâ€™ wasiâ€™a kursiyyuhus samaawaati wal ardlo walaa yaâ€™uuduhuu hifdhuhumaa wahuwal â€˜aliyyul â€˜adhiim.â€

ØªØ±Ø¬Ù…Û:
Ø§Ù„Ù„ÛØŒ Ú©ÙˆØ¦ÛŒ Ù…Ø¹Ø¨ÙˆØ¯ Ù†ÛÛŒÚº Ø³ÙˆØ§Ø¦Û’ Ø§Ø³ Ú©Û’ØŒ Ø¬Ùˆ Ø²Ù†Ø¯Û ÛÛ’ØŒ Ø¯Ø§Ø¦Ù…ÛŒ Ø§ÙˆØ± Ù…Ø³Ù„Ø³Ù„ Ø§Ù¾Ù†Û’ Ù…Ø®Ù„ÙˆÙ‚Ø§Øª Ú©ÛŒ Ø¯ÛŒÚ©Ú¾ Ø¨Ú¾Ø§Ù„ Ú©Ø±ØªØ§ ÛÛ’Ø› Ù†Û Ø§ÙˆÙ†Ú¯Ú¾ØªØ§ ÛÛ’ Ø§ÙˆØ± Ù†Û ÛÛŒ Ø³ÙˆØªØ§ ÛÛ’Û” Ø¬Ùˆ Ú©Ú†Ú¾ Ø¢Ø³Ù…Ø§Ù†ÙˆÚº Ø§ÙˆØ± Ø²Ù…ÛŒÙ† Ù…ÛŒÚº ÛÛ’ØŒ ÙˆÛ Ø³Ø¨ Ø§Ù„Ù„Û Ú©Ø§ ÛÛ’Û” Ø§Ù„Ù„Û Ú©Û’ Ù¾Ø§Ø³ Ø´ÙØ§Ø¹Øª Ú©Ø±Ù†Û’ Ú©Ø§ Ø§Ø®ØªÛŒØ§Ø± Ú©Ø³ÛŒ Ú©Ùˆ Ø¨Ú¾ÛŒ Ù†ÛÛŒÚºØŒ Ø³ÙˆØ§Ø¦Û’ Ø§Ø³ Ú©Û’ Ú©Û Ø§Ù„Ù„Û Ø§Ø¬Ø§Ø²Øª Ø¯Û’Û”
Ø§Ù„Ù„Û Ø¬Ø§Ù†ØªØ§ ÛÛ’ Ø¬Ùˆ Ú©Ú†Ú¾ Ø§Ù† Ú©Û’ Ø³Ø§Ù…Ù†Û’ ÛÛ’ Ø§ÙˆØ± Ø¬Ùˆ Ú©Ú†Ú¾ Ø§Ù† Ú©Û’ Ù¾ÛŒÚ†Ú¾Û’ ÛÛ’ØŒ Ø§ÙˆØ± ÙˆÛ Ø§Ù„Ù„Û Ú©Û’ Ø¹Ù„Ù… Ú©Û’ Ú©Ø³ÛŒ Ø¨Ú¾ÛŒ Ú†ÛŒØ² Ú©Ùˆ Ù†ÛÛŒÚº Ø¬Ø§Ù† Ø³Ú©ØªÛ’ Ø³ÙˆØ§Ø¦Û’ Ø§Ø³ Ú©Û’ Ø¬Ùˆ Ø§Ù„Ù„Û Ú†Ø§ÛÛ’Û” Ø§Ù„Ù„Û Ú©ÛŒ Ú©Ø±Ø³ÛŒ Ø¢Ø³Ù…Ø§Ù†ÙˆÚº Ø§ÙˆØ± Ø²Ù…ÛŒÙ† Ú©Ùˆ Ù…Ø­ÛŒØ· ÛÛ’ØŒ Ø§ÙˆØ± Ø§Ù„Ù„Û Ú©Ùˆ Ø§Ù† Ø¯ÙˆÙ†ÙˆÚº Ú©Ùˆ Ù…Ø­ÙÙˆØ¸ Ø±Ú©Ú¾Ù†Û’ Ù…ÛŒÚº Ú©ÙˆØ¦ÛŒ Ø¨ÙˆØ¬Ú¾ Ù†ÛÛŒÚº Ù…Ø­Ø³ÙˆØ³ ÛÙˆØªØ§ØŒ Ø§ÙˆØ± Ø§Ù„Ù„Û Ø¨ÛØª Ø¨Ù„Ù†Ø¯ Ø§ÙˆØ± Ø¹Ø¸ÛŒÙ… ÛÛ’Û”
(QS. Al Baqarah: 255)
  `.trim();

  // URL for the image (replace with your preferred image URL)
  const imageUrl = 'https://i.ibb.co/8NksWfT/ISLAM-IMAGE.png'; // Update as needed

  // Send the caption with the image
  await XliconBotInc.sendMessage(m.chat, {
    image: { url: imageUrl }, // Image URL
    caption: caption // The caption content
  });
}
break;

case 'niyatnamaz': {
  if (!q) return replygcxlicon(`Usage Example:\nniyatnamaz Subuh`);

  // Array containing the prayer intentions
  const niyatnamaz = [
    {
      solat: "subuh",
      latin: "Ushalli fardhosh shubhi rok'ataini mustaqbilal qiblati adaa-an lillaahi ta'aala",
      arabic: "Ø§ÙØµÙÙ„Ù‘ÙÙ‰ ÙÙØ±Ù’Ø¶Ù Ø§Ù„ØµÙ‘ÙØ¨Ù’Ø­Ù Ø±ÙÙƒÙ’Ø¹ÙØªÙÙŠÙ’Ù†Ù Ù…ÙØ³Ù’ØªÙÙ‚Ù’Ø¨ÙÙ„Ù Ø§Ù„Ù’Ù‚ÙØ¨Ù’Ù„ÙØ©Ù Ø§ÙØ¯ÙØ§Ø¡Ù‹ ÙÙ„Ù„Ù‡Ù ØªÙØ¹ÙØ§Ù„ÙÙ‰",
      translation_en: "I intend to perform the Fardh of Subuh (Fajr) with two raka'ats facing the Qibla for the sake of Allah Ta'ala",
    },
    {
      solat: "maghrib",
      latin: "Ushalli fardhol maghribi tsalaata raka'aatim mustaqbilal qiblati adaa-an lillaahi ta'aala",
      arabic: "Ø§ÙØµÙÙ„Ù‘ÙÙ‰ ÙÙØ±Ù’Ø¶Ù Ø§Ù„Ù’Ù…ÙØºÙ’Ø±ÙØ¨Ù Ø«ÙÙ„Ø§ÙØ«Ù Ø±ÙÙƒÙØ¹ÙØ§ØªÙ Ù…ÙØ³Ù’ØªÙÙ‚Ù’Ø¨ÙÙ„Ù Ø§Ù„Ù’Ù‚ÙØ¨Ù’Ù„ÙØ©Ù Ø§ÙØ¯ÙØ§Ø¡Ù‹ ÙÙ„Ù„Ù‡Ù ØªÙØ¹ÙØ§Ù„ÙÙ‰",
      translation_en: "I intend to perform the Fardh of Maghrib with three raka'ats facing the Qibla for the sake of Allah Ta'ala",
    },
    {
      solat: "dzuhur",
      latin: "Ushalli fardhodl dhuhri arba'a raka'aatim mustaqbilal qiblati adaa-an lillaahi ta'aala",
      arabic: "Ø§ÙØµÙÙ„Ù‘ÙÙ‰ ÙÙØ±Ù’Ø¶Ù Ø§Ù„Ø¸Ù‘ÙÙ‡Ù’Ø±ÙØ§ÙØ±Ù’Ø¨ÙØ¹Ù Ø±ÙÙƒÙØ¹ÙØ§ØªÙ Ù…ÙØ³Ù’ØªÙÙ‚Ù’Ø¨ÙÙ„Ù Ø§Ù„Ù’Ù‚ÙØ¨Ù’Ù„ÙØ©Ù Ø§ÙØ¯ÙØ§Ø¡Ù‹ ÙÙ„Ù„Ù‡Ù ØªÙØ¹ÙØ§Ù„ÙÙ‰",
      translation_en: "I intend to perform the Fardh of Dzuhur (Dhuhr) with four raka'ats facing the Qibla for the sake of Allah Ta'ala",
    },
    {
      solat: "isha",
      latin: "Ushalli fardhol 'isyaa-i arba'a raka'aatim mustaqbilal qiblati adaa-an lillaahi ta'aala",
      arabic: "ØµÙÙ„Ù‘ÙÙ‰ ÙÙØ±Ù’Ø¶Ù Ø§Ù„Ù’Ø¹ÙØ´ÙØ§Ø¡Ù Ø§ÙØ±Ù’Ø¨ÙØ¹Ù Ø±ÙÙƒÙØ¹ÙØ§ØªÙ Ù…ÙØ³Ù’ØªÙÙ‚Ù’Ø¨ÙÙ„Ù Ø§Ù„Ù’Ù‚ÙØ¨Ù’Ù„ÙØ©Ù Ø§ÙØ¯ÙØ§Ø¡Ù‹ ÙÙ„Ù„Ù‡Ù ØªÙØ¹ÙØ§Ù„ÙÙ‰",
      translation_en: "I intend to perform the Fardh of Isha with four raka'ats facing the Qibla for the sake of Allah Ta'ala",
    },
    {
      solat: "ashar",
      latin: "Ushalli fardhol 'ashri arba'a raka'aatim mustaqbilal qiblati adaa-an lillaahi ta'aala",
      arabic: "ØµÙÙ„Ù‘ÙÙ‰ ÙÙØ±Ù’Ø¶Ù Ø§Ù„Ù’Ø¹ÙØµÙ’Ø±ÙØ§ÙØ±Ù’Ø¨ÙØ¹Ù Ø±ÙÙƒÙØ¹ÙØ§ØªÙ Ù…ÙØ³Ù’ØªÙÙ‚Ù’Ø¨ÙÙ„Ù Ø§Ù„Ù’Ù‚ÙØ¨Ù’Ù„ÙØ©Ù Ø§ÙØ¯ÙØ§Ø¡Ù‹ ÙÙ„Ù„Ù‡Ù ØªÙØ¹ÙØ§Ù„ÙÙ‰",
      translation_en: "I intend to perform the Fardh of Ashar (Asr) with four raka'ats facing the Qibla for the sake of Allah Ta'ala",
    }
  ];

  // Convert user input to lowercase for matching
  let text = q.toLowerCase() || '';
  let data = niyatnamaz.find(v => v.solat === text);

  // If the requested prayer is not found
  if (!data) {
    return replygcxlicon(`Command ${text} Not Found\n\nList of 5 Daily Prayers:\nâ€¢ Subuh\nâ€¢ Maghrib\nâ€¢ Dzuhur\nâ€¢ Isha\nâ€¢ Ashar`);
  }

  // Format the response
  const responseText = `
_*Intention for the ${text.charAt(0).toUpperCase() + text.slice(1)} Prayer*_

*Arabic:* ${data.arabic}

*Latin:* ${data.latin}

*Translation:* ${data.translation_en}`.trim();

  // URL for the image (replace with your preferred image URL)
  const imageUrl = 'https://i.ibb.co/8NksWfT/ISLAM-IMAGE.png'; // Update as needed

  // Send the response with the image and caption using replygcxlicon
  await replygcxlicon(responseText);
  
  // Send the image separately as the last reply
  await XliconBotInc.sendMessage(m.chat, {
    image: { url: imageUrl }, // Image URL
    caption: 'Here is the image related to your prayer intention.' // A simple caption for the image
  });
}
break;


case 'quotesislami': {
  // Array of Islamic quotes
  const islami = [
    { id: "1", arabic: "Ù…ÙÙ†Ù’ Ø³ÙØ§Ø±Ù Ø¹ÙÙ„Ù‰Ù Ø§Ù„Ø¯ÙÙ‘Ø±Ù’Ø¨Ù ÙˆÙØµÙÙ„Ù", translation_en: "Whoever walks the path will reach (their goal)." },
    { id: "2", arabic: "Ù…ÙÙ†Ù’ ØµÙØ¨ÙØ±Ù Ø¸ÙÙÙØ±Ù", translation_en: "Whoever is patient will be successful." },
    { id: "3", arabic: "Ù…ÙÙ†Ù’ Ø¬ÙØ¯ÙÙ‘ ÙˆÙØ¬ÙÙ€Ø¯Ù", translation_en: "Whoever strives will achieve (success)." },
    { id: "4", arabic: "Ø¬ÙØ§Ù„ÙØ³Ù’ Ø£ÙÙ‡Ù’Ù„Ù Ø§Ù„ØµÙÙ‘Ø¯Ù’Ù‚Ù ÙˆÙØ§Ù„ÙˆÙÙÙØ§Ø¡Ù", translation_en: "Associate with those who are truthful and trustworthy." },
    { id: "5", arabic: "Ù…ÙÙ†Ù’ Ù‚ÙÙ„ÙÙ‘ ØµÙØ¯Ù’Ù‚ÙÙ‡Ù Ù‚ÙÙ„ÙÙ‘ ØµÙØ¯ÙÙŠÙ’Ù‚ÙÙ‡Ù", translation_en: "Whoever has little honesty will have few friends." },
    { id: "6", arabic: "Ù…ÙÙˆÙØ¯ÙÙ‘Ø©Ù Ø§Ù„ØµÙÙ‘Ø¯ÙÙŠÙ’Ù‚Ù ØªÙØ¸Ù’Ù‡ÙØ±Ù ÙˆÙÙ‚Ù’ØªÙ Ø§Ù„Ø¶ÙÙ‘ÙŠÙ’Ù‚Ù", translation_en: "The affection of a friend shows in times of hardship." },
    { id: "7", arabic: "Ø§Ù„ØµÙÙ‘Ø¨Ù’Ø±Ù ÙŠÙØ¹ÙÙŠÙ’Ù†Ù Ø¹ÙÙ„ÙÙ‰ ÙƒÙÙ„ÙÙ‘ Ø¹ÙÙ…ÙÙ„Ù", translation_en: "Patience helps with every task." },
    { id: "8", arabic: "ÙˆÙÙ…ÙØ§ Ø§Ù„Ù„ÙÙ‘Ø°ÙÙ‘Ø©Ù Ø¥ÙÙ„Ø§ÙÙ‘ Ø¨ÙØ¹Ù’Ø¯Ù Ø§Ù„ØªÙÙ‘Ø¹ÙØ¨Ù", translation_en: "There is no pleasure except after effort." },
    { id: "9", arabic: "Ø¬ÙØ±ÙÙ‘Ø¨Ù’ ÙˆÙÙ„Ø§ÙØ­ÙØ¸Ù’ ØªÙÙƒÙÙ†Ù’ Ø¹ÙØ§Ø±ÙÙÙ‹Ø§", translation_en: "Try and observe, and you will gain knowledge." },
    { id: "10", arabic: "Ø¨ÙÙŠÙ’Ø¶ÙØ©Ù Ø§Ù„ÙŠÙÙˆÙ’Ù…Ù Ø®ÙÙŠÙ’Ø±ÙŒ Ù…ÙÙ†Ù’ Ø¯ÙØ¬ÙØ§Ø¬ÙØ©Ù Ø§Ù„ØºÙØ¯Ù", translation_en: "Today's egg is better than tomorrow's chicken." },
    { id: "11", arabic: "Ø£ÙØ·Ù’Ù„ÙØ¨Ù Ø§Ù„Ù’Ø¹ÙÙ„Ù’Ù…Ù Ù…ÙÙ†Ù Ø§Ù„Ù’Ù…ÙÙ‡Ù’Ø¯Ù Ø¥ÙÙ„ÙÙ‰ Ø§Ù„ÙÙ‘Ù„Ø­Ù’Ø¯Ù", translation_en: "Seek knowledge from the cradle to the grave." },
    { id: "12", arabic: "Ø§Ù„ÙˆÙÙ‚Ù’ØªÙ Ø£ÙØ«Ù’Ù…ÙÙ†Ù Ù…ÙÙ†Ù Ø§Ù„Ø°ÙÙ‘Ù‡ÙØ¨Ù", translation_en: "Time is more valuable than gold." },
    { id: "13", arabic: "Ù„Ø§Ù Ø®ÙÙŠÙ’Ø±Ù ÙÙŠÙ Ù„ÙØ°ÙÙ‘Ø©Ù ØªÙØ¹Ù’Ù‚ÙØ¨Ù Ù†ÙØ¯ÙÙ…Ø§Ù‹", translation_en: "There is no good in pleasure that is followed by regret." },
    { id: "14", arabic: "Ø£ÙØ®ÙÙŠ Ù„ÙÙ†Ù’ ØªÙÙ†ÙØ§Ù„Ù Ø§Ù„Ø¹ÙÙ„Ù’Ù…Ù Ø¥ÙÙ„Ø§ÙÙ‘ Ø¨ÙØ³ÙØªÙÙ‘Ø©Ù Ø³ÙØ£ÙÙ†Ù’Ø¨ÙÙŠÙ’ÙƒÙ Ø¹ÙÙ†Ù’ ØªÙÙÙ’ØµÙÙŠÙ’Ù„ÙÙ‡ÙØ§ Ø¨ÙØ¨ÙÙŠÙØ§Ù†Ù: Ø°ÙÙƒÙØ§Ø¡ÙŒ ÙˆÙØ­ÙØ±Ù’ØµÙŒ ÙˆÙØ§Ø¬Ù’ØªÙÙ‡ÙØ§Ø¯ÙŒ ÙˆÙØ¯ÙØ±Ù’Ù‡ÙÙ…ÙŒ ÙˆÙØµÙØ­Ù’Ø¨ÙØ©Ù Ø£ÙØ³Ù’ØªÙØ§Ø°Ù ÙˆÙØ·ÙÙˆÙ’Ù„Ù Ø²ÙÙ…ÙØ§Ù†Ù", translation_en: "My brother, you will not attain knowledge except through six things: intelligence, eagerness, diligence, money, companionship with a teacher, and a long period of time." },
    { id: "15", arabic: "Ù„Ø§Ù ØªÙÙƒÙÙ†Ù’ Ø±ÙØ·Ù’Ø¨Ø§Ù‹ ÙÙØªÙØ¹Ù’ØµÙØ±Ù ÙˆÙÙ„Ø§Ù ÙŠÙØ§Ø¨ÙØ³Ù‹Ø§ ÙÙØªÙÙƒÙØ³ÙÙ‘Ø±Ù", translation_en: "Do not be soft so that you are easily squeezed, nor hard so that you are easily broken." },
    { id: "16", arabic: "Ù„ÙÙƒÙÙ„ÙÙ‘ Ù…ÙÙ‚ÙØ§Ù…Ù Ù…ÙÙ‚ÙØ§Ù„ÙŒ ÙˆÙÙ„ÙÙƒÙÙ„ÙÙ‘ Ù…ÙÙ‚ÙØ§Ù„Ù Ù…ÙÙ‚ÙØ§Ù…ÙŒ", translation_en: "Every place has its own speech, and every speech has its own place." },
    { id: "17", arabic: "Ø®ÙÙŠÙ’Ø±Ù Ø§Ù„Ù†ÙÙ‘Ø§Ø³Ù Ø£ÙØ­Ù’Ø³ÙÙ†ÙÙ‡ÙÙ…Ù’ Ø®ÙÙ„ÙÙ‚Ø§Ù‹ ÙˆÙØ£ÙÙ†Ù’ÙÙØ¹ÙÙ‡ÙÙ…Ù’ Ù„ÙÙ„Ù†ÙÙ‘Ø§Ø³Ù", translation_en: "The best of people are those who have the best manners and are the most beneficial to others." },
    { id: "18", arabic: "Ø®ÙÙŠÙ’Ø±Ù Ø¬ÙÙ„ÙÙŠÙ’Ø³Ù ÙÙŠ Ø§Ù„Ø²Ù‘Ù…Ø§Ù†Ù ÙƒÙØªØ§Ø¨Ù", translation_en: "The best companion in any era is a book." },
    { id: "19", arabic: "Ù…ÙÙ†Ù’ ÙŠÙØ²Ù’Ø±ÙØ¹Ù’ ÙŠÙØ­Ù’ØµÙØ¯Ù’", translation_en: "Whoever plants will harvest." },
    { id: "20", arabic: "Ù„ÙÙˆÙ’Ù„Ø§Ù Ø§Ù„Ø¹ÙÙ„Ù’Ù…Ù Ù„ÙÙƒÙØ§Ù†Ù Ø§Ù„Ù†ÙÙ‘Ø§Ø³Ù ÙƒÙØ§Ù„Ø¨ÙÙ‡ÙØ§Ø¦ÙÙ…Ù", translation_en: "If not for knowledge, people would be like animals." },
    { id: "21", arabic: "Ø³ÙÙ„Ø§ÙÙ…ÙØ©Ù Ø§Ù„Ø¥ÙÙ†Ù’Ø³ÙØ§Ù†Ù ÙÙŠÙ Ø­ÙÙÙ’Ø¸Ù Ø§Ù„Ù„ÙÙ‘Ø³ÙØ§Ù†Ù", translation_en: "The safety of a person lies in the protection of their tongue (words)." },
    { id: "22", arabic: "Ø§Ù„Ø±ÙÙ‘ÙÙ’Ù‚Ù Ø¨ÙØ§Ù„Ø¶ÙÙ‘Ø¹ÙÙŠÙ’ÙÙ Ù…ÙÙ†Ù’ Ø®ÙÙ„ÙÙ‚Ù Ø§Ù„Ø´ÙÙ‘Ø±ÙÙŠÙ’ÙÙ", translation_en: "Being gentle with the weak is a mark of noble character." },
    { id: "23", arabic: "ÙˆÙØ¹ÙØ§Ù…ÙÙ„Ù Ø§Ù„Ù†ÙÙ‘Ø§Ø³Ù Ø¨ÙÙ…ÙØ§ ØªÙØ­ÙØ¨ÙÙ‘ Ù…ÙÙ†Ù’Ù‡Ù Ø¯ÙØ§Ø¦ÙÙ…Ø§Ù‹", translation_en: "Treat people in a way that you would like to be treated." },
    { id: "24", arabic: "Ù„ÙÙŠÙ’Ø³Ù Ø§Ù„Ø¬ÙÙ…ÙØ§Ù„Ù Ø¨ÙØ£ÙØ«Ù’ÙˆÙØ§Ø¨Ù ØªÙØ²ÙÙŠÙÙ‘Ù†ÙÙ†ÙØ§ Ø¥ÙÙ†ÙÙ‘ Ø§Ù„Ø¬ÙÙ…ÙØ§Ù„Ù Ø¬Ù…ÙØ§ÙÙ„Ù Ø§Ù„Ø¹ÙÙ„Ù’Ù…Ù ÙˆÙØ§Ù„Ø£ÙØ¯ÙØ¨Ù", translation_en: "Beauty is not in the clothes that adorn us, but in knowledge and manners." },
    { id: "25", arabic: "Ù…ÙÙ†Ù’ Ø£ÙØ¹Ø§ÙÙ†ÙÙƒÙ Ø¹ÙÙ„Ù‰Ù Ø§Ù„Ø´ÙÙ‘Ø±ÙÙ‘ Ø¸ÙÙ„ÙÙ…ÙÙƒÙ", translation_en: "Whoever helps you in wrongdoing has wronged you." }
  ];

  // Select a random quote
  const randomIndex = Math.floor(Math.random() * islami.length);
  const randomQuote = islami[randomIndex];
  const { arabic, translation_en } = randomQuote;

  // Format the response text
  const responseText = `${arabic}\n\n${translation_en}`;

  // Now send the image with the last reply
  const imageUrl = 'https://i.ibb.co/8NksWfT/ISLAM-IMAGE.png'; // Replace with the actual image URL
  await XliconBotInc.sendMessage(m.chat, {
    image: { url: imageUrl },
    caption: responseText
  });
}
break;

case 'assalamualaikum': {
  const imageUrl = 'https://i.ibb.co/8NksWfT/ISLAM-IMAGE.png'; // Replace with the actual image URL
  await XliconBotInc.sendMessage(m.chat, {
    image: { url: imageUrl },
    caption: "Waalaikumsalam Wa Rehmatullahi Wa Barakatuhu"
  });
}
break;



case 'hadith': {
  const apiUrl = 'https://api.lolhuman.xyz/api/hadits/detail/Sunan_Tirmidzi/1769?apikey=dcb4198762eb793a386a9c1c';

  try {
    // Fetch Hadith details from the API
    let response = await fetch(apiUrl);
    let data = await response.json();

    if (data.status !== 200) {
      return await XliconBotInc.sendText(m.chat, "Failed to fetch Hadith details.");
    }

    // Extract the Hadith text and ID
    let hadith = data.result['1'];
    let hadithText = hadith.nass;

    // Delay function to throttle requests
    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Translate function with retry logic
    async function translateText(text, targetLang) {
      let retries = 5;
      while (retries > 0) {
        try {
          await delay(500); // Delay between requests
          let result = await translate(text, { to: targetLang });
          return result.text;
        } catch (error) {
          console.error('Translation error:', error);
          if (error.message.includes('TooManyRequestsError')) {
            await delay(10000); // Wait for 10 seconds before retrying
          } else {
            return text; // Return original text if translation fails
          }
          retries -= 1;
        }
      }
      return text; // Return original text if all retries fail
    }

    // Translate the Hadith text to Urdu
    let translatedHadith = await translateText(hadithText, 'ur');

    // Create the caption with translations
    let captionText = `
*Hadith ID:* ${hadith.id}

âƒ Original Text:
${hadithText}

âƒ Translated Text (Urdu):
${translatedHadith}
`.trim();

    // Send the image with caption directly
    const imageUrl = 'https://i.ibb.co/8NksWfT/ISLAM-IMAGE.png'; // Replace with the actual image URL
    await XliconBotInc.sendMessage(m.chat, {
      image: { url: imageUrl },
      caption: captionText // Directly use captionText here
    });

  } catch (error) {
    console.error('Error fetching or processing Hadith:', error);
    return await XliconBotInc.sendText(m.chat, "An error occurred while fetching the Hadith.");
  }
}
break;


case 'prophetname': {
  try {
    // Define the API URL
    const apiUrl = `${global.api}islamic/prophet-names?apikey=${global.id}`;

    // Fetch data from the API
    let response = await fetch(apiUrl);
    let data = await response.json();

    // Check if the request was successful
    if (data.status !== 200) {
      return await XliconBotInc.sendText(m.chat, "Failed to fetch Prophet's name.");
    }

    // Extract the Prophet's name
    let prophetName = data.result.name;

    // Create the message content
    let captionText = `
*Prophet's Name:*
${prophetName}
`.trim();

    // Now send the image with the last reply
    const imageUrl = 'https://i.ibb.co/8NksWfT/ISLAM-IMAGE.png'; // Replace with the actual image URL
    await XliconBotInc.sendMessage(m.chat, {
      image: { url: imageUrl },
      caption: captionText // Directly use captionText here
    });

  } catch (error) {
    console.error('Error fetching Prophet\'s name:', error);
    return await XliconBotInc.sendText(m.chat, "An error occurred while fetching the Prophet's name.");
  }
}
break;

        
case 'prayertime': {
  // Extract the city name from the command input
  let city = m.text.split(' ').slice(1).join(' ');
  if (!city) {
      return await replygcxlicon("Please provide a city name, e.g., `prayertime Lahore`.");
  }

  // Define the API URL with the city parameter using global variables
  const apiUrl = `${global.api}islamic/prayer-times?city=${encodeURIComponent(city)}&apikey=${global.id}`;

  try {
      // Fetch data from the API
      let response = await fetch(apiUrl);
      let data = await response.json();

      // Check if the request was successful
      if (data.status !== 200 || data.result.status_valid !== 1) {
          return await replygcxlicon("Failed to fetch prayer times. Please check the city name and try again.");
      }

      // Assign emojis for each prayer time
      let fajrEmoji = 'ğŸŒ…';
      let dhuhrEmoji = 'ğŸŒ';
      let asrEmoji = 'ğŸŒ¤';
      let maghribEmoji = 'ğŸŒ‡';
      let ishaEmoji = 'ğŸŒ™';

      // Extract relevant data
      let cityName = data.result.city;
      let method = data.result.prayer_method_name;
      let items = data.result.items[0];
      let fajr = fajrEmoji + ' Fajr: ' + items.fajr;
      let dhuhr = dhuhrEmoji + ' Dhuhr: ' + items.dhuhr;
      let asr = asrEmoji + ' Asr: ' + items.asr;
      let maghrib = maghribEmoji + ' Maghrib: ' + items.maghrib;
      let isha = ishaEmoji + ' Isha: ' + items.isha;

      // Create the message content
      let captionText = `
*Prayer Times for ${cityName}:*

${fajr}
${dhuhr}
${asr}
${maghrib}
${isha}

*Method:* ${method}
`.trim();

    
      // Now send the image with the last reply
      const imageUrl = 'https://i.ibb.co/8NksWfT/ISLAM-IMAGE.png'; // Replace with the actual image URL
      await XliconBotInc.sendMessage(m.chat, {
        image: { url: imageUrl },
        caption: captionText // Directly use captionText here
      });

  } catch (error) {
      console.error('Error fetching prayer times:', error);
      return await replygcxlicon("An error occurred while fetching the prayer times.");
  }
}
break;

case 'sahihbukhari': {
  // Supported languages
  const languageNames = {
    'ar': 'Arabic',
    'ur': 'Urdu',
    'en': 'English',
    'id': 'Indonesian',
    'bn': 'Bengali',
    'rus': 'Russian',
    'tr': 'Turkish',
    'ta': 'Tamil'
  };

  // If no language is specified, send the list of available languages
  if (!text || !Object.keys(languageNames).includes(text.toLowerCase())) {
    let languageList = 'Available languages for Hadith:\n\n';
    for (let lang in languageNames) {
      languageList += `- ${languageNames[lang]} (${lang})\n`;
    }
    languageList += `\nPlease specify a language using the format: \`sahihbukhari <language code>\` (e.g., \`sahihbukhari en\`)`;
    return await replygcxlicon(languageList);
  }

  // Extract the language from the text (e.g., "en" from "sahihbukhari en")
  const lang = text.toLowerCase();

  // If the language is not valid, show the language options
  if (!languageNames[lang]) {
    let languageList = 'Available languages for Hadith:\n\n';
    for (let langCode in languageNames) {
      languageList += `- ${languageNames[langCode]} (${langCode})\n`;
    }
    languageList += `\nPlease choose a valid language.`;
    return await replygcxlicon(languageList);
  }

  // Generate a random Hadith number between 1 and 7560
  const randomHadithNumber = Math.floor(Math.random() * 7560) + 1;

  try {
    // Fetch the Hadith from the API
    let url = `${global.api}islamic/hadith-sahih-al-bukhari?q=${randomHadithNumber}/${lang}&apikey=${global.id}`;
    let response = await fetch(url);
    let data = await response.json();

    // Check if the response is successful and contains Hadith data
    if (data.status === 200 && data.result && data.result.data && data.result.data.hadiths) {
      let hadiths = data.result.data.hadiths;
      if (hadiths.length > 0) {
        // Display the Hadith
        let hadith = hadiths[0];
        let captionText = `*Hadith Number:* ${hadith.hadithnumber}\n`
                        + `*Text:* ${hadith.text}\n`
                        + `*Book:* ${hadith.reference.book}\n`
                        + `*Hadith:* ${hadith.reference.hadith}`;
        
      
        // Now send the image with the last reply
        const imageUrl = 'https://i.ibb.co/8NksWfT/ISLAM-IMAGE.png'; // Replace with the actual image URL
        await XliconBotInc.sendMessage(m.chat, {
          image: { url: imageUrl },
          caption: captionText // Use the Hadith caption here
        });
      } else {
        await XliconBotInc.sendText(m.chat, "*No Hadith found for the given query.*");
      }
    } else {
      await XliconBotInc.sendText(m.chat, "*Failed to fetch Hadith. Please try again later.*");
    }
  } catch (error) {
    await XliconBotInc.sendText(m.chat, "*Error occurred while fetching Hadith.*");
  }
}
break;

case 'jamiattirmidhi': {
  // Supported languages
  const languageNames = {
    'ar': 'Arabic',
    'ur': 'Urdu',
    'en': 'English',
    'id': 'Indonesian',
    'bn': 'Bengali',
    'tr': 'Turkish'
  };

  // If no language is specified, send the list of available languages
  if (!text || !Object.keys(languageNames).includes(text.toLowerCase())) {
    let languageList = 'Available languages for Hadith:\n\n';
    for (let lang in languageNames) {
      languageList += `- ${languageNames[lang]} (${lang})\n`;
    }
    languageList += `\nPlease specify a language using the format: \`jamiattirmidhi <language code>\` (e.g., \`jamiattirmidhi en\`)`;
    return await replygcxlicon(languageList);
  }

  // Extract the language from the text (e.g., "en" from "jamiattirmidhi en")
  const lang = text.toLowerCase();

  // If the language is not valid, show the language options
  if (!languageNames[lang]) {
    let languageList = 'Available languages for Hadith:\n\n';
    for (let langCode in languageNames) {
      languageList += `- ${languageNames[langCode]} (${langCode})\n`;
    }
    languageList += `\nPlease choose a valid language.`;
    return await replygcxlicon(languageList);
  }

  // Generate a random Hadith number between 1 and 148
  const randomHadithNumber = Math.floor(Math.random() * 148) + 1;

  try {
    // Fetch the Hadith from the API
    let url = `${global.api}islamic/hadith-jami-at-tirmidhi?q=${randomHadithNumber}/${lang}&apikey=${global.id}`;
    let response = await fetch(url);
    let data = await response.json();

    // Check if the response is successful and contains Hadith data
    if (data.status === 200 && data.result && data.result.data && data.result.data.hadiths) {
      let hadiths = data.result.data.hadiths;
      if (hadiths.length > 0) {
        // Display the Hadith
        let hadith = hadiths[0];
        let captionText = `*Hadith Number:* ${hadith.hadithnumber}\n`
                        + `*Text:* ${hadith.text}\n`
                        + `*Book:* ${hadith.reference.book}\n`
                        + `*Hadith:* ${hadith.reference.hadith}\n`
                        + `*Grades:*\n${hadith.grades.map(grade => `  *${grade.name}:* ${grade.grade}`).join('\n')}`;
        
        // Send the Hadith text using replygcxlicon
        await replygcxlicon(captionText);

        // Now send the image with the final response
        const imageUrl = 'https://i.ibb.co/8NksWfT/ISLAM-IMAGE.png'; // Replace with the actual image URL
        await XliconBotInc.sendMessage(m.chat, {
          image: { url: imageUrl },
          caption: captionText // Use the Hadith caption here
        });
      } else {
        await XliconBotInc.sendText(m.chat, "*No Hadith found for the given query.*");
      }
    } else {
      await XliconBotInc.sendText(m.chat, "*Failed to fetch Hadith. Please try again later.*");
    }
  } catch (error) {
    await XliconBotInc.sendText(m.chat, "*Error occurred while fetching Hadith.*");
  }
}
break;


case 'sunanannasai': {
  // Supported languages
  const languageNames = {
    'ar': 'Arabic',
    'ur': 'Urdu',
    'en': 'English',
    'id': 'Indonesian',
    'bn': 'Bengali',
    'tr': 'Turkish'
  };

  // If no language is specified, send the list of available languages
  if (!text || !Object.keys(languageNames).includes(text.toLowerCase())) {
    let languageList = 'Available languages for Hadith:\n\n';
    for (let lang in languageNames) {
      languageList += `- ${languageNames[lang]} (${lang})\n`;
    }
    languageList += `\nPlease specify a language using the format: \`sunanannasai <language code>\` (e.g., \`sunanannasai en\`)`;
    return await replygcxlicon(languageList); // Send with replygcxlicon for intermediate message
  }

  // Extract the language from the text (e.g., "en" from "sunanannasai en")
  const lang = text.toLowerCase();

  // If the language is not valid, show the language options
  if (!languageNames[lang]) {
    let languageList = 'Available languages for Hadith:\n\n';
    for (let langCode in languageNames) {
      languageList += `- ${languageNames[langCode]} (${langCode})\n`;
    }
    languageList += `\nPlease choose a valid language.`;
    return await replygcxlicon(languageList); // Send with replygcxlicon for invalid language
  }

  // Generate a random Hadith number between 1 and 324
  const randomHadithNumber = Math.floor(Math.random() * 324) + 1;

  try {
    // Fetch the Hadith from the API
    let url = `${global.api}islamic/hadith-sunan-nasai?q=${randomHadithNumber}/${lang}&apikey=${global.id}`;
    let response = await fetch(url);
    let data = await response.json();

    // Check if the response is successful and contains Hadith data
    if (data.status === 200 && data.result && data.result.data && data.result.data.hadiths) {
      let hadiths = data.result.data.hadiths;
      if (hadiths.length > 0) {
        // Display the Hadith
        let hadith = hadiths[0];
        let captionText = `*Hadith Number:* ${hadith.hadithnumber}\n`
                        + `*Text:* ${hadith.text}\n`
                        + `*Book:* ${hadith.reference.book}\n`
                        + `*Hadith:* ${hadith.reference.hadith}\n`
                        + `*Grades:*\n${hadith.grades.map(grade => `  *${grade.name}:* ${grade.grade}`).join('\n')}`;

       

        // Now send the final message with the image and caption
        const imageUrl = 'https://i.ibb.co/8NksWfT/ISLAM-IMAGE.png'; // Replace with the actual image URL
        await XliconBotInc.sendMessage(m.chat, {
          image: { url: imageUrl },
          caption: captionText // Attach the Hadith caption to the image
        });
      } else {
        await XliconBotInc.sendText(m.chat, "*No Hadith found for the given query.*");
      }
    } else {
      await XliconBotInc.sendText(m.chat, "*Failed to fetch Hadith. Please try again later.*");
    }
  } catch (error) {
    await XliconBotInc.sendText(m.chat, "*Error occurred while fetching Hadith.*");
  }
}
break;

case 'jamiattirmidhi': {
  // Supported languages
  const languageNames = {
    'ar': 'Arabic',
    'ur': 'Urdu',
    'en': 'English',
    'id': 'Indonesian',
    'bn': 'Bengali',
    'tr': 'Turkish'
  };

  // If no language is specified, send the list of available languages
  if (!text || !Object.keys(languageNames).includes(text.toLowerCase())) {
    let languageList = 'Available languages for Hadith:\n\n';
    for (let lang in languageNames) {
      languageList += `- ${languageNames[lang]} (${lang})\n`;
    }
    languageList += `\nPlease specify a language using the format: \`jamiattirmidhi <language code>\` (e.g., \`jamiattirmidhi en\`)`;
    return await replygcxlicon(languageList); // Send with replygcxlicon for intermediate message
  }

  // Extract the language from the text (e.g., "en" from "jamiattirmidhi en")
  const lang = text.toLowerCase();

  // If the language is not valid, show the language options
  if (!languageNames[lang]) {
    let languageList = 'Available languages for Hadith:\n\n';
    for (let langCode in languageNames) {
      languageList += `- ${languageNames[langCode]} (${langCode})\n`;
    }
    languageList += `\nPlease choose a valid language.`;
    return await replygcxlicon(languageList); // Send with replygcxlicon for invalid language
  }

  // Generate a random Hadith number between 1 and 148
  const randomHadithNumber = Math.floor(Math.random() * 148) + 1;

  try {
    // Fetch the Hadith from the API
    let url = `${global.api}islamic/hadith-jami-at-tirmidhi?q=${randomHadithNumber}/${lang}&apikey=${global.id}`;
    let response = await fetch(url);
    let data = await response.json();

    // Check if the response is successful and contains Hadith data
    if (data.status === 200 && data.result && data.result.data && data.result.data.hadiths) {
      let hadiths = data.result.data.hadiths;
      if (hadiths.length > 0) {
        // Display the Hadith
        let hadith = hadiths[0];
        let captionText = `*Hadith Number:* ${hadith.hadithnumber}\n`
                        + `*Text:* ${hadith.text}\n`
                        + `*Book:* ${hadith.reference.book}\n`
                        + `*Hadith:* ${hadith.reference.hadith}\n`
                        + `*Grades:*\n${hadith.grades.map(grade => `  *${grade.name}:* ${grade.grade}`).join('\n')}`;

        
        // Now send the final message with the image and caption
        const imageUrl = 'https://i.ibb.co/8NksWfT/ISLAM-IMAGE.png'; // Replace with the actual image URL
        await XliconBotInc.sendMessage(m.chat, {
          image: { url: imageUrl },
          caption: captionText // Attach the Hadith caption to the image
        });
      } else {
        await XliconBotInc.sendText(m.chat, "*No Hadith found for the given query.*");
      }
    } else {
      await XliconBotInc.sendText(m.chat, "*Failed to fetch Hadith. Please try again later.*");
    }
  } catch (error) {
    await XliconBotInc.sendText(m.chat, "*Error occurred while fetching Hadith.*");
  }
}
break;



 //------------------------------------------------------------------------------------------//

  case 'addlist':
if (!XliconTheCreator) return XliconStickOwner()
if (!m.isGroup) return XliconStickGroup()
var args1 = text.split("@")[0]
var args2 = text.split("@")[1]
if (!q.includes("@")) return replygcxlicon(`Usage Example: ${prefix+command} *Item Name@Item*\n\n_Example_\n\n${prefix+command} namelist@List`)
if (isAlreadyResponList(m.chat, args1, db_respon_list)) return replygcxlicon(`List of responses with key : *${args1}* already in this group.`)
if (/image/.test(mime)) {
media = await XliconBotInc.downloadAndSaveMediaMessage(quoted)
mem = await TelegraPh(media)
addResponList(m.chat, args1, args2, true, `${mem}`, db_respon_list)
replygcxlicon(`Successfully set list message with key : *${args1}*`)
if (fs.existsSync(media)) fs.unlinkSync(media)
} else {
addResponList(m.chat, args1, args2, false, '-', db_respon_list)
replygcxlicon(`Successful Add List With Key : *${args1}*`)
}
break

      
case 'dellist':
if (!XliconTheCreator) return XliconStickOwner()
if (!m.isGroup) return XliconStickGroup()
if (db_respon_list.length === 0) return replygcxlicon(`There is no message list in the database yet`)
if (!q) return replygcxlicon(`Usage Example: ${prefix + command} *Item name*\n\n_Example_\n\n${prefix + command} listname`)
if (!isAlreadyResponList(m.chat, q, db_respon_list)) return replygcxlicon(`Item list by Name *${q}* not in the database!`)
delResponList(m.chat, q, db_respon_list)
replygcxlicon(`Successfully delete list message with key *${q}*`)
break
      
      
      
case 'store':
case 'shop': 
case 'list': {
let teks = 'â”Œâ”€â”€â­“ã€Œ *LIST STORE* ã€\nâ”‚\n'
for (let x of db_respon_list) {
teks += `â”‚â­” ${x.key}\n`
}
teks += `â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â­“\n\n`
replygcxlicon(teks)
}
break
      
      
			case 'setprefix':
                if (!XliconTheCreator) return XliconStickOwner()
                if (!text) return replygcxlicon(`Example : ${prefix + command} #`)
                global.xprefix = text
                replygcxlicon(`Prefix successfully changed to ${text}`)
                break
      
      
      
			case 'addmsg': {
	if (!XliconTheCreator) return XliconStickOwner()
                if (!m.quoted) return replygcxlicon('Reply Message You Want To Save In Database')
                if (!text) return replygcxlicon(`Example : ${prefix + command} filename`)
                let msgs = global.db.database
                if (text.toLowerCase() in msgs) return replygcxlicon(`'${text}' registered in the message list`)
                msgs[text.toLowerCase()] = quoted.fakeObj
replygcxlicon(`Successfully added message in message list as '${text}'
    
Access with ${prefix}getmsg ${text}

View list of Messages With ${prefix}listmsg`)
            }
            break
      
      
      
            case 'getmsg': {
                if (!text) return replygcxlicon(`Example : ${prefix + command} file name\n\nView list of messages with ${prefix}listmsg`)
                let msgs = global.db.database
                if (!(text.toLowerCase() in msgs)) return replygcxlicon(`'${text}' not listed in the message list`)
                XliconBotInc.copyNForward(m.chat, msgs[text.toLowerCase()], true)
            }
            break
      
      
      
            case 'listmsg': {
                let msgs = JSON.parse(fs.readFileSync('./database/database.json'))
	        let seplit = Object.entries(global.db.database).map(([nama, isi]) => { return { nama, ...isi } })
		let teks = ' DATABASE LIST \n\n'
		for (let i of seplit) {
		    teks += `${themeemoji} *Name :* ${i.nama}\n${themeemoji} *Type :* ${getContentType(i.message).replace(/Message/i, '')}\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n`
	        }
	        replygcxlicon(teks)
	    }
	    break 
      
      
      
	case 'delmsg': case 'deletemsg': {
		if (!XliconTheCreator) return XliconStickOwner()
	        let msgs = global.db.database
	        if (!(text.toLowerCase() in msgs)) return replygcxlicon(`'${text}' not listed in the message list`)
		delete msgs[text.toLowerCase()]
		replygcxlicon(`Successfully deleted '${text}' from the message list`)
            }
	    break
      
      
      
			case 'setcmd': {
                if (!m.quoted) return replygcxlicon('Reply Message!')
                if (!m.quoted.fileSha256) return replygcxlicon('SHA256 Hash Missing')
                if (!text) return replygcxlicon(`For What Command?`)
                let hash = m.quoted.fileSha256.toString('base64')
                if (global.db.sticker[hash] && global.db.sticker[hash].locked) return replygcxlicon('You have no permission to change this sticker command')
                global.db.sticker[hash] = {
                    text,
                    mentionedJid: m.mentionedJid,
                    creator: m.sender,
                    at: + new Date,
                    locked: false,
                }
                replygcxlicon(`Done!`)
            }
            break
      
      
      
            case 'delcmd': {
                let hash = m.quoted.fileSha256.toString('base64')
                if (!hash) return replygcxlicon(`No hashes`)
                if (global.db.sticker[hash] && global.db.sticker[hash].locked) return replygcxlicon('You have no permission to delete this sticker command')             
                delete global.db.sticker[hash]
                replygcxlicon(`Done!`)
            }
            break
      
      
case 'listcmd': {
                let teks = `
*List Hash*
Info: *bold* hash is Locked
${Object.entries(global.db.sticker).map(([key, value], index) => `${index + 1}. ${value.locked ? `*${key}*` : key} : ${value.text}`).join('\n')}
`.trim()
                XliconBotInc.sendText(m.chat, teks, m, { mentions: Object.values(global.db.sticker).map(x => x.mentionedJid).reduce((a,b) => [...a, ...b], []) })
            }
            break 
      
      
case 'lockcmd': {
                if (!XliconTheCreator) return XliconStickOwner()
                if (!m.quoted) return replygcxlicon('Reply Message!')
                if (!m.quoted.fileSha256) return replygcxlicon('SHA256 Hash Missing')
                let hash = m.quoted.fileSha256.toString('base64')
                if (!(hash in global.db.sticker)) return replygcxlicon('Hash not found in database')
                global.db.sticker[hash].locked = !/^un/i.test(command)
                replygcxlicon('Done!')
            }
            break
      
  
 // HENTAII CMDS AHHH       
			case 'hentaivid': case 'hentai': case 'hentaivideo': {
    if (!m.isGroup) return XliconStickGroup();
    if (!AntiNsfw) return replygcxlicon(mess.nsfw);

    await XliconStickWait();
    const { hentai } = require('./lib/scraper.js');
    anu = await hentai();
    result912 = anu[Math.floor(Math.random() * anu.length)];

    // Prepare message details for video
    const videoDetails = `*Title:* ${result912.title}\n` +
                         `*Category:* ${result912.category}\n` +
                         `*Mimetype:* ${result912.type}\n` +
                         `*Views:* ${result912.views_count}\n` +
                         `*Shares:* ${result912.share_count}\n` +
                         `*Source:* ${result912.link}\n` +
                         `*Video Link:* ${result912.video_1}`;

    // Send video and details
    await XliconBotInc.sendMessage(m.chat, {
        video: { url: result912.video_1 },
        caption: videoDetails
    }, { quoted: m });
}
break;
        
case 'trap': {
    if (!m.isGroup) return XliconStickGroup();
    if (!AntiNsfw) return replygcxlicon(mess.nsfw);

    await XliconStickWait();
    try {
        // Fetch the trap image from the API
        const waifudd = await axios.get(`https://waifu.pics/api/nsfw/${command}`);

        // Prepare the message details
        const imageDetails = `Hi ${m.pushName}\n_*Here is the result of ${command}*_`;

        // Send the image with the details
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
            caption: imageDetails
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching trap image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;
        
case 'hentai-neko':
case 'hneko': {
    if (!m.isGroup) return XliconStickGroup();
    if (!AntiNsfw) return replygcxlicon(mess.nsfw);

    try {
        // Fetch the neko image from the API
        const waifudd = await axios.get(`https://waifu.pics/api/nsfw/neko`);

        // Prepare the caption text
        const imageDetails = `Hi ${m.pushName}\n_*Here is the result of ${command}*_`;

        // Send the image with the caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
            caption: imageDetails
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching hentai neko image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;
        
        
case 'hentai-waifu':
case 'nwaifu': {
    if (!m.isGroup) return XliconStickGroup();
    if (!AntiNsfw) return replygcxlicon(mess.nsfw);

    try {
        // Fetch the waifu image from the API
        const waifudd = await axios.get(`https://waifu.pics/api/nsfw/waifu`);

        // Prepare the caption text
        const imageDetails = `Hi ${m.pushName}\n_*Here is the result of ${command}*_`;

        // Send the image with the caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
            caption: imageDetails
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching hentai waifu image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;
        
case 'gasm': {
    if (!m.isGroup) return XliconStickGroup();
    if (!AntiNsfw) return replygcxlicon(mess.nsfw);

    await XliconStickWait();

    try {
        // Fetch image from the nekos.life API
        waifudd = await axios.get(`https://nekos.life/api/v2/img/${command}`);

        // Send the image with caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
            caption: `Hi ${m.pushName}\n_*Here is the result of ${command}*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching Gasm image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'milf': {
    if (!m.isGroup) return XliconStickGroup();

    await XliconStickWait();

    try {
        // Load Milf images from file
        var ahegaonsfw = JSON.parse(fs.readFileSync('./src/media/nsfw/milf.json'));

        // Pick a random result
        var xliconyresult = pickRandom(ahegaonsfw);

        // Send the image with caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: xliconyresult.url },
            caption: `Hi ${m.pushName}\n_*Here is the result of ${command}*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching Milf image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animespank': {
    if (!m.isGroup) return XliconStickGroup();
    if (!AntiNsfw) return replygcxlicon(mess.nsfw);

    await XliconStickWait();

    try {
        // Fetch image from the nekos.life API
        waifudd = await axios.get(`https://nekos.life/api/v2/img/spank`);

        // Send the image with caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
            caption: `Hi ${m.pushName}\n_*Here is the result of ${command}*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching AnimeSpank image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'blowjob': {
    if (!m.isGroup) return XliconStickGroup();
    if (!AntiNsfw) return replygcxlicon(mess.nsfw);

    await XliconStickWait();

    try {
        // Load Blowjob images from file
        var ahegaonsfw = JSON.parse(fs.readFileSync('./src/media/nsfw/blowjob.json'));

        // Pick a random result
        var xliconyresult = pickRandom(ahegaonsfw);

        // Send the image with caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: xliconyresult.url },
            caption: `Hi ${m.pushName}\n_*Here is the result of ${command}*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching Blowjob image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'cuckold': {
    if (!m.isGroup) return XliconStickGroup();
    if (!AntiNsfw) return replygcxlicon(mess.nsfw);

    await XliconStickWait();

    try {
        // Load Cuckold images from file
        var ahegaonsfw = JSON.parse(fs.readFileSync('./src/media/nsfw/cuckold.json'));

        // Pick a random result
        var xliconyresult = pickRandom(ahegaonsfw);

        // Send the image with caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: xliconyresult.url },
            caption: `Hi ${m.pushName}\n_*Here is the result of ${command}*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching Cuckold image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

        
case 'eba': {
    if (!m.isGroup) return XliconStickGroup();
    if (!AntiNsfw) return replygcxlicon(mess.nsfw);

    await XliconStickWait();

    try {
        // Load Eba NSFW images from file
        var ahegaonsfw = JSON.parse(fs.readFileSync('./src/media/nsfw/eba.json'));

        // Pick a random result
        var xliconyresult = pickRandom(ahegaonsfw);

        // Send the image with caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: xliconyresult.url },
            caption: `Hi ${m.pushName}\n_*Here is the result of ${command}*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching Eba image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'pussy': {
    if (!m.isGroup) return XliconStickGroup();
    if (!AntiNsfw) return replygcxlicon(mess.nsfw);

    await XliconStickWait();

    try {
        // Load Pussy NSFW images from file
        var ahegaonsfw = JSON.parse(fs.readFileSync('./src/media/nsfw/pussy.json'));

        // Pick a random result
        var xliconyresult = pickRandom(ahegaonsfw);

        // Send the image with caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: xliconyresult.url },
            caption: `Hi ${m.pushName}\n_*Here is the result of ${command}*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching Pussy image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'yuri': {
    if (!m.isGroup) return XliconStickGroup();
    if (!AntiNsfw) return replygcxlicon(mess.nsfw);

    await XliconStickWait();

    try {
        // Load Yuri NSFW images from file
        var ahegaonsfw = JSON.parse(fs.readFileSync('./src/media/nsfw/yuri.json'));

        // Pick a random result
        var xliconyresult = pickRandom(ahegaonsfw);

        // Send the image with caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: xliconyresult.url },
            caption: `Hi ${m.pushName}\n_*Here is the result of ${command}*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching Yuri image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

        
case 'zettai': {
    if (!m.isGroup) return XliconStickGroup();
    if (!AntiNsfw) return replygcxlicon(mess.nsfw);

    await XliconStickWait();

    try {
        // Load Zettai NSFW images from file
        var ahegaonsfw = JSON.parse(fs.readFileSync('./src/media/nsfw/zettai.json'));

        // Pick a random result
        var xliconyresult = pickRandom(ahegaonsfw);

        // Prepare the message with the image
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: xliconyresult.url },
            caption: `Hi ${m.pushName}\n_*Here is the result of ${command}*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching Zettai image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;
        
case 'gifblowjob': {
    if (!m.isGroup) return XliconStickGroup();
    if (!AntiNsfw) return replygcxlicon(mess.nsfw);

    await XliconStickWait();

    try {
        // Fetch the blowjob gif from the API
        let assss = await axios.get("https://api.waifu.pics/nsfw/blowjob");

        // Download the gif and prepare the buffer
        var bobuff = await fetchBuffer(assss.data.url);
        var bogif = await buffergif(bobuff);

        // Send the gif with the caption
        await XliconBotInc.sendMessage(m.chat, {
            video: { url: bogif },
            caption: `Hi ${m.pushName}\n_*Here is the result of ${command}*_`,
            gifPlayback: true
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching blowjob gif:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the gif. Please try again later.');
    }
}
break;

//END HENTAII CMDS AHHHH
        
    case 'animeawoo': {
    await XliconStickWait();

    try {
        // Fetch Awoo image from the waifu.pics API
        waifudd = await axios.get(`https://waifu.pics/api/sfw/awoo`);

        // Send the image with a caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching AnimeAwoo image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

        
case 'animemegumin': {
    await XliconStickWait();
    try {
        // Fetch Megumin image
        waifudd = await axios.get(`https://waifu.pics/api/sfw/megumin`);

        // Send the image with a caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching AnimeMegumin image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animeshinobu': {
    await XliconStickWait();
    try {
        // Fetch Shinobu image
        waifudd = await axios.get(`https://waifu.pics/api/sfw/shinobu`);

        // Send the image with a caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching AnimeShinobu image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animehandhold': {
    await XliconStickWait();
    try {
        // Fetch Handhold image
        waifudd = await axios.get(`https://waifu.pics/api/sfw/handhold`);

        // Send the image with a caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching AnimeHandhold image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animehighfive': {
    await XliconStickWait();
    try {
        // Fetch Highfive image
        waifudd = await axios.get(`https://waifu.pics/api/sfw/highfive`);

        // Send the image with a caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
            caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching AnimeHighfive image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

        
case 'animedance': {
    await XliconStickWait();
    try {
        // Fetch Dance image
        waifudd = await axios.get(`https://waifu.pics/api/sfw/dance`);

        // Send the image with a caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching AnimeDance image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animehappy': {
    await XliconStickWait();
    try {
        // Fetch Happy image
        waifudd = await axios.get(`https://waifu.pics/api/sfw/happy`);

        // Send the image with a caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
            caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching AnimeHappy image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animeglomp': {
    await XliconStickWait();
    try {
        // Fetch Glomp image
        waifudd = await axios.get(`https://waifu.pics/api/sfw/glomp`);

        // Send the image with a caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching AnimeGlomp image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animesmug': {
    await XliconStickWait();
    try {
        // Fetch Smug image
        waifudd = await axios.get(`https://waifu.pics/api/sfw/smug`);

        // Send the image with a caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
            caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching AnimeSmug image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animeblush': {
    await XliconStickWait();
    try {
        // Fetch Blush image
        waifudd = await axios.get(`https://waifu.pics/api/sfw/blush`);

        // Send the image with a caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
            caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching AnimeBlush image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animewave': {
    await XliconStickWait();
    try {
        // Fetch Wave image
        waifudd = await axios.get(`https://waifu.pics/api/sfw/wave`);

        // Send the image with a caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
          caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching AnimeWave image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;
        
case 'animesmile': {
    await XliconStickWait();
    try {
        // Fetch Smile image
        waifudd = await axios.get(`https://waifu.pics/api/sfw/smile`);

        // Send the image with a caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching AnimeSmile image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;
        
case 'animepoke': {
    await XliconStickWait();
    try {
        // Fetch Poke image
        waifudd = await axios.get(`https://waifu.pics/api/sfw/poke`);

        // Send the image with a caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
            caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching AnimePoke image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animewink': {
    await XliconStickWait();
    try {
        // Fetch Wink image
        waifudd = await axios.get(`https://waifu.pics/api/sfw/wink`);

        // Send the image with a caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching AnimeWink image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animebonk': {
    await XliconStickWait();
    try {
        // Fetch Bonk image
        waifudd = await axios.get(`https://waifu.pics/api/sfw/bonk`);

        // Send the image with a caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
            caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching AnimeBonk image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animebully': {
    await XliconStickWait();
    try {
        // Fetch Bully image
        waifudd = await axios.get(`https://waifu.pics/api/sfw/bully`);

        // Send the image with a caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
            caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });

    } catch (error) {
        console.error('Error fetching AnimeBully image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;
        
case 'animeyeet': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://waifu.pics/api/sfw/yeet`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching AnimeYeet image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animebite': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://waifu.pics/api/sfw/bite`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
            caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching AnimeBite image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animelick': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://waifu.pics/api/sfw/lick`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching AnimeLick image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animekill': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://waifu.pics/api/sfw/kill`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching AnimeKill image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animecry': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://waifu.pics/api/sfw/cry`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching AnimeCry image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;
        
case 'animewlp': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://nekos.life/api/v2/img/wallpaper`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching AnimeWLP image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animekiss': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://nekos.life/api/v2/img/kiss`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching AnimeKiss image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animehug': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://nekos.life/api/v2/img/hug`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching AnimeHug image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animeneko': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://waifu.pics/api/sfw/neko`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching AnimeNeko image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animepat': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://nekos.life/api/v2/img/pat`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching AnimePat image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;
        
case 'animeslap': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://nekos.life/api/v2/img/slap`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching AnimeSlap image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animecuddle': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://nekos.life/api/v2/img/cuddle`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching AnimeCuddle image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

//ANIME GIRLS PICS        
case 'animewaifu': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://nekos.life/api/v2/img/waifu`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching AnimeWaifu image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animenom': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://nekos.life/api/v2/img/nom`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching AnimeNom image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animefoxgirl': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://nekos.life/api/v2/img/fox_girl`);
        await XliconBotInc.sendMessage(m.chat, {
            
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching AnimeFoxGirl image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animetickle': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://nekos.life/api/v2/img/tickle`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
            caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching AnimeTickle image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animegecg': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://nekos.life/api/v2/img/gecg`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching AnimeGecg image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;
//ANIME CMDS END        
 
        
//IMAGES CMDS        
case 'dogwoof': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://nekos.life/api/v2/img/woof`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
            caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching DogWoof image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case '8ballpool': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://nekos.life/api/v2/img/8ball`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
            caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching 8BallPool image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'goosebird': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://nekos.life/api/v2/img/goose`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
            caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching GooseBird image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animefeed': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://nekos.life/api/v2/img/feed`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
            caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching AnimeFeed image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'animeavatar': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://nekos.life/api/v2/img/avatar`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
            caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching AnimeAvatar image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'lizardpic': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://nekos.life/api/v2/img/lizard`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
            caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching LizardPic image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

case 'catmeow': {
    await XliconStickWait();
    try {
        let waifudd = await axios.get(`https://nekos.life/api/v2/img/meow`);
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: waifudd.data.url },
           caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of ${command} ğŸ“œâœ¨*_`
        }, { quoted: m });
    } catch (error) {
        console.error('Error fetching CatMeow image:', error);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later.');
    }
}
break;

//MEW ANIME CMDS
//----------------------------------------------------------------------------------------------//


case 'bilibili': {
  if (!isPremium) return replyprem(mess.premium);
  if (!text) return replygcxlicon(`Example : ${prefix + command} https://www.bilibili.com/video/BV1cy4y1k7A2`);
  await XliconStickWait();
  try {
    // Fetch video information from the Bilibili API
    const response = await axios.get(`https://api.nexoracle.com/downloader/bilibili?apikey=free_key@maher_apis&url=${encodeURIComponent(text)}`);

    if (response.status !== 200 || !response.data.result || !response.data.result.medias || response.data.result.medias.length === 0) {
      return replygcxlicon('âŒ No video found. Please check the URL and try again.');
    }

    const video = response.data.result.medias.find(media => media.videoAvailable) || response.data.result.medias[0];
    const videoUrl = video.url;

    // Prepare message with video details
    const caption = `ğŸ“¹ *Bilibili Video Downloaded*\n\nğŸ“‚ Title: ${response.data.result.title}\nğŸ“… Duration: ${response.data.result.duration}\nğŸ‘¤ Uploader: ${response.data.result.uploader}`;

    // Send video message
    await XliconBotInc.sendMessage(m.chat, {
      video: { url: videoUrl },
      caption: caption
    }, { quoted: m });

  } catch (error) {
    console.error('Failed to fetch video:', error);
    replygcxlicon('âŒ An error occurred while fetching the video. Please try again later.');
  }
}
break;





case 'dailymotion': {
  if (!isPremium) return replyprem(mess.premium);
  if (!text) return replygcxlicon(`Example : ${prefix + command} https://dai.ly/x9492ja`);
  await XliconStickWait();
  try {
    // Ensure global.api is an absolute URL
    const apiUrl = new URL(`${global.api}downloader/dailymotion?apikey=${global.id}&url=${encodeURIComponent(text)}`);

    // Fetch video information from Dailymotion API
    const response = await fetch(apiUrl.toString());
    const json = await response.json();

    // Check if the response contains video data
    if (!json || !json.result || json.result.length === 0) {
      return replygcxlicon('âŒ Failed to fetch video. Please try again.');
    }

    // Access the first result
    const videoInfo = json.result[0];

    // Choose the best quality video available from formats
    const bestQualityVideo = videoInfo.formats.find(format => format.format_id === 'hls-1080') || 
                             videoInfo.formats.find(format => format.format_id === 'hls-720') || 
                             videoInfo.formats[videoInfo.formats.length - 1]; // fallback to the lowest

    const videoUrl = bestQualityVideo.url;

    // Send a reaction to indicate the start of the download
    await XliconBotInc.sendMessage(m.chat, { react: { text: "â±ï¸", key: m.key } });

    // Send the video
    await XliconBotInc.sendMessage(m.chat, {
      video: { url: videoUrl },
      caption: `ğŸ“¹ *Dailymotion Video Downloaded*\n\nğŸ“‚ Title: ${videoInfo.title}\nğŸ“… Duration: ${videoInfo.duration_string}\nğŸŒ Source: ${videoInfo.source}`
    }, { quoted: m });

    // Send a reaction to indicate the download is complete
    await XliconBotInc.sendMessage(m.chat, { react: { text: "â˜‘ï¸", key: m.key } });

  } catch (err) {
    console.error(err);
    await XliconBotInc.sendMessage(m.chat, { react: { text: "âœ–ï¸", key: m.key } });
    replygcxlicon('âŒ An error occurred while fetching the video. Please try again later.');
  }
}
break;

case 'animeedit': case 'amv': {
  XliconStickWait(); // Indicate that the bot is processing the request

  try {
      // List of available API URLs
      const apiUrls = [
          'https://aemt.uk.to/download/storyanime',
          'https://meitang.xyz/download/storyanime',
          'https://btch.us.kg/download/storyanime',
          'https://api.tioo.eu.org/download/storyanime',
          'https://api.tioprm.eu.org/download/storyanime'
      ];

      // Select a random API URL
      const randomApiUrl = apiUrls[Math.floor(Math.random() * apiUrls.length)];

      // Fetch anime status video from the selected API
      const response = await axios.get(randomApiUrl, {
          headers: {
              accept: 'application/json' // Set the accept header to request JSON response
          }
      });
      console.log('API Response:', response.data); // Log the response for debugging

      // Check if the response is successful and contains the result
      if (!response.data.status || !response.data.result) {
          throw new Error('Failed to fetch anime status video.');
      }

      const { title, url } = response.data.result;

      // Prepare caption and send video
      const caption = `ğŸ¬ *Enjoy your Anime Edit!* âœ¨`;

      await XliconBotInc.sendMessage(m.chat, {
          video: { url: url },
          caption: caption,
          mimetype: 'video/mp4', // Specify the MIME type
      }, { quoted: m });
  } catch (error) {
      console.error('Error in storyanime command:', error.message); // Log specific error message
      replygcxlicon('âš ï¸ An error occurred while fetching the anime status video.');
  }
}
break;
              
                
                
case 'animeinfo': {
  if (!text) return replygcxlicon(`Which anime are you looking for?`);

  const fetchAnimeInfo = async (animeName) => {
    const api = `https://abra.abrahamdw882.workers.dev/search/${encodeURIComponent(animeName)}`;

    try {
      const response = await axios.get(api);
      if (response.status !== 200 || !response.data.results || response.data.results.length === 0) {
        console.error('No results found in API response');
        return null;
      }
      return response.data.results;
    } catch (error) {
      console.error('Error fetching anime info:', error);
      return null;
    }
  };

  await XliconStickWait();
  const animeName = text.trim();
  const results = await fetchAnimeInfo(animeName);

  if (!results) {
    return replygcxlicon('âŒ Failed to fetch anime information. Please try again.');
  }

  let animetxt = `Anime Information for *"${animeName}"*:\n\n`;
  results.forEach(anime => {
    animetxt += `ğŸ€ *Title:* ${anime.title}\nğŸ‹ *Release Date:* ${anime.releaseDate}\nğŸ†” *ID:* ${anime.id}\nğŸŒ *Link:* ${anime.link}\nğŸ–¼ï¸ *Image:* ${anime.img}\n\n`;
  });

  await XliconBotInc.sendMessage(m.chat, {
    text: `Hi ${m.pushName}\n_*Here is the result of ${animeName}*_\n\n${animetxt}`,
    image: { url: results[0].img },
    quoted: m
  });

}
break;
               

case 'sendanimeid': {
  if (!text) return replygcxlicon(`Please provide the anime name to fetch IDs.`);

  const fetchAnimeIds = async (animeName) => {
    const api = `https://abra.abrahamdw882.workers.dev/search/${encodeURIComponent(animeName)}`;

    try {
      const response = await fetch(api);
      if (!response.ok) {
        console.error(`API response not OK: ${response.status} ${response.statusText}`);
        throw new Error('API response not OK');
      }
      const json = await response.json();
      if (json.results && json.results.length > 0) {
        return json.results.map(anime => ({ id: anime.id, title: anime.title })); // Return list of anime IDs and titles
      } else {
        console.error('No results found in API response');
      }
    } catch (error) {
      console.error(`Error fetching from ${api}:`, error);
    }
    return null; // Return null if no results found
  };

  await XliconStickWait();
  const animeName = text.trim();
  const animeData = await fetchAnimeIds(animeName);

  if (!animeData) {
    return replygcxlicon('âŒ Failed to fetch anime IDs. Please try again.');
  }

  if (animeData.length === 0) {
    return replygcxlicon(`No anime IDs found for "${animeName}".`);
  }

  // Generate detailed text with title first, then ID
  let idText = `ğŸŒ *Anime IDs for "${animeName}"* ğŸŒ\n\n`;
  animeData.forEach((anime, index) => {
    idText += `ğŸ¥ *Title:* ${anime.title}\nğŸ†” *ID:* ${anime.id}\n\n`;
  });

  // Send the detailed ID and title list
  await XliconBotInc.sendMessage(m.chat, { text: idText });
}
break;

case 'animedl': {
  if (!isPremium) return replyprem(mess.premium);
  if (!text) return replygcxlicon(`Example: ${prefix + command} one-piece,1`);

  await XliconStickWait();

  try {
      const [animeId, episode] = text.split(',');
      if (!animeId || !episode) {
          return replygcxlicon('Invalid format. Please use: .animedl <anime-id>,<episode-number>');
      }

      const formattedText = `${animeId.trim()}-episode-${episode.trim()}`;
      const apiUrls = [
          `https://api2.abrahamdw882.workers.dev/download/${formattedText}`,
          `https://abra.abrahamdw882.workers.dev/download/${formattedText}`,
          `https://api1.toontamilindia.workers.dev/download/${formattedText}`
      ];

      let videoUrl = '';
      for (let apiUrl of apiUrls) {
          try {
              const response = await axios.get(apiUrl);
              if (response.status === 200) {
                  const json = response.data;
                  const keys = Object.keys(json.results);
                  if (keys.length >= 2) {
                      videoUrl = json.results[keys[1]]; // First fallback to the second result
                  }
                  if (!videoUrl && keys.length >= 1) {
                      videoUrl = json.results[keys[0]]; // Fallback to the first result if second isn't available
                  }
                  if (videoUrl) break;
              }
          } catch (error) {
              console.warn(`Failed to fetch from ${apiUrl}:`, error);
          }
      }

      if (!videoUrl) {
          return replygcxlicon('âŒ No video link found. Please check the ID and episode number, and try again.');
      }

      // Prepare video details message
      const animeName = animeId.replace(/-/g, ' ');
      const caption = `ğŸ“¹ *Anime Video Downloaded*\n\nğŸŒ *Anime Website:* _Gogoanime_\nğŸ“‚ *Anime Name:* _${animeName}_\nğŸ“… *Episode No:* _${episode.trim()}_\nğŸ†” *Episode Id:* _${formattedText}_\nğŸŒ *Resolution:* _Auto_\nğŸ“œ *Subtitles Language:* _English_\nğŸ’» *Server:* _Kali Linux_\nğŸ“… *Download Date:* _${new Date().toLocaleDateString()}_\nâ° *Download Time:* _${new Date().toLocaleTimeString()}_\nğŸ“¥ *Downloaded By:* _XLICON-V4_\nğŸ‘¤ *Feature By:* _Salman Ahmad_`;

      // Send video and details
      await XliconBotInc.sendMessage(m.chat, {
          video: { url: videoUrl },
          caption: caption
      }, { quoted: m });

      await XliconBotInc.sendMessage(m.chat, { react: { text: "â˜‘ï¸", key: m.key } });

  } catch (error) {
      console.error('Error fetching video:', error);
      await XliconBotInc.sendMessage(m.chat, { react: { text: "âœ–ï¸", key: m.key } });
      replygcxlicon('âŒ An error occurred while fetching the video. Please try again later.');
  }
}
break;
              
                
 //Manga Cmds               

case 'mangainfo': {
  const mangaTitle = text.trim();
  if (!mangaTitle) {
    return replygcxlicon('âŒ Provide a manga title, e.g., mangainfo One Piece');
  }

  try {
    const mangaSearchUrl = `https://api.mangadex.org/manga?title=${encodeURIComponent(mangaTitle)}&limit=1&availableTranslatedLanguage[]=en`;
    const searchResponse = await axios.get(mangaSearchUrl);

    if (!searchResponse.data || !searchResponse.data.data || searchResponse.data.data.length === 0) {
      return replygcxlicon(`âŒ No English manga found with the title "${mangaTitle}".`);
    }

    const manga = searchResponse.data.data[0];
    const { title, description, status, tags } = manga.attributes;

    const genres = tags
      .map((tag) => tag.attributes.name.en)
      .join(', ') || 'Unknown';

    const replyText = `
*ğŸ“– Manga Info:*
ğŸ“š *Title:* ${title.en || 'No title available'}
ğŸ“œ *Description:* ${description.en || 'No description available'}
ğŸ”– *Status:* ${status || 'Unknown'}
ğŸ­ *Genres:* ${genres}
`;

    return replygcxlicon(replyText);
  } catch (error) {
    console.error('Error fetching manga info:', error.message);
    return replygcxlicon(`âŒ Error fetching manga info: ${error.message}`);
  }
}
break;

case 'searchchapter': {
  const mangaTitle = text.trim();
  if (!mangaTitle) {
    return replygcxlicon('âŒ Provide a manga title, e.g., searchchapter One Piece');
  }

  try {
    const mangaSearchUrl = `https://api.mangadex.org/manga?title=${encodeURIComponent(mangaTitle)}&limit=1&availableTranslatedLanguage[]=en`;
    const searchResponse = await axios.get(mangaSearchUrl);

    if (!searchResponse.data || !searchResponse.data.data || searchResponse.data.data.length === 0) {
      return replygcxlicon(`âŒ No English manga found with the title "${mangaTitle}".`);
    }

    const mangaId = searchResponse.data.data[0].id;
    const chaptersUrl = `https://api.mangadex.org/chapter?manga=${mangaId}&translatedLanguage[]=en&limit=10`;
    const chaptersResponse = await axios.get(chaptersUrl);

    if (!chaptersResponse.data || chaptersResponse.data.data.length === 0) {
      return replygcxlicon(`âŒ No chapters found for "${mangaTitle}".`);
    }

    const chaptersList = chaptersResponse.data.data
      .map(
        (chapter) =>
          `ğŸ“˜ Chapter ${chapter.attributes.chapter}: ${chapter.attributes.title || "Untitled"}`
      )
      .join('\n');

    const replyText = `*ğŸ“š Available Chapters for "${mangaTitle}":*\n${chaptersList}`;
    return replygcxlicon(replyText);
  } catch (error) {
    console.error('Error fetching chapters:', error.message);
    return replygcxlicon(`âŒ Error fetching chapters: ${error.message}`);
  }
}
break;


case 'mangachapter': {
  const input = text.trim();
  if (!input) {
    return replygcxlicon('âŒ Please provide a manga title and chapter, e.g., One Piece chapter 1120.');
  }

  const match = input.match(/(.+?)\s+chapter\s+(\d+)/i);
  if (!match) {
    return replygcxlicon('âŒ Invalid format. Use: <title> chapter <number>');
  }

  const mangaTitle = match[1].trim();
  const chapterNumber = match[2];
  const baseUrl = 'https://api.mangadex.org';

  try {
    // Search for manga
    const searchResponse = await axios.get(`${baseUrl}/manga`, {
      params: { title: mangaTitle, limit: 1, availableTranslatedLanguage: ['en'] },
    });

    if (searchResponse.data.data.length === 0) {
      return replygcxlicon(`âŒ No manga found with the title "${mangaTitle}".`);
    }

    const mangaId = searchResponse.data.data[0].id;

    // Get the chapter
    const chapterResponse = await axios.get(`${baseUrl}/chapter`, {
      params: { manga: mangaId, chapter: chapterNumber, translatedLanguage: ['en'] },
    });

    if (chapterResponse.data.data.length === 0) {
      return replygcxlicon(`âŒ No chapter ${chapterNumber} found for "${mangaTitle}".`);
    }

    const chapterId = chapterResponse.data.data[0].id;
    const serverResponse = await axios.get(`${baseUrl}/at-home/server/${chapterId}`);
    const { baseUrl: chapterBaseUrl, chapter } = serverResponse.data;

    const imageUrls = chapter.data.map(
      (fileName) => `${chapterBaseUrl}/data/${chapter.hash}/${fileName}`
    );

    if (imageUrls.length === 0) {
      return replygcxlicon(`âŒ No images found for chapter ${chapterNumber} of "${mangaTitle}".`);
    }

    const pdfPath = `/tmp/manga_${mangaTitle}_chapter_${chapterNumber}.pdf`;
    const pdfDoc = new PDFDocument();
    const writeStream = fs.createWriteStream(pdfPath);

    pdfDoc.pipe(writeStream);

    for (const imgUrl of imageUrls) {
      const imageBuffer = (await axios.get(imgUrl, { responseType: 'arraybuffer' })).data;
      pdfDoc.addPage().image(imageBuffer, { fit: [500, 700], align: 'center', valign: 'center' });
    }

    pdfDoc.end();

    writeStream.on('finish', async () => {
      await XliconBotInc.sendMessage(m.chat, {
        document: { url: pdfPath },
        fileName: `Manga_${mangaTitle}_Chapter_${chapterNumber}.pdf`,
        mimetype: 'application/pdf',
      }, { quoted: m });

      fs.unlinkSync(pdfPath);
    });
  } catch (error) {
    console.error('Error fetching manga chapter:', error.message);
    return replygcxlicon('âŒ An error occurred while fetching the chapter. Please try again later.');
  }
}
break;


case 'randommanga': {
  try {
    const offset = Math.floor(Math.random() * 1000);
    const randomUrl = `https://api.mangadex.org/manga?limit=1&offset=${offset}&availableTranslatedLanguage[]=en`;
    const response = await axios.get(randomUrl);

    if (!response.data || !response.data.data || response.data.data.length === 0) {
      return replygcxlicon('âŒ Could not fetch a random manga. Please try again.');
    }

    const manga = response.data.data[0];
    const { title, description, status, tags } = manga.attributes;

    const genres = tags.map(tag => tag.attributes.name.en).join(", ") || "N/A";
    const mangaDetails = `
*ğŸ“– Random Manga Suggestion:*
â­ *Title:* ${title.en || "N/A"}
ğŸ“ *Description:* ${description?.en || "No description available"}
ğŸ“š *Status:* ${status || "Unknown"}
ğŸ­ *Genres:* ${genres}
    `;

    return replygcxlicon(mangaDetails);
  } catch (error) {
    console.error('Error fetching random manga:', error.message);
    return replygcxlicon(`âŒ Error fetching random manga: ${error.message}`);
  }
}
break;

                
case 'mangaimg': {
  if (!text) return replygcxlicon(`*â€¢ Example:* ${prefix + command} a manga character ğŸ–¼ï¸`);

  await XliconStickWait();

  try {
      // Fetch the manga image from the API
      let apiUrl = `${global.api}ai/manga-diffusion?apikey=${global.id}&prompt=${encodeURIComponent(text)}`;
      let response = await fetch(apiUrl);

      // Check if the response is okay
      if (!response.ok) {
          return replygcxlicon('âŒ Failed to fetch the image. Please try again.');
      }

      // Convert the response to a buffer
      const buffer = await response.buffer();

      // Prepare the message to send
      const caption = `> Manga Image ğŸ¨\n\n_*Here is the result of: ${text} ğŸŒŸ*_`;

      // Send the image and caption
      await XliconBotInc.sendMessage(m.chat, {
          image: { buffer },
          caption: caption
      }, { quoted: m });

      await XliconBotInc.sendMessage(m.chat, { react: { text: "â˜‘ï¸", key: m.key } });

  } catch (e) {
      console.error(e);
      await XliconBotInc.sendMessage(m.chat, { react: { text: "âœ–ï¸", key: m.key } });
      return replygcxlicon("â— Error fetching the image. Please try again.");
  }
}
break;

case 'animeimg': {
  if (!text) return replygcxlicon(`*â€¢ Example:* ${prefix + command} a cute anime girl ğŸ‘§âœ¨`);

  await XliconStickWait();

  try {
      // Fetch the anime image from the API
      let apiUrl = `${global.api}ai/anime-gen?apikey=${global.id}&prompt=${encodeURIComponent(text)}`;
      let response = await fetch(apiUrl);

      // Check if the response is okay
      if (!response.ok) {
          return replygcxlicon('âŒ Failed to fetch the image. Please try again.');
      }

      // Convert the response to a buffer
      const buffer = await response.buffer();

      // Prepare the caption for the image
      const caption = `> Anime Image ğŸ¥\n\n_*Here is the result of: ${text} ğŸŒŸ*_`;

      // Send the image and caption
      await XliconBotInc.sendMessage(m.chat, {
          image: { buffer },
          caption: caption
      }, { quoted: m });

      await XliconBotInc.sendMessage(m.chat, { react: { text: "â˜‘ï¸", key: m.key } });

  } catch (e) {
      console.error(e);
      await XliconBotInc.sendMessage(m.chat, { react: { text: "âœ–ï¸", key: m.key } });
      return replygcxlicon("â— Error fetching the image. Please try again.");
  }
}
break;
              
               
//--------------------------------------------------------------------------------------------//
//ANIME INFO AND WAIUS        
case 'searchanime': {
    if (!text) return replygcxlicon(`Which anime are you looking for?`);

    const malScraper = require('mal-scraper');
    await XliconStickWait();

    try {
        // Fetch anime info
        const anime = await malScraper.getInfoFromName(text).catch(() => null);
        if (!anime) return replygcxlicon(`Could not find any anime with the name "${text}"`);

        // Prepare anime info message
        let animetxt = `
ğŸ€ *Title:* ${anime.title}
ğŸ‹ *Type:* ${anime.type}
ğŸ *Premiered on:* ${anime.premiered}
ğŸ’  *Total Episodes:* ${anime.episodes}
ğŸ“ˆ *Status:* ${anime.status}
ğŸ’® *Genres:* ${anime.genres}
ğŸŒŸ *Score:* ${anime.score}
ğŸ’ *Rating:* ${anime.rating}
ğŸ… *Rank:* ${anime.ranked}
ğŸŒ *URL:* ${anime.url}
â„ *Description:* ${anime.synopsis}`;

        // Send the message with anime image and info
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: anime.picture },
            caption: `Hi ${m.pushName}\n_*Here is the result of ${text}*_\n\n${animetxt}`
        }, { quoted: m });

    } catch (e) {
        console.error(e);
        return replygcxlicon("â— Error fetching the anime. Please try again.");
    }
}
break;




case 'loli': {
    let baseUrl = 'https://weeb-api.vercel.app/';
    const response = await fetch(baseUrl + 'loli');  // Replace with 'loli' command
    const imageBuffer = await response.buffer();  // Get image buffer

    // Send the image with a simple message
    await XliconBotInc.sendMessage(m.chat, {
        image: imageBuffer,
        caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of loli ğŸ­*_`
    }, { quoted: m });
}
break;

case 'waifu': {
    let baseUrl = 'https://weeb-api.vercel.app/';
    const response = await fetch(baseUrl + 'waifu');  // Replace with 'waifu' command
    const imageBuffer = await response.buffer();  // Get image buffer

    // Send the image with a simple message
    await XliconBotInc.sendMessage(m.chat, {
        image: imageBuffer,
        caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of waifu ğŸ’–*_`
    }, { quoted: m });
}
break;

case 'neko': {
    let baseUrl = 'https://weeb-api.vercel.app/';
    const response = await fetch(baseUrl + 'neko');  // Replace with 'neko' command
    const imageBuffer = await response.buffer();  // Get image buffer

    // Send the image with a simple message
    await XliconBotInc.sendMessage(m.chat, {
        image: imageBuffer,
        caption: `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of neko ğŸ¾ğŸ±*_`
    }, { quoted: m });
}
break;

			case 'traceanime': {
    try {
        let q = m.quoted ? m.quoted : m;
        let mime = (q.msg || q).mimetype || q.mediaType || "";
        if (!mime.startsWith('image')) {
            return replygcxlicon("*Respond to an image*");
        }
        let data = await q.download();
        let image = await uploadImage(data);
        let apiUrl = `https://api.trace.moe/search?anilistInfo&url=${encodeURIComponent(image)}`;
        let response = await fetch(apiUrl);
        let result = await response.json();
        if (!result || result.error || result.result.length === 0) {
            return replygcxlicon("*Error: Could not track the anime.*");
        }
        let { anilist, from, to, similarity, video, episode } = result.result[0];
        let animeTitle = anilist.title ? anilist.title.romaji || anilist.title.native : "Unknown Title";
        let message = `*Anime:* ${animeTitle}\n`;
        if (anilist.synonyms && anilist.synonyms.length > 0) {
            message += `*Synonyms:* ${anilist.synonyms.join(", ")}\n`;
        }
        message += `*Similarity:* ${similarity.toFixed(2)}%\n`;
        message += `*Time:* ${formatDuration(from * 1000)} - ${formatDuration(to * 1000)}\n`;
        if (episode) {
            message += `*Episode:* ${episode}\n`;
        }

        // Send the video with anime information as the caption
        await XliconBotInc.sendMessage(m.chat, {
            video: { url: video },
            caption: message
        }, { quoted: m });
    } catch (error) {
        console.error("Error:", error);
        replygcxlicon("*Error: Could not track the anime or send the video.*");
    }
}
break;


//Stickers of anime and manga
			case 'shinobu':{
axios.get(`https://api.waifu.pics/sfw/shinobu`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickhandhold': {
axios.get(`https://api.waifu.pics/sfw/handhold`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickshinobu': {
axios.get(`https://api.waifu.pics/sfw/shinobu`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickhighfive': {
axios.get(`https://api.waifu.pics/sfw/highfive`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickcuddle': {
axios.get(`https://api.waifu.pics/sfw/cuddle`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickcringe': {
axios.get(`https://api.waifu.pics/sfw/cringe`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickdance': {
axios.get(`https://api.waifu.pics/sfw/dance`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickhappy': {
axios.get(`https://api.waifu.pics/sfw/happy`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickglomp': {
axios.get(`https://api.waifu.pics/sfw/glomp`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'sticksmug': {
axios.get(`https://api.waifu.pics/sfw/smug`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickblush': {
axios.get(`https://api.waifu.pics/sfw/blush`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickawoo': {
axios.get(`https://api.waifu.pics/sfw/awoo`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickwave': {
axios.get(`https://api.waifu.pics/sfw/wave`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'sticksmile': {
axios.get(`https://api.waifu.pics/sfw/smile`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
        
case 'stickslap': {
axios.get(`https://api.waifu.pics/sfw/slap`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'sticknom': {
axios.get(`https://api.waifu.pics/sfw/nom`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickpoke': {
axios.get(`https://api.waifu.pics/sfw/poke`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickwink': {
axios.get(`https://api.waifu.pics/sfw/wink`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickbonk': {
axios.get(`https://api.waifu.pics/sfw/bonk`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickbully': {
axios.get(`https://api.waifu.pics/sfw/bully`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickyeet': {
axios.get(`https://api.waifu.pics/sfw/yeet`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickbite': {
axios.get(`https://api.waifu.pics/sfw/bite`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickkiss': {
axios.get(`https://api.waifu.pics/sfw/kiss`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'sticklick': {
axios.get(`https://api.waifu.pics/sfw/lick`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickpat': {
axios.get(`https://api.waifu.pics/sfw/pat`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickhug': {
axios.get(`https://api.waifu.pics/sfw/hug`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickkill': {
axios.get(`https://api.waifu.pics/sfw/kill`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickcry': {
axios.get(`https://api.waifu.pics/sfw/cry`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'stickspank':{
                axios.get(`https://nekos.life/api/v2/img/spank`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break
        
case 'sticktickle':{
                axios.get(`https://nekos.life/api/v2/img/tickle`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break


case 'gura':
case 'gurastick':{
var ano = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/main/gura')
var wifegerak = ano.split('\n')
var wifegerakx = wifegerak[Math.floor(Math.random() * wifegerak.length)]
encmedia = await XliconBotInc.sendImageAsSticker(m.chat, wifegerakx, m, { packname: global.packname, author: global.author, })

}
break
        
 //Anime Stickers end here       
        
case 'telestick': {
	if (m.isGroup) return XliconStickPrivate()
		if (args[0] && args[0].match(/(https:\/\/t.me\/addstickers\/)/gi)) {
		let xliconresources = await Telesticker(args[0])
		await replygcxlicon(`Sending ${xliconresources.length} stickers...`)
		if (m.isGroup && xliconresources.length > 30) {
			await replygcxlicon('Number of stickers more than 30, bot will send it in private chat.')
			for (let i = 0; i < xliconresources.length; i++) {
				XliconBotInc.sendMessage(m.sender, { sticker: { url: xliconresources[i].url }})
			}
		} else {
			for (let i = 0; i < xliconresources.length; i++) {
				XliconBotInc.sendMessage(m.chat, { sticker: { url: xliconresources[i].url }})
			}
		}
	} else replygcxlicon(`Where is the telegram sticker link?\nExample. ${prefix + command} https://t.me/addstickers/FriendlyDeath`)
}
break
        
 


case 'sound1':
case 'sound2':
case 'sound3':
case 'sound4':
case 'sound5':
case 'sound6':
case 'sound7':
case 'sound8':
case 'sound9':
case 'sound10':
case 'sound11':
case 'sound12':
case 'sound13':
case 'sound14':
case 'sound15':
case 'sound16':
case 'sound17':
case 'sound18':
case 'sound19':
case 'sound20':
case 'sound21':
case 'sound22':
case 'sound23':
case 'sound24':
case 'sound25':
case 'sound26':
case 'sound27':
case 'sound28':
case 'sound29':
case 'sound30':
case 'sound31':
case 'sound32':
case 'sound33':
case 'sound34':
case 'sound35':
case 'sound36':
case 'sound37':
case 'sound38':
case 'sound39':
case 'sound40':
case 'sound41':
case 'sound42':
case 'sound43':
case 'sound44':
case 'sound45':
case 'sound46':
case 'sound47':
case 'sound48':
case 'sound49':
case 'sound50':
case 'sound51':
case 'sound52':
case 'sound53':
case 'sound54':
case 'sound55':
case 'sound56':
case 'sound57':
case 'sound58':
case 'sound59':
case 'sound60':
case 'sound61':
case 'sound62':
case 'sound63':
case 'sound64':
case 'sound65':
case 'sound66':
case 'sound67':
case 'sound68':
case 'sound69':
case 'sound70':
case 'sound71':
case 'sound72':
case 'sound73':
case 'sound74':
case 'sound75':
case 'sound76':
case 'sound77':
case 'sound78':
case 'sound79':
case 'sound80':
case 'sound81':
case 'sound82':
case 'sound83':
case 'sound84':
case 'sound85':
case 'sound86':
case 'sound87':
case 'sound88':
case 'sound89':
case 'sound90':
case 'sound91':
case 'sound92':
case 'sound93':
case 'sound94':
case 'sound95':
case 'sound96':
case 'sound97':
case 'sound98':
case 'sound99':
case 'sound100':
case 'sound101':
case 'sound102':
case 'sound103':
case 'sound104':
case 'sound105':
case 'sound106':
case 'sound107':
case 'sound108':
case 'sound109':
case 'sound110':
case 'sound111':
case 'sound112':
case 'sound113':
case 'sound114':
case 'sound115':
case 'sound116':
case 'sound117':
case 'sound118':
case 'sound119':
case 'sound120':
case 'sound121':
case 'sound122':
case 'sound123':
case 'sound124':
case 'sound125':
case 'sound126':
case 'sound127':
case 'sound128':
case 'sound129':
case 'sound130':
case 'sound131':
case 'sound132':
case 'sound133':
case 'sound134':
case 'sound135':
case 'sound136':
case 'sound137':
case 'sound138':
case 'sound139':
case 'sound140':
case 'sound141':
case 'sound142':
case 'sound143':
case 'sound144':
case 'sound145':
case 'sound146':
case 'sound147':
case 'sound148':
case 'sound149':
case 'sound150':
case 'sound151':
case 'sound152':
case 'sound153':
case 'sound154':
case 'sound155':
case 'sound156':
case 'sound157':
case 'sound158':
case 'sound159':
case 'sound160':
case 'sound161':
XliconBotInc_dev = await getBuffer(`https://github.com/salmanytofficial/Tiktokmusic-API/raw/master/tiktokmusic/${command}.mp3`)
await XliconBotInc.sendMessage(m.chat, { audio: XliconBotInc_dev, mimetype: 'audio/mp4', ptt: true }, { quoted: m })     
break
			
    
  case 'checkme': {
  const args = text.split(" ");
  const bet = `${sender}`;

  const sifat = ['ğŸ¤” Fine','ğŸ˜¡ Unfriendly','ğŸ‘ Chapri','ğŸ’” Nibba/nibbi','ğŸ˜¤ Annoying','ğŸ’€ Dilapidated','ğŸ˜¡ Angry person','ğŸ˜Š Polite','ğŸ™„ Burden','ğŸ’¯ Great','ğŸ¤® Cringe','ğŸ¤¥ Liar'];
  const hoby = ['ğŸ³ Cooking','ğŸ’ƒ Dancing','ğŸ® Playing','ğŸ® Gaming','ğŸ¨ Painting','ğŸ¤ Helping Others','ğŸ¿ Watching anime','ğŸ“š Reading','ğŸš´â€â™‚ï¸ Riding Bike','ğŸ¤ Singing','ğŸ’¬ Chatting','ğŸ˜‚ Sharing Memes','âœï¸ Drawing','ğŸ’¸ Eating Parents Money','ğŸ² Playing Truth or Dare','ğŸ¤« Staying Alone'];
  const bukcin = [...Array(100).keys()].map(i => String(i + 1));
  const arp = bukcin.slice();
  const cakep = ['âœ… Yes','âŒ No','ğŸ˜– Very Ugly','ğŸ˜ Very Handsome'];
  const wetak = ['ğŸ’– Caring','ğŸ’ Generous','ğŸ˜¡ Angry person','ğŸ˜” Sorry','ğŸ¤² Submissive','ğŸ˜Š Fine','ğŸ™‡â€â™‚ï¸ Im sorry','ğŸ§¡ Kind Hearted','ğŸ˜Œ Patient','ğŸ¥° UwU','ğŸ”¥ Top','ğŸ¤— Helpful'];
  const baikk = bukcin.slice();
  const bhuruk = bukcin.slice();
  const cerdhas = bukcin.slice();
  const berhani = bukcin.slice();
  const mengheikan = bukcin.slice();

  const sipat = sifat[Math.floor(Math.random() * sifat.length)];
  const biho = hoby[Math.floor(Math.random() * hoby.length)];
  const bhucin = bukcin[Math.floor(Math.random() * bukcin.length)];
  const senga = arp[Math.floor(Math.random() * arp.length)];
  const chakep = cakep[Math.floor(Math.random() * cakep.length)];
  const watak = wetak[Math.floor(Math.random() * wetak.length)];
  const baik = baikk[Math.floor(Math.random() * baikk.length)];
  const burug = bhuruk[Math.floor(Math.random() * bhuruk.length)];
  const cerdas = cerdhas[Math.floor(Math.random() * cerdhas.length)];
  const berani = berhani[Math.floor(Math.random() * berhani.length)];
  const takut = mengheikan[Math.floor(Math.random() * mengheikan.length)];

  const profile = `
*â‰¡â•ã€Šğ—–ğ—µğ—²ğ—°ğ—¸ ğ—½ğ—¿ğ—¼ğ—³ğ—¶ğ—¹ğ—² ğ—³ğ—¼ğ—¿ @${bet.split('@')[0]}ã€‹â•â‰¡*
*ğŸ¤– Bot Name: XLICON-V4-MD*

*ğŸ§‘â€ğŸ¤â€ğŸ§‘ ğ—¡ğ—®ğ—ºğ—²:* ${m.pushName}
*âš¡ ğ—–ğ—µğ—®ğ—¿ğ—®ğ—°ğ˜ğ—²ğ—¿ğ—¶ğ˜€ğ˜ğ—¶ğ—°:* ${sipat}
*ğŸ¨ ğ—›ğ—¼ğ—¯ğ—¯ğ˜†:* ${biho}
*ğŸ’– ğ—¦ğ—¶ğ—ºğ—½ğ—¹ğ—²ğ—»ğ—²ğ˜€ğ˜€ (Simp):* ${bhucin}%
*ğŸ’¥ ğ—šğ—¿ğ—²ğ—®ğ˜ğ—»ğ—²ğ˜€ğ˜€:* ${senga}%
*ğŸŒŸ ğ—›ğ—®ğ—»ğ—±ğ˜€ğ—¼ğ—ºğ—²:* ${chakep}
*ğŸ’¬ ğ—–ğ—µğ—®ğ—¿ğ—®ğ—°ğ˜ğ—²ğ—¿:* ${watak}
*ğŸŒ± ğ—šğ—¼ğ—¼ğ—± ğ— ğ—¼ğ—¿ğ—®ğ—¹ğ˜€:* ${baik}%
*ğŸ˜ˆ ğ—•ğ—®ğ—± ğ— ğ—¼ğ—¿ğ—®ğ—¹ğ˜€:* ${burug}%
*ğŸ§  ğ—œğ—»ğ˜ğ—²ğ—¹ğ—¹ğ—¶ğ—´ğ—²ğ—»ğ—°ğ—²:* ${cerdas}%
*ğŸ”¥ ğ—–ğ—¼ğ˜‚ğ—¿ğ—®ğ—´ğ—²:* ${berani}%
*ğŸ˜± ğ—”ğ—³ğ—¿ğ—®ğ—¶ğ—±:* ${takut}%

*â‰¡â•ã€Šğ—–ğ—µğ—²ğ—°ğ—¸ ğ—½ğ—¿ğ—¼ğ—½ğ—²ğ—¿ğ˜ğ—¶ğ—²ğ˜€ã€‹â•â‰¡*
`;

const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';
await XliconBotInc.sendMessage(m.chat, {
  image: { url: imageUrl }, // Directly use the URL for the image
  caption: profile, // Custom message with check result and mentioned user
  mentions: [bet] // Mentions the mentioned user
});
}
break;

      
        
			case 'hug': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/hug`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} hugged themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} hugged @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'cry': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/cry`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} cried themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} cried @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'kill': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/kill`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} killed themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} killed @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'pat': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/pat`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} patted themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} patted @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'lick': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/lick`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} licked themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} licked @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'kiss': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/kiss`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} kissed themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} kissed @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'bite': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/cry`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} bit themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} bit @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'yeet': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/yeet`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} yeeted themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} yeeted @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'bully': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/bully`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} bullied themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} bullied @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'bonk': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/bonk`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} bonked themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} bonked @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'wink': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/wink`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} winked themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} winked @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'poke': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/poke`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} poked themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} poked @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'nom': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/nom`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} nommed themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} nommed @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'slap': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/slap`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} slapped themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} slapped @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'smile': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/smile`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} smiled themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} smiled @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'wave': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/wave`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} waved themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} waved @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'awoo': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/awoo`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} awooed themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} awooed @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'blush': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/blush`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} blushed themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} blushed @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'smug': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/smug`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} smugged themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} smugged @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'glomp': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/glomp`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} glomped themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} glomped @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'happy': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/happy`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} happied themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} happied @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'dance': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/dance`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} danced themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} danced @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'cringe': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/cringe`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} cringed themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} cringed @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'cuddle': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/cuddle`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} cuddled themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} cuddled @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'highfive': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/awoo`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} highfived themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} highfived @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'handhold': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://api.waifu.pics/sfw/handhold`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} handheld themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} handheld @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
                case 'spank': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://nekos.life/api/v2/img/spank`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} spanked themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} spanked @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        case 'feed': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://nekos.life/api/v2/img/feed`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} fed themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} fed @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
                case 'tickle': {

        if (!m.isGroup) return XliconStickGroup()
        if (!m.mentionedJid[0] && !m.quoted) return replygcxlicon(`Tag or reply to a person`)
        var pat = await fetchJson(`https://nekos.life/api/v2/img/tickle`)

        try {

          let messsender = m.sender

          let musers = ``
          try {

            users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'

            ment = [messsender, users]

          } catch {

            users == "none"

            ment = [messsender, m.sender]

          }

          if (users == "none") {

           musers = `@${m.sender.split("@")[0]} tickled themself!`

          } else {

           musers = `@${m.sender.split("@")[0]} tickled @${users.split("@")[0]} `

          }

          const response = await axios.get(pat.url, { responseType: 'arraybuffer' })

          const buffer = Buffer.from(response.data, "utf-8")

          var fetchedgif = await GIFBufferToVideoBuffer(buffer)

          XliconBotInc.sendMessage(m.chat, { video: fetchedgif, gifPlayback: true, mentions: ment, caption: musers }, { quoted: m })

        } catch (error) {

          console.log(error);

        }

      }

        break;
        
        
        
        case 'quotes': {
          // Fetch the quote from the API
          const quotexlicony = await axios.get('https://favqs.com/api/qotd');
          const quoteText = quotexlicony.data.quote.body;
          const quoteAuthor = quotexlicony.data.quote.author;
      
          // Prepare the quote text as a caption
          const textquotes = `ğŸ’¬ *Quote:* ${quoteText}\n\nğŸ‘¤ *Author:* ${quoteAuthor}`;
      
          // Image URL to use
          const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';
      
          // Send the quote with the image directly from the URL
          await XliconBotInc.sendMessage(m.chat, {
              image: { url: imageUrl },
              caption: textquotes,
              quoted: m
          });
      }
      break;
      
        
case 'truth': {
    // Set up image URL
    const imageUrl = 'https://i.ibb.co/305yt26/bf84f20635dedd5dde31e7e5b6983ae9.jpg';

  
    // Truth questions array
   const truths = [
        "Have you ever liked anyone? How long?",
        "If you could make a friend in any group, who would you pick?",
        "What's your biggest fear?",
        "Have you ever liked someone and felt they liked you back?",
        "Have you ever stolen money from family?",
        "What's the name of your friend's ex you secretly liked?",
        "What makes you happy when sad?",
        "Have you experienced unrequited love?",
        "What's your most embarrassing moment?",
        "What's your proudest achievement this year?",
        "What's the weirdest thing you've done when alone?",
        "Have you ever cheated on a test?",
        "What is something you've done that you're ashamed of?",
        "Have you ever been caught lying?",
        "What is your most ridiculous nickname?",
        "If you could switch lives with someone for a day, who would it be?",
        "What's the worst gift you've ever received?",
        "Have you ever shared a secret you promised to keep?",
        "What's your biggest insecurity?",
        "Have you ever broken something and blamed someone else?",
        "What's a secret you've kept from your parents?",
        "What would you do if you had only 24 hours to live?",
        "What's the most trouble you've gotten into at school?",
        "What's the worst date you've ever had?",
        "What's something you've never told your best friend?",
        "What's a talent you wish you had?",
        "Have you ever pretended to be sick to skip school?",
        "If you had to date someone in this room, who would it be?",
        "What's a lie you've told to impress someone?",
        "Have you ever stalked someone on social media?",
        "If you had a superpower, what would it be?",
        "Have you ever cried watching a movie? Which one?",
        "Whatâ€™s the most childish thing you still do?",
        "Have you ever laughed at something inappropriate?",
        "Whatâ€™s your guilty pleasure?",
        "If you were invisible, whatâ€™s the first thing youâ€™d do?",
        "Have you ever lied to get out of trouble?",
        "Who do you admire the most, and why?",
        "Whatâ€™s the meanest thing youâ€™ve done to someone?",
        "Do you have any hidden talents?",
        "Have you ever lied in a game of Truth or Dare?",
        "Whatâ€™s one secret youâ€™ve kept from everyone?",
        "Have you ever had a crush on a teacher?",
        "Whatâ€™s the silliest thing youâ€™re afraid of?",
        "Whatâ€™s the worst thing youâ€™ve done when you were mad?",
        "Who was your first kiss?",
        "Have you ever cheated in a relationship?",
        "Whatâ€™s the most expensive thing youâ€™ve broken?",
        "Whatâ€™s the worst rumor you spread or heard?",
        "Have you ever been jealous of a friend?",
        "Whatâ€™s something you regret doing or saying?"
    ];

    // Randomly select a truth question
    const selectedTruth = truths[Math.floor(Math.random() * truths.length)];

    // Send the truth message
    const truthMessage = `ğŸ­ *Truth* Challenge ğŸ­\n\n${selectedTruth}`;

    await XliconBotInc.sendMessage(m.chat, {
        image: { url: imageUrl },
        caption: truthMessage,
        footer: 'XLICON-V4-MD',
        quoted: m
    });
}
break;

case 'dare': {
    // Set up image URL
    const imageUrl = 'https://i.ibb.co/305yt26/bf84f20635dedd5dde31e7e5b6983ae9.jpg';

  
    // Dare challenges array
    const dares = [
        "Eat 2 tablespoons of rice without side dishes.",
        "Call your crush and say 'I miss you.'",
        "Only reply with emojis for 24 hours.",
        "Shout *I love my crush* in public.",
        "Send your contact list screenshot.",
        "Act possessed in a funny way.",
        "Rename yourself to *I AM GOOFY* for 24 hours.",
        "Put a silly photo of yourself as your profile picture.",
        "Shout 'I am amazing!' in a voice note.",
        "Send a message to your ex saying you miss them.",
        "Text your last contact with just 'Hey!' repeatedly.",
        "Do 20 jumping jacks and record yourself.",
        "Text a random person and confess a fake secret.",
        "Talk in an accent for the next hour.",
        "Post a cringy photo on social media.",
        "Let the person next to you text anyone from your phone.",
        "Draw a funny mustache on your face and take a selfie.",
        "Say the alphabet backward.",
        "Walk outside and wave at strangers.",
        "Talk like a baby for the next 10 minutes.",
        "Share a funny meme with the last person you texted.",
        "Dance without music for 1 minute.",
        "Let someone else write your next social media post.",
        "Wear socks on your hands for the next 5 minutes.",
        "Pretend to be a chicken for 30 seconds.",
        "Take a silly selfie and post it online.",
        "Read the last text you sent out loud.",
        "Text your parents and say you got engaged.",
        "Eat a spoonful of something spicy.",
        "Imitate a famous celebrity for a minute.",
        "Text your crush with a heart emoji.",
        "Try to lick your elbow.",
        "Do 10 push-ups on video.",
        "Do your best animal impression.",
        "Spin around 10 times and walk in a straight line.",
        "Text a friend and say you're moving abroad.",
        "Act like your favorite character for 5 minutes.",
        "Talk with your tongue sticking out.",
        "Message a random number and say 'Happy Birthday!'",
        "Recite a poem about the nearest object.",
        "Pretend youâ€™re a robot for the next 5 minutes.",
        "Stand on one leg for 30 seconds.",
        "Text a friend and ask for the weirdest selfie.",
        "Sing a nursery rhyme with dramatic flair.",
        "Write 'I am the best' on your forehead with marker.",
        "Act like youâ€™re a waiter and take everyoneâ€™s order.",
        "Send a voice note saying youâ€™re a superhero.",
        "Pretend youâ€™re on a cooking show and describe your dinner.",
        "Text a random person 'Did you call me?'"
    ];

    // Randomly select a dare challenge
    const selectedDare = dares[Math.floor(Math.random() * dares.length)];

    // Send the dare message
    const dareMessage = `ğŸ”¥ *Dare* Challenge ğŸ”¥\n\n${selectedDare}`;

    await XliconBotInc.sendMessage(m.chat, {
        image: { url: imageUrl },
        caption: dareMessage,
        footer: 'XLICON-V4-MD',
        quoted: m
    });
}
break;

case 'pickupline': {
    try {
        // Fetch the pickup line from the API
        let res = await fetch(`https://api.popcat.xyz/pickuplines`);
        if (!res.ok) {
            throw new Error(`API request failed with status ${res.status}`);
        }
        
        let json = await res.json();
        let pickupLine = `*Here's a pickup line for you ğŸ˜˜ğŸ’–:*\n\n${json.pickupline} ğŸ˜‚â¤ï¸`;

        // Image URL to use
        const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';

       
        // Send the message with the image, caption, and footer
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: imageUrl },
            caption: pickupLine,
            footer: 'XLICON-V4-MD'
        });
    } catch (error) {
        console.error('Error in pickupline command:', error);
        replygcxlicon('Failed to fetch a pickup line. Please try again later.');
    }
}
break;

case 'pick': {
    // Check if the message is in a group and if there's text provided
    if (!m.isGroup) return XliconStickGroup();
    if (!text) return replygcxlicon(`What do you want to pick? ğŸ¤”\nExample: ${prefix + command} idiot ğŸ˜œ`);

    // Get group metadata and participants
    const groupMetadata = await XliconBotInc.groupMetadata(m.chat).catch(() => {}) || "";
    const participants = groupMetadata ? groupMetadata.participants : [];
    let member = participants.map((u) => u.id);

    // Get a random member
    let xliconshimts = member[Math.floor(Math.random() * member.length)];

    // Image URL to use
    const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';

    try {
       
        // Send the message with the image, text, and mention
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: imageUrl },
            caption: `The most *${text}* here is *@${xliconshimts.split("@")[0]}* ğŸ˜œâœ¨`,
            mentions: [xliconshimts] // Ensure that the user is mentioned in the message
        });
    } catch (error) {
        console.error('Error fetching or sending image:', error);
        replygcxlicon('Failed to send image. Please try again later.');
    }
}
break;

        
        
    case 'yomamajoke': {
    try {
        // Fetch a yo mama joke from the API
        let res = await fetch(`https://yomamaindra.onrender.com/jokes`);

        if (!res.ok) {
            throw new Error(`API request failed with status ${res.status}`);
        }

        let json = await res.json();

        // Extract the joke from the response
        let yoMamaJoke = `${json.joke}`;

        // Image URL to use
        const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';

       
        // Send the message with the image and caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: imageUrl },
            caption: `*Yo Mama Joke ğŸ˜‚:*\n\n${yoMamaJoke}`,
            footer: 'XLICON-V4-MD'
        });
    } catch (error) {
        console.error('API Fetch Error:', error);
        await XliconBotInc.sendText(m.chat, "An error occurred while fetching the joke. Please try again.");
    }
}
break;
        
        
        
		case 'fact': {
    try {
        // Fetch a random fact from the API
        const { data } = await axios.get(`https://nekos.life/api/v2/fact`);
        
        // Define the fact text with the theme emoji
        let factText = `${themeemoji} *Fact:* ${data.fact}\n`;

        // Image URL to use
        const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';

      
        // Send the message with the image and caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: imageUrl },
            caption: factText,
            footer: botname
        });
    } catch (error) {
        console.error('Error fetching fact:', error);
        await XliconBotInc.sendText(m.chat, "An error occurred while fetching the fact. Please try again.");
    }
}
break;
	
  
case 'soulmate': {
  if (!m.isGroup) return XliconStickGroup(); // Ensure it's a group
  let member = participants.map(u => u.id);
  let me = m.sender;
  let jodoh = member[Math.floor(Math.random() * member.length)];

  // Image URL to use
  const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';

  try {
     
      // Send the message with the image, caption, and mention the users
      await XliconBotInc.sendMessage(m.chat, {
          image: { url: imageUrl },
          caption: `ğŸ‘«Your Soulmate Is\n\n@${me.split('@')[0]}\n\nâ¤ï¸\n\n@${jodoh.split('@')[0]}`,
          mentions: [me, jodoh] // Mentions both users
      });
  } catch (error) {
      console.error('Error fetching or sending image:', error);
      replygcxlicon('Failed to send image. Please try again later.');
  }
  }            
  break;

      
      
      case 'couple': {
  if (!m.isGroup) return XliconStickGroup(); // Ensure it's a group

  // Get all participants in the group
  let member = participants.map(u => u.id);
  let orang = member[Math.floor(Math.random() * member.length)]; // Random member for one partner
  let jodoh = member[Math.floor(Math.random() * member.length)]; // Random member for the other partner

  // Image URL to use
  const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';

  try {
      // Send the message with the image, caption, and mention the users
      await XliconBotInc.sendMessage(m.chat, {
          image: { url: imageUrl },
          caption: `ğŸ’Couple\n\n@${orang.split('@')[0]}\n\nâ¤ï¸\n\n@${jodoh.split('@')[0]}\n\nCieeee, What's Going Onâ¤ï¸ğŸ’–ğŸ‘€`,
          mentions: [orang, jodoh] // Mentions both users
      });
  } catch (error) {
      console.error('Error sending message:', error);
      await XliconBotInc.sendMessage(m.chat, { text: 'Failed to send message. Please try again later.' });
  }
  }
  break;





  case 'can': {
    if (!text) return replygcxlicon(`â“ Ask a question\n\nExample: ${prefix + command} Can I dance?`);

    let bisa = [`âœ… Can`, `âŒ Can't`, `ğŸš« Cannot`, `ğŸ’¯ Of Course You Can!!!`];
    let keh = bisa[Math.floor(Math.random() * bisa.length)];

    let jawab = `*Can ${text}*\nAnswer: ${keh} ğŸ¤©`;

    // Image URL to use
    const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';

    try {
        // Send the message with the image and the answer
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: imageUrl },
            caption: jawab, // Custom message with the question and answer
            mentions: [m.sender] // Mentions the user who asked
        });
    } catch (error) {
        console.error('Error fetching or sending image:', error);
        replygcxlicon('â— Failed to send image. Please try again later.');
    }
}
break;


case 'is': {
  if (!text) return replygcxlicon(`â“ Ask a question\n\nExample: ${prefix + command} Is she a virgin?`);

  let apa = [`âœ… Yes`, `âŒ No`, `ğŸ¤” It Could Be`, `âœ”ï¸ That's right`];
  let kah = apa[Math.floor(Math.random() * apa.length)];

  let jawab = `*Is ${text}*\nAnswer: ${kah} ğŸ˜`;

  // Image URL to use
  const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';

  try {
      // Send the message with the image and the answer
      await XliconBotInc.sendMessage(m.chat, {
          image: { url: imageUrl },
          caption: jawab, // Custom message with the question and answer
          mentions: [m.sender] // Mentions the user who asked
      });
  } catch (error) {
      console.error('Error fetching or sending image:', error);
      replygcxlicon('â— Failed to send image. Please try again later.');
  }
}
break;

case 'when': {
  if (!text) return replygcxlicon(`â“ Ask a question\n\nExample: ${prefix + command} will I get married?`);

  let kapan = [
      '5 More Days â³', '10 More Days â³', '15 More Days â³', '20 More Days â³', '25 More Days â³', '30 More Days â³',
      '35 More Days â³', '40 More Days â³', '45 More Days â³', '50 More Days â³', '55 More Days â³', '60 More Days â³',
      '65 More Days â³', '70 More Days â³', '75 More Days â³', '80 More Days â³', '85 More Days â³', '90 More Days â³', 
      '100 More Days â³', '5 Months More ğŸ—“ï¸', '10 Months More ğŸ—“ï¸', '15 Months More ğŸ—“ï¸', '20 Months More ğŸ—“ï¸', 
      '25 Months More ğŸ—“ï¸', '30 Months More ğŸ—“ï¸', '35 Months More ğŸ—“ï¸', '40 Months More ğŸ—“ï¸', '45 Months More ğŸ—“ï¸', 
      '50 Months More ğŸ—“ï¸', '55 Months More ğŸ—“ï¸', '60 Months More ğŸ—“ï¸', '65 Months More ğŸ—“ï¸', '70 Months More ğŸ—“ï¸', 
      '75 Months More ğŸ—“ï¸', '80 Months More ğŸ—“ï¸', '85 Months More ğŸ—“ï¸', '90 Months More ğŸ—“ï¸', '100 Months More ğŸ—“ï¸', 
      '1 More Year ğŸ“…', '2 More Years ğŸ“…', '3 More Years ğŸ“…', '4 More Years ğŸ“…', '5 More Years ğŸ“…', 'Tomorrow â°', 
      'The Day After Tomorrow â°'
  ];

  let koh = kapan[Math.floor(Math.random() * kapan.length)];
  let jawab = `*When ${text}*\nAnswer: ${koh} ğŸ¤”`;

  // Image URL to use
  const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';

  try {
      // Send the message with the image and the answer
      await XliconBotInc.sendMessage(m.chat, {
          image: { url: imageUrl },
          caption: jawab, // Custom message with the question and answer
          mentions: [m.sender] // Mentions the user who asked
      });
  } catch (error) {
      console.error('Error fetching or sending image:', error);
      replygcxlicon('â— Failed to send image. Please try again later.');
  }
}
break;


case 'what': {
  if (!text) return replygcxlicon(`â“ Ask a question\n\nExample: ${prefix + command} is your name?`);

  let lel = [`ğŸ‘©â€â¤ï¸â€ğŸ‘¨ Ask Your GF`, `ğŸ¤·â€â™‚ï¸ I Donâ€™t Know`, `ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ I Donâ€™t Know, Ask Your Father`];
  let kah = lel[Math.floor(Math.random() * lel.length)];
  let jawab = `*What ${text}* â“\nAnswer: ${kah} ğŸ¤”`;

  // Image URL to use
  const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';

  try {
      await XliconBotInc.sendMessage(m.chat, {
          image: { url: imageUrl },
          caption: jawab,
          mentions: [m.sender]
      });
  } catch (error) {
      console.error('Error fetching or sending image:', error);
      replygcxlicon('â— Failed to send image. Please try again later.');
  }
}
break;

case 'where': {
  if (!text) return replygcxlicon(`â“ Ask a question\n\nExample: ${prefix + command} is your name?`);

  let wherelol = [`ğŸï¸ In the mountain`, `ğŸŒ• On Mars`, `ğŸŒ™ On the moon`, `ğŸŒ³ In the jungle`, `ğŸ‘©â€ğŸ‘§ I donâ€™t know, ask your mom`, `ğŸ¤·â€â™‚ï¸ It could be somewhere`];
  let kah = wherelol[Math.floor(Math.random() * wherelol.length)];
  let jawab = `*Where ${text}* â“\nAnswer: ${kah} ğŸ¤”`;

  // Image URL to use
  const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';

  try {
      await XliconBotInc.sendMessage(m.chat, {
          image: { url: imageUrl },
          caption: jawab,
          mentions: [m.sender]
      });
  } catch (error) {
      console.error('Error fetching or sending image:', error);
      replygcxlicon('â— Failed to send image. Please try again later.');
  }
}
break;

case 'how': {
  if (!text) return replygcxlicon(`â“ Ask a question\n\nExample: ${prefix + command} to date a girl?`);

  let gimana = [`ğŸ¤” Ummm...`, `ğŸ˜… Itâ€™s Difficult Bro`, `ğŸš« Sorry, the bot canâ€™t answer`, `ğŸ” Try searching on Google`, `ğŸ˜± Holy cow! Really?`, `ğŸ˜´ Iâ€™m too dizzy to answer`, `ğŸ™ Oh, I see :(`, `â³ Be patient, boss`, `ğŸ™„ Really, dude?`];
  let kah = gimana[Math.floor(Math.random() * gimana.length)];
  let jawab = `*How ${text}* â“\nAnswer: ${kah} ğŸ¤”`;

  // Image URL to use
  const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';

  try {
      await XliconBotInc.sendMessage(m.chat, {
          image: { url: imageUrl },
          caption: jawab,
          mentions: [m.sender]
      });
  } catch (error) {
      console.error('Error fetching or sending image:', error);
      replygcxlicon('â— Failed to send image. Please try again later.');
  }
}
break;
      
case 'rate': {
  if (!text) return replygcxlicon(`â“ Example: ${prefix + command} my profile`);

  let ra = Array.from({ length: 100 }, (_, i) => i + 1); // Array of numbers from 1 to 100
  let kah = ra[Math.floor(Math.random() * ra.length)];
  let jawab = `*Rate ${text}* ğŸ’¯\nAnswer: ${kah}% ğŸ†`;

  // Image URL to use
  const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';

  try {

      // Send the message with the image and the answer
      await XliconBotInc.sendMessage(m.chat, {
          image: { url: imageUrl },
          caption: jawab, // Custom message with the rating
          mentions: [m.sender] // Mentions the user who asked
      });
  } catch (error) {
      console.error('Error fetching or sending image:', error);
      replygcxlicon('â— Failed to send image. Please try again later.');
  }
}
break;
      
			case 'define': {
   if (!q) return replygcxlicon(`â“ What would you like to define?`);
    try {
        const targetFine = await axios.get(`http://api.urbandictionary.com/v0/define?term=${q}`);
        if (!targetFine || !targetFine.data.list.length) return replygcxlicon('No definition found.');

        const definition = targetFine.data.list[0].definition.replace(/\[|\]/g, "");
        const example = targetFine.data.list[0].example.replace(/\[|\]/g, "");
        const reply = `
ğŸ“– *Word:* ${q}
ğŸ’¬ *Definition:* ${definition}
âœï¸ *Example:* ${example}`;

        // Image URL to use
        const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';


        // Send the message with the image and the reply text
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: imageUrl },
            caption: reply,
            mentions: [m.sender]
        });
    } catch (err) {
        console.error('Error:', err);
        replygcxlicon(`*${q}* isn't a valid text.`);
    }
}
break;

 //AI COMMANDS HERE       
case 'blackboxai': {
  if (!text) return replygcxlicon(`âš¡ *Example:* ${prefix + command} write a program to delete a file ğŸ“`);
  try {
    let gpt = await (await fetch(`https://itzpire.com/ai/blackbox-ai?q=${text}`)).json();
    const reply = `ğŸ”¥ *Blackbox AI Response* ğŸ”¥\n\nğŸ’¡ *Result:* ${gpt.result}\n\nğŸ“ *Your Request:* ${text}`;
    const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';

    await XliconBotInc.sendMessage(m.chat, {
      image: { url: imageUrl },
      caption: reply,
      mentions: [m.sender]
    });
  } catch (e) {
    console.error('Error:', e);
    return replygcxlicon(`â— *Error:* ${e.message} âš ï¸`);
  }
}
break;

case 'travel-assistant': {
  if (!text) return replygcxlicon(`âœˆï¸ *Example:* ${prefix + command} how can I visit the Taj Mahal ğŸ°`);
  try {
    let gpt = await (await fetch(`https://itzpire.com/ai/copilot2trip?q=${text}`)).json();
    if (gpt.status === "error") {
      return replygcxlicon(`âŒ *Error:* ${gpt.message}`);
    }
    const reply = `ğŸŒ *Travel Assistant AI* ğŸŒ\n\nğŸ—ºï¸ *Your Request:* ${text}\n\nğŸ’¬ *Response:* ${gpt.result}`;
    const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';

    await XliconBotInc.sendMessage(m.chat, {
      image: { url: imageUrl },
      caption: reply,
      mentions: [m.sender]
    });
  } catch (e) {
    console.error('Error:', e);
    return replygcxlicon("âš ï¸ *Error* âš ï¸");
  }
}
break;
                
case 'dalle': {
  if (!text) return replygcxlicon(`ğŸ¤ *â€¢ Example:* ${prefix + command} a girl singing in public ğŸ¶`);

  try {
      const apiUrls = [
          'https://aemt.uk.to/dalle?text=',
          'https://meitang.xyz/dalle?text=',
          'https://btch.us.kg/dalle?text=',
          'https://api.tioo.eu.org/dalle?text=',
          'https://api.tioprm.eu.org/dalle?text='
      ];
      const randomApiUrl = apiUrls[Math.floor(Math.random() * apiUrls.length)];
      let response = await fetch(randomApiUrl + encodeURIComponent(text));

      if (!response.ok) return replygcxlicon('âŒ Failed to fetch the image. Please try again.');

      let gptImageUrl = await response.json();

      if (!gptImageUrl || !gptImageUrl.url) return replygcxlicon('âŒ No image found. Please try again with a different prompt.');

      await XliconBotInc.sendMessage(m.chat, {
          image: { url: gptImageUrl.url },
          caption: `> Dalle ğŸŒŸ \n\n _*Here is the result of: ${text} âœ¨*_`
      }, { quoted: m });

  } catch (e) {
      console.error(e);
      return replygcxlicon("`*Error*`");
  }
}
break;

case 'stablediffusion': {
  if (!text) return replygcxlicon(`ğŸ¨ *â€¢ Example:* ${prefix + command} school boy ğŸ‘¦`);

  try {
      const apiUrls = [
          'https://aemt.uk.to/stablediffusion?text=',
          'https://meitang.xyz/stablediffusion?text=',
          'https://btch.us.kg/stablediffusion?text=',
          'https://api.tioo.eu.org/stablediffusion?text=',
          'https://api.tioprm.eu.org/stablediffusion?text='
      ];
      const randomApiUrl = apiUrls[Math.floor(Math.random() * apiUrls.length)];
      const timeout = new Promise((_, reject) =>
          setTimeout(() => reject(new Error('â³ Request timeout')), 15000)
      );

      let response = await Promise.race([
          fetch(randomApiUrl + encodeURIComponent(text)),
          timeout
      ]);

      if (!response.ok) return replygcxlicon('âŒ *Failed to fetch the image.* Please try again. ğŸ”„');

      let imageUrl = await response.json();

      if (!imageUrl || !imageUrl.url) return replygcxlicon('âŒ *No image found.* Please try again with a different prompt. ğŸ”„');

      await XliconBotInc.sendMessage(m.chat, {
          image: { url: imageUrl.url },
          caption: `âœ¨ *Stable Diffusion* âœ¨\n\nğŸ–¼ï¸ _*Here is the result of: ${text}*_ ğŸ–Œï¸`
      }, { quoted: m });

  } catch (e) {
      console.error(e);
      return replygcxlicon(`â— *Error:* ${e.message} âš ï¸`);
  }
}
break;

case 'lexica': {
    if (!text) return replygcxlicon(`ğŸ“¸ *â€¢ Example:* ${prefix + command} a cat ğŸ±`);

    try {
        const timeout = new Promise((_, reject) =>
            setTimeout(() => reject(new Error('â³ Request timeout')), 15000)
        );

        let response = await Promise.race([
            fetch(`https://api.maher-zubair.xyz/ai/lexica?apikey=${global.id}&prompt=${encodeURIComponent(text)}`),
            timeout
        ]);

        if (!response.ok) return replygcxlicon('âŒ *Failed to fetch the image.* Please try again. ğŸ”„');

        let data = await response.json();

        if (!data.result) return replygcxlicon('âŒ *No image found.* Please try again with a different prompt. ğŸ”„');

        await XliconBotInc.sendMessage(m.chat, {
            image: { url: data.result },
            caption: `âœ¨ *Lexica AI* âœ¨\n\nğŸ–¼ï¸ _*Here is the result of: ${text}*_ ğŸ–Œï¸`
        }, { quoted: m });

    } catch (e) {
        console.error(e);
        return replygcxlicon(`â— *Error:* ${e.message} âš ï¸`);
    }
}
break;

case 'photoleap': {
    if (!text) return replygcxlicon(`ğŸŒŠ *Example:* ${prefix + command} blue sea`);

    const currentTime = Date.now();
    if (currentTime - (global.lastUsedPhotoleap || 0) < 10000) {
        return replygcxlicon("â³ Cooldown 10 seconds, try again later");
    }
    global.lastUsedPhotoleap = currentTime;

    try {
        let gpt = await (await fetch(`https://tti.photoleapapp.com/api/v1/generate?prompt=${encodeURIComponent(text)}`)).json();

        if (!gpt.result_url) return replygcxlicon('âŒ *No image found.* Please try again with a different prompt. ğŸ”„');

        const reply = `âœ¨ *Photo Leap AI* âœ¨\n\nğŸ–¼ï¸ _*Here is the result of: ${text}*_ ğŸ“·`;

        await XliconBotInc.sendMessage(m.chat, {
            image: { url: gpt.result_url },
            caption: reply,
            mentions: [m.sender]
        });

    } catch (e) {
        console.error(e);
        return replygcxlicon(`â— *Error:* ${e.message} âš ï¸`);
    }
}
break;
                
case 'ai': case 'gpt': case 'openai': {
    if (!text) return replygcxlicon(`*â€¢ Example:* ${prefix + command} what is your name`);

    try {
        const apiUrls = [
            'https://aemt.uk.to/openai?text=',
            'https://meitang.xyz/openai?text=',
            'https://btch.us.kg/openai?text=',
            'https://api.tioo.eu.org/openai?text=',
            'https://api.tioprm.eu.org/openai?text='
        ];
        const randomApiUrl = apiUrls[Math.floor(Math.random() * apiUrls.length)];
        let response = await fetch(randomApiUrl + encodeURIComponent(text));

        if (!response.ok) return replygcxlicon('âŒ *Failed to fetch the response.* Please try again. ğŸ”„');

        let gpt = await response.json();

        if (!gpt.result) return replygcxlicon('âŒ *No result found.* Please try again with a different prompt. ğŸ”„');

        const reply = `ğŸŒŸ *OpenAI Response* ğŸŒŸ\n\nğŸ’¬ *Response:* ${gpt.result}\n\nğŸ“ *Your Request:* ${text}`;

        await XliconBotInc.sendMessage(m.chat, {
            image: { url: 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg' },
            caption: reply,
            mentions: [m.sender]
        });

    } catch (e) {
        console.error(e);
        return replygcxlicon(`â— *Error:* ${e.message} âš ï¸`);
    }
}
break;

case 'checkgpt': {
    if (!text) return replygcxlicon(`*â€¢ Example:* ${prefix + command} input your text`);

    try {
        let apiUrl = `${global.api}ai/text-detector?apikey=${global.id}&prompt=${encodeURIComponent(text)}`;
        let response = await fetch(apiUrl);

        if (!response.ok) return replygcxlicon('âŒ Failed to analyze the text. Please try again.');

        let data = await response.json();

        const feedback = `*ğŸ¤– GPT Text Analysis*\n\n`
            + `*ğŸ“ Input Text:* \n_${data.result.input_text}_\n\n`
            + `*ğŸŒ Detected Language:* \n_${data.result.detected_language}_\n\n`
            + `*ğŸ’¡ AI Detection Feedback:* \n_${data.result.feedback}_\n\n`
            + `*ğŸ“Š AI Likelihood:* \n_${data.result.isHuman}% likely human-generated_\n\n`
            + `*ğŸ’¬ Additional Feedback:* \n_${data.result.additional_feedback}_\n`;

        await XliconBotInc.sendMessage(m.chat, {
            image: { url: 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg' },
            caption: feedback,
            mentions: [m.sender]
        });

    } catch (e) {
        console.error(e);
        return replygcxlicon("â— *Error analyzing the text. Please try again.*");
    }
}
break;

case 'darky': {
    if (!text) return replygcxlicon(`*â€¢ Example:* ${prefix + command} write me a simple code of python`);

    try {
        let response = await (await fetch(`https://evlgpt.onrender.com/egpt?prompt=${encodeURIComponent(text)}`)).json();

        let message = response.message.replace(/GURUGPT V1/g, 'XLICON V4');

        const reply = `ğŸ”¥ *Xlicon AI Response* ğŸ”¥\n\nğŸ’¡ *Result:* ${message}\n\nğŸ“ *Your Request:* ${text}`;

        await XliconBotInc.sendMessage(m.chat, {
            image: { url: 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg' },
            caption: reply,
            mentions: [m.sender]
        });

    } catch (e) {
        console.error('Error:', e);
        return replygcxlicon("â— *Error*");
    }
}
break;

case 'bing': {
  if (!text) return replygcxlicon(`*â€¢ Example:* ${prefix + command} hello`);

  // Define API URLs
  const apiUrls = [
    'https://aemt.uk.to/bingai?text=',
    'https://meitang.xyz/bingai?text=',
    'https://btch.us.kg/bingai?text=',
    'https://api.tioo.eu.org/bingai?text=',
    'https://api.tioprm.eu.org/bingai?text='
  ];

  try {
    // Choose a random API URL from the list
    const apiUrl = apiUrls[Math.floor(Math.random() * apiUrls.length)] + encodeURIComponent(text);
    
    // Fetch data from the selected API
    let response = await (await fetch(apiUrl)).json();
    
    // Prepare the response text with emojis
    const reply = `ğŸ”¥ *Xlicon AI Response* ğŸ”¥\n\nğŸ’¬ *Response:* ${response.result}\n\nğŸ“ *Your Request:* ${text}`;

    // Image URL to use
    const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';

    // Send the message with the image URL and the reply text
    await XliconBotInc.sendMessage(m.chat, {
      image: { url: imageUrl },
      caption: reply,
      mentions: [m.sender]
    });

  } catch (e) {
    console.error('Error:', e);
    return replygcxlicon("â— *Error*");
  }
}
break;

case 'mathsai': {
  if (!text) return replygcxlicon(`*â€¢ Example:* ${prefix + command} what is your name`);
  
  try {
    // Fetch data from the Maths AI API
    let gpt = await (await fetch(`${global.api}ai/math?apikey=${global.id}&prompt=${text}`)).json();

    // Prepare the message with the response
    const reply = `ğŸ”¥ *Maths AI Response* ğŸ”¥\n\nğŸ§® *Result:* ${gpt.result}\n\nğŸ“ *Your Request:* ${text}`;

    // Image URL to use
    const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';

    // Send the message with the image URL and the reply text
    await XliconBotInc.sendMessage(m.chat, {
      image: { url: imageUrl },
      caption: reply,
      mentions: [m.sender]
    });

  } catch (e) {
    console.error('Error:', e);
    return replygcxlicon("â— *Error occurred while processing the math query.*");
  }
}
break;

case 'yomamajoke': {
  try {
    // Fetch a Yo Mama joke from the API
    let res = await fetch(`https://yomamaindra.onrender.com/jokes`);

    if (!res.ok) {
      throw new Error(`API request failed with status ${res.status}`);
    }

    let json = await res.json();

    // Extract the joke from the response
    let yoMamaJoke = `${json.joke}`;

    // Create the message with the joke
    const reply = `ğŸ˜‚ *Yo Mama Joke* ğŸ˜‚\n\n${yoMamaJoke}`;

    // Image URL to use
    const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';

    // Send the joke with the image URL
    await XliconBotInc.sendMessage(m.chat, {
      image: { url: imageUrl },
      caption: reply,
      mentions: [m.sender]
    });

  } catch (error) {
    console.error('API Fetch Error:', error);
    return await XliconBotInc.sendText(m.chat, "An error occurred while fetching the joke. Please try again.");
  }
}
break;

case 'truecaller': {
  let phoneNumber = '';

  // Determine the phone number from text, quoted message, or mentioned user
  if (text) {
    phoneNumber = text.replace(/[^0-9]/g, '');
  } else if (m.quoted) {
    phoneNumber = m.quoted.sender.replace(/[^0-9]/g, '');
  } else if (m.mentionedJid && m.mentionedJid[0]) {
    phoneNumber = m.mentionedJid[0].replace(/[^0-9]/g, '');
  } else {
    return await XliconBotInc.sendText(m.chat, "Please provide a number in international format without +, quote a user, or mention a user.");
  }

  try {
    const installationId = 'a1i0Z--jzbJC6kx-2_s3OMNW2X7O2Qe3ca-XwmHexijCBA6MNKAO2ciUw756zhWj';
    const apiUrl = `https://truecaller-api.vercel.app/search?phone=${encodeURIComponent(phoneNumber)}&id=${installationId}`;

    let response = await fetch(apiUrl);
    if (!response.ok) {
      throw new Error(`API request failed with status ${response.status}`);
    }

    let json = await response.json();
    json.creator = 'XLICON'; // Change creator to Xlicon

    let details = '';
    for (let prop in json) {
      if (prop === 'flagURL') continue;

      if (prop === 'addresses') {
        details += `âš *${prop}:*\n`;
        for (let addressProp in json[prop][0]) {
          details += `  âš *${addressProp}:* ${json[prop][0][addressProp]}\n`;
        }
      } else if (prop === 'countryDetails') {
        details += `âš *${prop}:*\n`;
        for (let countryProp in json[prop]) {
          if (Array.isArray(json[prop][countryProp])) {
            details += `  âš *${countryProp}:* ${json[prop][countryProp].join(', ')}\n`;
          } else {
            details += `  âš *${countryProp}:* ${json[prop][countryProp]}\n`;
          }
        }
      } else {
        if (prop !== 'flagURL') {
          details += `âš *${prop}:* ${json[prop]}\n`;
        }
      }
    }

    // Send the details message with an image link
    const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';

    await XliconBotInc.sendMessage(m.chat, {
      image: { url: imageUrl },
      caption: details,
      mentions: [m.sender]
    });

  } catch (error) {
    console.error('API Fetch Error:', error);
    return await XliconBotInc.sendText(m.chat, "An error occurred while fetching the phone details. Please try again.");
  }
}
break;


//-------------------------------------------------------------------------------------------------//

// Cricket Commands

// Matches Command
case 'matches':
case 'match':
case 'cricket':
  {
    let res = await fetchJson(`https://api-smd.onrender.com/api/match`);
    const matches = res.results;
    console.log(matches);

    let outputMessage = ""; // Initialize the output message
    matches.forEach((match) => {
      // Change 'matches' to 'match'
      outputMessage += `ğŸ *Match*: ${match.title}\n`;
      outputMessage += `ğŸ”— *Link*: ${match.link}\n\n`;
    });

    replygcxlicon(
      `${outputMessage}\n\nType *${prefix}score cricbuzz link* to get detailed result...`
    );
  }
  break;

// Scores Command
case 'scores':
case 'score':
  {
    if (!args[0]) {
      return replygcXlicon(
        `âš ï¸ *Cricbuzz match Link is required*. Type *${prefix}matches* to get links...`
      );
    }

    let res = await fetchJson(
      `https://api-smd.onrender.com/api/score?url=${args[0]}`
    );
    if (res.error) {
      return replygcXlicon("âŒ *No Data Found or Invalid URL...*");
    }

    let txt = `ğŸ *Match Summary:*\n\n*${res.results.names}*\n\n`;
    txt += `ğŸ“ *Details:*\n`;
    res.results.details.forEach(detail => {
      txt += `ğŸ“Œ ${detail}\n`;
    });
    txt += `\n*Summary*: ${res.results.preview}`;

    replygcxlicon(txt);
  }
  break;

    //-------------------------------------------------------------------------------------------//

   
    
    //--------------------------------------------------------------------------------------------//

    case 'sc': case 'script': case 'donate': case 'cekupdate': case 'updatebot': case 'cekbot': case 'sourcecode': {
    let me = m.sender;
    let teks = `âœ¨ *${global.botname} Script* âœ¨\n\n` +
               `ğŸ“º *YouTube:* ${global.websitex}\n` +
               `ğŸ™ *GitHub:* ${global.botscript}\n\n` +
               `ğŸ‘‹ *Hi* @${me.split('@')[0]}! \n` +
               `ğŸ’– _Don't forget to donate to support us!_ ğŸœğŸ‘‡\n` +
               `https://i.ibb.co/SBXWb1R/donate.jpg`;

    sendXliconBotIncMessage(m.chat, { 
        text: teks,
        mentions: [me],
        contextInfo: {
            forwardingScore: 9999999,
            isForwarded: true,
            mentionedJid: [me],
            "externalAdReply": {
                "showAdAttribution": true,
                "renderLargerThumbnail": true,
                "title": global.botname, 
                "containsAutoReply": true,
                "mediaType": 1, 
                "thumbnail": fs.readFileSync("./XliconMedia/theme/XliconPic.jpg"),
                "mediaUrl": `${wagc}`,
                "sourceUrl": `${wagc}`
            }
        }
    });
}
break;

                
case 'runtime': {
    // Format the uptime string with emojis and decorations
    let lowq = `*â›©ï¸ Bot Uptime â›©ï¸*\n\n` +
               `ğŸ•°ï¸ *The Bot Has Been Online For:*  \n` +
               `ğŸ’« ${runtime(process.uptime())} \n\n` +
               `ğŸ‰ *Let's keep the chat lively!* `;

    replygcxlicon(lowq);
}
break;
			case 'settings': {
    if (XliconTheCreator) {
        // Show the current settings
        let settingsBot = Object.entries(db.settings[botNumber]).map(([key, value]) => {
            let qhk = (typeof value === 'boolean') ? (value ? 'âœ… On' : 'âŒ Off') : value;
            return `*${key.charAt(0).toUpperCase() + key.slice(1)}*: ${qhk}`;
        }).join('\n');
        
        replygcxlicon(`*Current Settings:*\n${settingsBot}`);  // Return settings list

        // Handle specific commands to toggle settings on/off
        if (text === 'anticall on') {
            db.settings[botNumber].anticall = true;
            replygcxlicon('âœ… *Anticall Activated*');
        }
        else if (text === 'anticall off') {
            db.settings[botNumber].anticall = false;
            replygcxlicon('âŒ *Anticall Deactivated*');
        }
        else if (text === 'autobio on') {
            db.settings[botNumber].autobio = true;
            replygcxlicon('âœ… *Autobio Activated*');
        }
        else if (text === 'autobio off') {
            db.settings[botNumber].autobio = false;
            replygcxlicon('âŒ *Autobio Deactivated*');
        }
        else if (text === 'autoread on') {
            db.settings[botNumber].autoread = true;
            replygcxlicon('âœ… *Autoread Activated*');
        }
        else if (text === 'autoread off') {
            db.settings[botNumber].autoread = false;
            replygcxlicon('âŒ *Autoread Deactivated*');
        }
        else if (text === 'autotype on') {
            db.settings[botNumber].autotyping = true;
            replygcxlicon('âœ… *Autotype Activated*');
        }
        else if (text === 'autotype off') {
            db.settings[botNumber].autotyping = false;
            replygcxlicon('âŒ *Autotype Deactivated*');
        }
        else if (text === 'antiswview on') {
            db.settings[botNumber].readsw = true;
            replygcxlicon('âœ… *Read SW Activated*');
        }
        else if (text === 'antiswview off') {
            db.settings[botNumber].readsw = false;
            replygcxlicon('âŒ *Read SW Deactivated*');
        }
    } else {
        replygcxlicon('âš ï¸ *You are not authorized to view or change settings.*');
    }
}
break;

                
case 'ghstalk': case 'githubstalk': {
    if (!q) return replygcxlicon(`*Example:* ${prefix + command} DGXlicon`);

    await XliconStickWait();
    let githubstalk = require('./lib/scraper');
    let aj = await githubstalk.githubstalk(`${q}`);

    // Create a formatted message with emojis and styling
    let caption = `ğŸŒ *Github Stalker* ğŸŒ\n\n` +
                  `ğŸ‘¤ *Username:* ${aj.username}\n` +
                  `ğŸ†” *Nickname:* ${aj.nickname}\n` +
                  `ğŸ“ *Bio:* ${aj.bio}\n` +
                  `ğŸ” *Id:* ${aj.id}\n` +
                  `ğŸ”— *NodeId:* ${aj.nodeId}\n` +
                  `ğŸ“¸ *Profile Picture:* ${aj.profile_pic}\n` +
                  `ğŸŒ *Url Github:* ${aj.url}\n` +
                  `ğŸ·ï¸ *Type:* ${aj.type}\n` +
                  `ğŸ‘¥ *Admin:* ${aj.admin}\n` +
                  `ğŸ¢ *Company:* ${aj.company}\n` +
                  `ğŸ“ *Blog:* ${aj.blog}\n` +
                  `ğŸ“ *Location:* ${aj.location}\n` +
                  `âœ‰ï¸ *Email:* ${aj.email}\n` +
                  `ğŸ“¦ *Public Repos:* ${aj.public_repo}\n` +
                  `ğŸ“œ *Public Gists:* ${aj.public_gists}\n` +
                  `ğŸ‘¥ *Followers:* ${aj.followers}\n` +
                  `ğŸ‘£ *Following:* ${aj.following}\n` +
                  `ğŸ“… *Created At:* ${aj.created_at}\n` +
                  `ğŸ”„ *Updated At:* ${aj.updated_at}`;

    // Send the message with the user's profile picture
    XliconBotInc.sendMessage(m.chat, { 
        image: { url: aj.profile_pic }, 
        caption: caption 
    }, { quoted: m });
}
break;
                
case 'npmstalk': {
    if (!q) return replygcxlicon(`*Example:* ${prefix + command} xliconapi`);

    await XliconStickWait();
    let npmstalk = require('./lib/scraper');
    let eha = await npmstalk.npmstalk(q);
    
    // Create a formatted message for npm stalk
    let npmCaption = `ğŸ“¦ *NPM Stalker* ğŸ“¦\n\n` +
                     `ğŸŒŸ *Name:* ${eha.name}\n` +
                     `ğŸ”„ *Version Latest:* ${eha.versionLatest}\n` +
                     `ğŸ› ï¸ *Version Publish:* ${eha.versionPublish}\n` +
                     `ğŸ”§ *Version Update:* ${eha.versionUpdate}\n` +
                     `ğŸ“ˆ *Latest Dependencies:* ${eha.latestDependencies}\n` +
                     `ğŸ“… *Publish Dependencies:* ${eha.publishDependencies}\n` +
                     `ğŸ•’ *Publish Time:* ${eha.publishTime}\n` +
                     `ğŸ“† *Latest Publish Time:* ${eha.latestPublishTime}`;
    
    replygcxlicon(npmCaption);
}
break;

case 'ffstalk': {
    if (!q) return replygcxlicon(`*Example:* ${prefix + command} 946716486`);

    await XliconStickWait();
    let ffstalk = require('./lib/scraper');
    let eeh = await ffstalk.ffstalk(`${q}`);
    
    // Create a formatted message for Free Fire stalk
    let ffCaption = `ğŸ”¥ *Free Fire Stalker* ğŸ”¥\n\n` +
                    `ğŸ†” *ID:* ${eeh.id}\n` +
                    `ğŸ‘¤ *Nickname:* ${eeh.nickname}`;
    
    replygcxlicon(ffCaption);
}
break;

case 'mlstalk': {
    if (!q) return replygcxlicon(`*Example:* ${prefix + command} 530793138|8129`);

    await XliconStickWait();
    let mlstalk = require('./lib/scraper');
    let dat = await mlstalk.mlstalk(q.split("|")[0], q.split("|")[1]);
    
    // Create a formatted message for Mobile Legend stalk
    let mlCaption = `ğŸ“± *Mobile Legend Stalker* ğŸ“±\n\n` +
                    `ğŸ‘¤ *Username:* ${dat.userName}\n` +
                    `ğŸ†” *ID:* ${q.split("|")[0]}\n` +
                    `ğŸŒ *ID Zone:* ${q.split("|")[1]}`;
    
    replygcxlicon(mlCaption);
}
break;
                
case 'tiktokstalk': {
  if (!text) return replygcxlicon(`Please provide a TikTok username.`);

  const username = text;
  const apiUrl = `${global.api}stalking/tiktok-user2?apikey=${global.id}&user=${username}`;
  
  try {
    // Fetch TikTok user data
    let res = await fetchJson(apiUrl);
    
    if (!res.status) {
      await XliconBotInc.sendMessage(m.chat, { text: 'âŒ Unable to fetch data. Please try again later.' }, { quoted: m });
      return;
    }

    const user = res.result;
    let txt = `
â”Œâ”€â”€ã€Œ *TIKTOK STALK* ã€
â–¢ *ğŸ”– Name:* ${user.nickname}
â–¢ *ğŸ”– Username:* ${user.username}
â–¢ *ğŸ‘¥ Followers:* ${user.followerCount}
â–¢ *ğŸ«‚ Following:* ${user.followingCount}
â–¢ *ğŸ’– Hearts:* ${user.heartCount}
â–¢ *ğŸ“Œ Description:* ${user.signature || 'No description available.'}
â–¢ *ğŸ”— Link:* https://tiktok.com/${user.username}
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`;

    // Send the message with user profile image
    await XliconBotInc.sendMessage(m.chat, { image: { url: user.avatarLarger }, caption: txt }, { quoted: m });

  } catch (error) {
    console.error('Error fetching TikTok user data:', error.message);
    await XliconBotInc.sendMessage(m.chat, { text: 'âŒ An error occurred while processing the request. Please try again later.' }, { quoted: m });
  }
}
break;

case 'telestalk': {
  if (!text) return replygcxlicon(`*Where is the Telegram Username?*\n_Example:_\n${prefix}${command} ahmmikun`);

  try {
    // Fetch Telegram user data using the provided API
    const apiUrl = `${global.api}stalking/telegram-user?apikey=${global.id}&user=${encodeURIComponent(text)}`;
    let api = await fetchJson(apiUrl);

    // Log the API response for debugging
    console.log('Telegram API Response:', api);

    if (!api || api.status !== 200 || !api.result) {
      console.error('API response is invalid or no results found:', api);
      await XliconBotInc.sendMessage(m.chat, 'âŒ No results found on Telegram. Please try again with a different username.', { quoted: m });
      return;
    }

    // Prepare the response message with user information
    const userInfo = `*ğŸ“± T E L E G R A M - U S E R ğŸ“±*\n\n` +
                     `â€¢ ğŸ‘¤ *Name*: ${api.result.name}\n` +
                     `â€¢ ğŸ†” *Username*: ${api.result.username}\n` +
                     `â€¢ ğŸ“œ *Bio*: ${api.result.bio}\n` +
                     `â€¢ ğŸ”— *Profile Photo*: ${api.result.photo}`;

    // Send the user info to the user
    await XliconBotInc.sendMessage(m.chat, { text: userInfo }, { quoted: m });

    // Send the Telegram user's profile photo
    await XliconBotInc.sendMessage(m.chat, {
      image: { url: api.result.photo },
      caption: `*Profile Photo of ${api.result.name}*`
    }, { quoted: m });

  } catch (error) {
    console.error('Error fetching Telegram data:', error.message);
    await XliconBotInc.sendMessage(m.chat, { text: 'âŒ An error occurred while fetching the Telegram data. Please try again later.' }, { quoted: m });
  }
}
break;


case 'wachannelstalk': {
  if (!text) return replygcxlicon(`*Where is the WhatsApp Channel URL?*\n_Example:_\n${prefix}${command} https://whatsapp.com/channel/0029VaGvk6XId7nHNGfiRs0m`);

  try {
    // Fetch WhatsApp channel data using the provided API
    const apiUrl = `${global.api}stalking/whatsapp-channel?apikey=${global.id}&url=${encodeURIComponent(text)}`;
    let api = await fetchJson(apiUrl);

    // Log the API response for debugging
    console.log('WhatsApp Channel API Response:', api);

    if (!api || api.status !== 200 || !api.result) {
      console.error('API response is invalid or no results found:', api);
      await XliconBotInc.sendMessage(m.chat, 'âŒ No results found on WhatsApp Channel. Please try again with a different URL.', { quoted: m });
      return;
    }

    // Prepare the response message with channel information
    const channelInfo = `*ğŸŒ W H A T S A P P - C H A N N E L ğŸŒ*\n\n` +
                        `â€¢ ğŸ·ï¸ *Title*: ${api.result.title}\n` +
                        `â€¢ ğŸ“œ *Description*: ${api.result.description}\n` +
                        `â€¢ ğŸ‘¥ *Followers*: ${api.result.followers}\n` +
                        `â€¢ ğŸ”— *Channel Link*: ${text}`;

    // Send the channel info to the user
    await XliconBotInc.sendMessage(m.chat, { text: channelInfo }, { quoted: m });

    // Send the WhatsApp channel's image
    await XliconBotInc.sendMessage(m.chat, {
      image: { url: api.result.img },
      caption: `*Channel Image for ${api.result.title}*`
    }, { quoted: m });

  } catch (error) {
    console.error('Error fetching WhatsApp channel data:', error.message);
    await XliconBotInc.sendMessage(m.chat, { text: 'âŒ An error occurred while fetching the WhatsApp channel data. Please try again later.' }, { quoted: m });
  }
}
break;



			case 'tiktokgirl': {
    await XliconStickWait();  // Indicate that the bot is processing the request

    try {
        // Load the list of TikTok videos from the JSON file
        var asupan = JSON.parse(fs.readFileSync('./src/media/tiktokvids/tiktokgirl.json'));
        
        // Select a random TikTok video from the list
        var hasil = pickRandom(asupan);

        // Send the video directly with a caption
        const caption = `ğŸ‘‹ Hi ${m.pushName}\n_*Here is the result of: ${command}*_ ğŸ‰`;


        await XliconBotInc.sendMessage(m.chat, {
            video: { url: hasil.url },
            caption: caption,
            mimetype: 'video/mp4', // Specify the MIME type
        }, { quoted: m });

    } catch (error) {
        // Handle errors gracefully and send a message to the user
        console.error('Error in tiktokgirl command:', error.message);  // Log specific error message
        replygcxlicon('âš ï¸ An error occurred while fetching the TikTok video. Please try again later.');
    }
}
break;

case 'tiktokghea': {
    await XliconStickWait();  // Indicate that the bot is processing the request

    try {
        var gheayubi = JSON.parse(fs.readFileSync('./src/media/tiktokvids/gheayubi.json'));
        var hasil = pickRandom(gheayubi);

        // Prepare and send the video with caption
        const caption = `ğŸ‘‹ Hi ${m.pushName}\n_*Here is the result of: ${command}*_ ğŸ‰`;


        await XliconBotInc.sendMessage(m.chat, {
            video: { url: hasil.url },
            caption: caption,
            mimetype: 'video/mp4', // Specify the MIME type
        }, { quoted: m });

    } catch (error) {
        console.error('Error in tiktokghea command:', error.message);
        replygcxlicon('âš ï¸ An error occurred while fetching the TikTok video. Please try again later.');
    }
}
break;

case 'tiktokbocil': {
    await XliconStickWait();  // Indicate that the bot is processing the request

    try {
        var bocil = JSON.parse(fs.readFileSync('./src/media/tiktokvids/bocil.json'));
        var hasil = pickRandom(bocil);

        // Prepare and send the video with caption
        const caption = `ğŸ‘‹ Hi ${m.pushName}\n_*Here is the result of: ${command}*_ ğŸ‰`;


        await XliconBotInc.sendMessage(m.chat, {
            video: { url: hasil.url },
            caption: caption,
            mimetype: 'video/mp4', // Specify the MIME type
        }, { quoted: m });

    } catch (error) {
        console.error('Error in tiktokbocil command:', error.message);
        replygcxlicon('âš ï¸ An error occurred while fetching the TikTok video. Please try again later.');
    }
}
break;

case 'tiktoknukhty': {
    await XliconStickWait();  // Indicate that the bot is processing the request

    try {
        var ukhty = JSON.parse(fs.readFileSync('./src/media/tiktokvids/ukhty.json'));
        var hasil = pickRandom(ukhty);

        // Prepare and send the video with caption
        const caption = `ğŸ‘‹ Hi ${m.pushName}\n_*Here is the result of: ${command}*_ ğŸ‰`;


        await XliconBotInc.sendMessage(m.chat, {
            video: { url: hasil.url },
            caption: caption,
            mimetype: 'video/mp4', // Specify the MIME type
        }, { quoted: m });

    } catch (error) {
        console.error('Error in tiktoknukhty command:', error.message);
        replygcxlicon('âš ï¸ An error occurred while fetching the TikTok video. Please try again later.');
    }
}
break;

case 'tiktoksantuy': {
    await XliconStickWait();  // Indicate that the bot is processing the request

    try {
        var santuy = JSON.parse(fs.readFileSync('./src/media/tiktokvids/santuy.json'));
        var hasil = pickRandom(santuy);

        // Prepare and send the video with caption
        const caption = `ğŸ‘‹ Hi ${m.pushName}\n_*Here is the result of: ${command}*_ ğŸ‰`;


        await XliconBotInc.sendMessage(m.chat, {
            video: { url: hasil.url },
            caption: caption,
            mimetype: 'video/mp4', // Specify the MIME type
        }, { quoted: m });

    } catch (error) {
        console.error('Error in tiktoksantuy command:', error.message);
        replygcxlicon('âš ï¸ An error occurred while fetching the TikTok video. Please try again later.');
    }
}
break;

case 'tiktokkayes': {
    await XliconStickWait();  // Indicate that the bot is processing the request

    try {
        var kayes = JSON.parse(fs.readFileSync('./src/media/tiktokvids/kayes.json'));
        var hasil = pickRandom(kayes);

        // Prepare and send the video with caption
        const caption = `ğŸ‘‹ Hi ${m.pushName}\n_*Here is the result of: ${command}*_ ğŸ‰`;


        await XliconBotInc.sendMessage(m.chat, {
            video: { url: hasil.url },
            caption: caption,
            mimetype: 'video/mp4', // Specify the MIME type
        }, { quoted: m });

    } catch (error) {
        console.error('Error in tiktokkayes command:', error.message);
        replygcxlicon('âš ï¸ An error occurred while fetching the TikTok video. Please try again later.');
    }
}
break;

case 'tiktokpanrika': {
    await XliconStickWait();  // Indicate that the bot is processing the request

    try {
        var rikagusriani = JSON.parse(fs.readFileSync('./src/media/tiktokvids/panrika.json'));
        var hasil = pickRandom(rikagusriani);

        // Prepare and send the video with caption
        const caption = `ğŸ‘‹ Hi ${m.pushName}\n_*Here is the result of: ${command}*_ ğŸ‰`;


        await XliconBotInc.sendMessage(m.chat, {
            video: { url: hasil.url },
            caption: caption,
            mimetype: 'video/mp4', // Specify the MIME type
        }, { quoted: m });

    } catch (error) {
        console.error('Error in tiktokpanrika command:', error.message);
        replygcxlicon('âš ï¸ An error occurred while fetching the TikTok video. Please try again later.');
    }
}
break;

case 'tiktoknotnot': {
    await XliconStickWait();  // Indicate that the bot is processing the request

    try {
        var notnot = JSON.parse(fs.readFileSync('./src/media/tiktokvids/notnot.json'));
        var hasil = pickRandom(notnot);

        // Prepare and send the video with caption
        const caption = `ğŸ‘‹ Hi ${m.pushName}\n_*Here is the result of: ${command}*_ ğŸ‰`;


        await XliconBotInc.sendMessage(m.chat, {
            video: { url: hasil.url },
            caption: caption,
            mimetype: 'video/mp4', // Specify the MIME type
        }, { quoted: m });

    } catch (error) {
        console.error('Error in tiktoknotnot command:', error.message);
        replygcxlicon('âš ï¸ An error occurred while fetching the TikTok video. Please try again later.');
    }
}
break;
        
        
case 'chinese': {
    await XliconStickWait();  // Indicate that the bot is processing the request

    try {
        var notnot = JSON.parse(fs.readFileSync('./src/media/tiktokpics/china.json'));
        var hasil = pickRandom(notnot);

        // Prepare and send the image with caption
        const caption = `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of: ${command}*_\nğŸ‰ Enjoy the Chinese TikTok pic! ğŸ‡¨ğŸ‡³`;

        await XliconBotInc.sendMessage(m.chat, {
            image: { url: hasil.url },  // Send image instead of video
            caption: caption,
        }, { quoted: m });

    } catch (error) {
        console.error('Error in chinese command:', error.message);
        replygcxlicon('âš ï¸ An error occurred while fetching the TikTok image. Please try again later. ğŸ˜“');
    }
}
break;

case 'hijab': {
    await XliconStickWait();  // Indicate that the bot is processing the request

    try {
        var notnot = JSON.parse(fs.readFileSync('./src/media/tiktokpics/hijab.json'));
        var hasil = pickRandom(notnot);

        // Prepare and send the image with caption
        const caption = `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of: ${command}*_\nğŸ’– Enjoy the beautiful hijab TikTok pic! ğŸ§•`;

        await XliconBotInc.sendMessage(m.chat, {
            image: { url: hasil.url },  // Send image instead of video
            caption: caption,
        }, { quoted: m });

    } catch (error) {
        console.error('Error in hijab command:', error.message);
        replygcxlicon('âš ï¸ An error occurred while fetching the TikTok image. Please try again later. ğŸ˜“');
    }
}
break;

case 'japanese': {
    await XliconStickWait();  // Indicate that the bot is processing the request

    try {
        var notnot = JSON.parse(fs.readFileSync('./src/media/tiktokpics/japan.json'));
        var hasil = pickRandom(notnot);

        // Prepare and send the image with caption
        const caption = `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of: ${command}*_\nğŸ Enjoy the Japanese TikTok pic! ğŸ‡¯ğŸ‡µ`;

        await XliconBotInc.sendMessage(m.chat, {
            image: { url: hasil.url },  // Send image instead of video
            caption: caption,
        }, { quoted: m });

    } catch (error) {
        console.error('Error in japanese command:', error.message);
        replygcxlicon('âš ï¸ An error occurred while fetching the TikTok image. Please try again later. ğŸ˜“');
    }
}
break;

case 'korean': {
    await XliconStickWait();  // Indicate that the bot is processing the request

    try {
        var notnot = JSON.parse(fs.readFileSync('./src/media/tiktokpics/korea.json'));
        var hasil = pickRandom(notnot);

        // Prepare and send the image with caption
        const caption = `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of: ${command}*_\nğŸ‡°ğŸ‡· Enjoy the Korean TikTok pic! ğŸ¶`;

        await XliconBotInc.sendMessage(m.chat, {
            image: { url: hasil.url },  // Send image instead of video
            caption: caption,
        }, { quoted: m });

    } catch (error) {
        console.error('Error in korean command:', error.message);
        replygcxlicon('âš ï¸ An error occurred while fetching the TikTok image. Please try again later. ğŸ˜“');
    }
}
break;

case 'malay': {
    await XliconStickWait();  // Indicate that the bot is processing the request

    try {
        var notnot = JSON.parse(fs.readFileSync('./src/media/tiktokpics/malaysia.json'));
        var hasil = pickRandom(notnot);

        // Prepare and send the image with caption
        const caption = `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of: ${command}*_\nğŸ‡²ğŸ‡¾ Enjoy the Malay TikTok pic! ğŸŒ¸`;

        await XliconBotInc.sendMessage(m.chat, {
            image: { url: hasil.url },  // Send image instead of video
            caption: caption,
        }, { quoted: m });

    } catch (error) {
        console.error('Error in malay command:', error.message);
        replygcxlicon('âš ï¸ An error occurred while fetching the TikTok image. Please try again later. ğŸ˜“');
    }
}
break;

case 'randomgirl': {
    await XliconStickWait();  // Indicate that the bot is processing the request

    try {
        var notnot = JSON.parse(fs.readFileSync('./src/media/tiktokpics/random.json'));
        var hasil = pickRandom(notnot);

        // Prepare and send the image with caption
        const caption = `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of: ${command}*_\nğŸŒŸ Enjoy this random TikTok girl pic! ğŸ’–`;

        await XliconBotInc.sendMessage(m.chat, {
            image: { url: hasil.url },  // Send image instead of video
            caption: caption,
        }, { quoted: m });

    } catch (error) {
        console.error('Error in randomgirl command:', error.message);
        replygcxlicon('âš ï¸ An error occurred while fetching the TikTok image. Please try again later. ğŸ˜“');
    }
}
break;

case 'randomboy': {
    await XliconStickWait();  // Indicate that the bot is processing the request

    try {
        var notnot = JSON.parse(fs.readFileSync('./src/media/tiktokpics/random2.json'));
        var hasil = pickRandom(notnot);

        // Prepare and send the image with caption
        const caption = `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of: ${command}*_\nğŸŒŸ Enjoy this random TikTok boy pic! ğŸ’™`;

        await XliconBotInc.sendMessage(m.chat, {
            image: { url: hasil.url },  // Send image instead of video
            caption: caption,
        }, { quoted: m });

    } catch (error) {
        console.error('Error in randomboy command:', error.message);
        replygcxlicon('âš ï¸ An error occurred while fetching the TikTok image. Please try again later. ğŸ˜“');
    }
}
break;

case 'thai': {
    await XliconStickWait();  // Indicate that the bot is processing the request

    try {
        var notnot = JSON.parse(fs.readFileSync('./src/media/tiktokpics/thailand.json'));
        var hasil = pickRandom(notnot);

        // Prepare and send the image with caption
        const caption = `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of: ${command}*_\nğŸ‡¹ğŸ‡­ Enjoy the Thai TikTok pic! ğŸ€`;

        await XliconBotInc.sendMessage(m.chat, {
            image: { url: hasil.url },  // Send image instead of video
            caption: caption,
        }, { quoted: m });

    } catch (error) {
        console.error('Error in thai command:', error.message);
        replygcxlicon('âš ï¸ An error occurred while fetching the TikTok image. Please try again later. ğŸ˜“');
    }
}
break;

case 'vietnamese': {
    await XliconStickWait();  // Indicate that the bot is processing the request

    try {
        var notnot = JSON.parse(fs.readFileSync('./src/media/tiktokpics/vietnam.json'));
        var hasil = pickRandom(notnot);

        // Prepare and send the image with caption
        const caption = `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of: ${command}*_\nğŸ‡»ğŸ‡³ Enjoy the Vietnamese TikTok pic! ğŸ‹`;

        await XliconBotInc.sendMessage(m.chat, {
            image: { url: hasil.url },  // Send image instead of video
            caption: caption,
        }, { quoted: m });

    } catch (error) {
        console.error('Error in vietnamese command:', error.message);
        replygcxlicon('âš ï¸ An error occurred while fetching the TikTok image. Please try again later. ğŸ˜“');
    }
}
break;

case 'indo': {
    await XliconStickWait();  // Indicate that the bot is processing the request

    try {
        var notnot = JSON.parse(fs.readFileSync('./src/media/tiktokpics/indonesia.json'));
        var hasil = pickRandom(notnot);

        // Prepare and send the image with caption
        const caption = `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of: ${command}*_\nğŸ‡®ğŸ‡© Enjoy the Indonesian TikTok pic! ğŸŒ¸`;

        await XliconBotInc.sendMessage(m.chat, {
            image: { url: hasil.url },  // Send image instead of video
            caption: caption,
        }, { quoted: m });

    } catch (error) {
        console.error('Error in indo command:', error.message);
        replygcxlicon('âš ï¸ An error occurred while fetching the TikTok image. Please try again later. ğŸ˜“');
    }
}
break;

case 'woof':
case '8ball':
case 'goose':
case 'gecg':
case 'feed':
case 'avatar':
case 'fox_girl':
case 'lizard':
case 'meow':{
                axios.get(`https://nekos.life/api/v2/img/${command}`)
.then(({data}) => {
XliconBotInc.sendImageAsSticker(m.chat, data.url, m, { packname: global.packname, author: global.author })
})
}
break

//------------------------------------------------------------------------------------------------//
case 'anime': {
    // Get the anime name from the user's input
    let queryText = args.join(' ');

    // Check if queryText is provided
    if (!queryText) {
        return await XliconBotInc.sendText(m.chat, "âš ï¸ Please provide the name of the anime.");
    }

    // Check if the query includes '-tr' for translation
    const translateFlag = queryText.endsWith('-tr');
    if (translateFlag) {
        queryText = queryText.slice(0, -4).trim(); // Remove the '-tr' from the query
    }

    // Define the API URL with the user's query
    const apiUrl = `https://api.lolhuman.xyz/api/anime?apikey=dcb4198762eb793a386a9c1c&query=${encodeURIComponent(queryText)}`;

    try {
        // Fetch data from the API
        const response = await fetch(apiUrl);
        const data = await response.json();

        if (data.status !== 200 || !data.result || data.result.length === 0) {
            return await XliconBotInc.sendText(m.chat, "âŒ Failed to fetch anime details. Please check the query and try again.");
        }

        const anime = data.result;

        // Extract relevant data with safety checks
        const title = anime.title?.english || anime.title?.romaji || anime.title?.native || 'Unknown Title';
        const description = anime.description || 'No description available.';
        const genres = anime.genres?.join(', ') || 'Unknown';
        const status = anime.status || 'Unknown';
        const episodes = anime.episodes || 'Unknown';
        const duration = anime.duration || 'Unknown';
        const startDate = anime.startDate ? `${anime.startDate.year}-${anime.startDate.month}-${anime.startDate.day}` : 'N/A';
        const endDate = anime.endDate ? `${anime.endDate.year}-${anime.endDate.month}-${anime.endDate.day}` : 'N/A';

        // Delay function to throttle requests
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Translate function with retry logic
        async function translateText(text, targetLang) {
            let retries = 5;
            while (retries > 0) {
                try {
                    await delay(500); // Delay between requests
                    let result = await translate(text, { to: targetLang });
                    return result.text;
                } catch (error) {
                    console.error('Translation error:', error);
                    if (error.message.includes('TooManyRequestsError')) {
                        await delay(10000); // Wait for 10 seconds before retrying
                    } else {
                        return text; // Return original text if translation fails
                    }
                    retries -= 1;
                }
            }
            return text; // Return original text if all retries fail
        }

        // Translate description if needed
        let translatedDescription = description;
        if (translateFlag) {
            translatedDescription = await translateText(description, 'ur');
        }

        // Create the caption with translations and emojis
        const captionText = `*ğŸŒŸ Title:* ${title}

âœ¨ *Genres:* ${genres}
âœ¨ *Status:* ${status}
âœ¨ *Episodes:* ${episodes}
âœ¨ *Duration:* ${duration} minutes per episode
âœ¨ *Start Date:* ${startDate}
âœ¨ *End Date:* ${endDate}

ğŸ“ *Description:* ${translatedDescription}
`.trim();

        // Use the anime cover image URL directly
        const imageUrl = anime.coverImage?.large || 'https://via.placeholder.com/500';

        // Send the message with the image URL and the caption
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: imageUrl },
            caption: captionText,  // caption text with translated description (if applicable)
            mentions: [m.sender]   // Mention the sender
        });

    } catch (error) {
        console.error('API Fetch Error:', error);
        return await XliconBotInc.sendText(m.chat, "âŒ An error occurred while fetching the anime details.");
    }
}
break;


//------------------------------------------------------------------------------------------------//

case 'wallhp': case 'akira': case 'akiyama': case 'ana': case 'art': case 'asuna': case 'ayuzawa': case 'boruto': case 'bts': case 'chiho': case 'chitoge': case 'cosplay': case 'cosplayloli': case 'cosplaysagiri': case 'cyber': case 'deidara': case 'doraemon': case 'elaina': case 'emilia': case 'erza': case 'exo':  case 'gamewallpaper': case 'gremory': case 'hacker': case 'hestia': case 'husbu': case 'inori': case 'islamic': case 'isuzu': case 'itachi': case 'itori': case 'jennie': case 'jiso': case 'justina': case 'kaga': case 'kagura': case 'kakasih': case 'kaori': case 'cartoon': case 'shortquote': case 'keneki': case 'kotori': case 'kurumi': case 'lisa': case 'loli2': case 'madara': case 'megumin': case 'mikasa': case 'mikey': case 'miku': case 'minato': case 'mountain': case 'naruto': case 'nekonime': case 'nezuko': case 'onepiece': case 'pentol': case 'pokemon': case 'programming':  case 'randomnime': case 'randomnime2': case 'rize': case 'rose': case 'sagiri': case 'sakura': case 'sasuke': case 'satanic': case 'shina': case 'shinka': case 'shinomiya': case 'shizuka': case 'shota': case 'space': case 'technology': case 'tejina': case 'toukachan': case 'tsunade': case 'waifu2': case 'yotsuba': case 'yuki': case 'yulibocil': case 'yumeko': {
    await XliconStickWait();  // Indicate that the bot is processing the request

    try {
        let heyy;
        if (/akira/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/akira.json')
if (/akiyama/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/akiyama.json')
if (/ana/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/ana.json')
if (/art/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/art.json')
if (/asuna/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/asuna.json')
if (/ayuzawa/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/ayuzawa.json')
if (/boneka/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/boneka.json')
if (/boruto/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/boruto.json')
if (/bts/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/bts.json')
if (/cecan/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/cecan.json')
if (/chiho/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/chiho.json')
if (/chitoge/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/chitoge.json')
if (/cogan/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/cogan.json')
if (/cosplay/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/cosplay.json')
if (/cosplayloli/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/cosplayloli.json')
if (/cosplaysagiri/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/cosplaysagiri.json')
if (/cyber/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/cyber.json')
if (/deidara/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/deidara.json')
if (/doraemon/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/doraemon.json')
if (/eba/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/eba.json')
if (/elaina/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/elaina.json')
if (/emilia/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/emilia.json')
if (/erza/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/erza.json')
if (/exo/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/exo.json')
if (/femdom/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/femdom.json')
if (/freefire/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/freefire.json')
if (/gamewallpaper/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/gamewallpaper.json')
if (/glasses/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/glasses.json')
if (/gremory/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/gremory.json')
if (/hacker/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/hekel.json')
if (/hestia/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/hestia.json')
if (/husbu/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/husbu.json')
if (/inori/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/inori.json')
if (/islamic/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/islamic.json')
if (/isuzu/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/isuzu.json')
if (/itachi/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/itachi.json')
if (/itori/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/itori.json')
if (/jennie/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/jeni.json')
if (/jiso/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/jiso.json')
if (/justina/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/justina.json')
if (/kaga/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/kaga.json')
if (/kagura/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/kagura.json')
if (/kakasih/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/kakasih.json')
if (/kaori/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/kaori.json')
if (/cartoon/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/kartun.json')
if (/shortquote/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/katakata.json')
if (/keneki/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/keneki.json')
if (/kotori/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/kotori.json')
if (/kpop/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/kpop.json')
if (/kucing/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/kucing.json')
if (/kurumi/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/kurumi.json')
if (/lisa/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/lisa.json')
if (/loli2/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/loli.json')
if (/madara/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/madara.json')
if (/megumin/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/megumin.json')
if (/mikasa/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/mikasa.json')
if (/mikey/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/mikey.json')
if (/miku/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/miku.json')
if (/minato/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/minato.json')
if (/mobile/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/mobil.json')
if (/motor/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/motor.json')
if (/mountain/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/mountain.json')
if (/naruto/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/naruto.json')
if (/nekonime/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/nekonime.json')
if (/nezuko/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/nezuko.json')
if (/onepiece/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/onepiece.json')
if (/pentol/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/pentol.json')
if (/pokemon/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/pokemon.json')
if (/profil/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/profil.json')
if (/progamming/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/programming.json')
if (/pubg/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/pubg.json')
if (/randblackpink/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/randblackpink.json')
if (/randomnime/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/randomnime.json')
if (/randomnime2/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/randomnime2.json')
if (/rize/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/rize.json')
if (/rose/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/rose.json')
if (/ryujin/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/ryujin.json')
if (/sagiri/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/sagiri.json')
if (/sakura/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/sakura.json')
if (/sasuke/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/sasuke.json')
if (/satanic/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/satanic.json')
if (/shina/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/shina.json')
if (/shinka/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/shinka.json')
if (/shinomiya/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/shinomiya.json')
if (/shizuka/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/shizuka.json')
if (/shota/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/shota.json')
if (/space/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/tatasurya.json')
if (/technology/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/technology.json')
if (/tejina/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/tejina.json')
if (/toukachan/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/toukachan.json')
if (/tsunade/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/tsunade.json')
if (/waifu2/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/waifu.json')
if (/wallhp/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/wallhp.json')
if (/wallml/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/wallml.json')
if (/wallmlnime/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/wallnime.json')
if (/yotsuba/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/yotsuba.json')
if (/yuki/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/yuki.json')
if (/yulibocil/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/yulibocil.json')
if (/yumeko/.test(command)) heyy = await fetchJson('https://raw.githubusercontent.com/DGXeon/XeonMedia/master/yumeko.json')

        let yeha = heyy[Math.floor(Math.random() * heyy.length)];

        // Prepare and send the image with caption
        const caption = `Hi ${m.pushName} ğŸ‘‹\n_*Here is the result of: ${command}*_`;
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: yeha },
            caption: caption,
        }, { quoted: m });

    } catch (error) {
        console.error('Error in wallhp command:', error.message);
        replygcxlicon('âš ï¸ An error occurred while fetching the image. Please try again later. ğŸ˜“');
    }
}
break;


		case 'translate': {
    if (!q) return replygcxlicon(`*â“ Where is the text?*\n\nğŸ“Œ *Example usage:*\n*${prefix + command} <language id> <text>*\n*${prefix + command} ja yo wassup*`);
        await XliconStickWait()    

    const defaultLang = 'en';
    let lang = args[0];
    let text = args.slice(1).join(' ');

    if ((args[0] || '').length !== 2) {
        lang = defaultLang;
        text = args.join(' ');
    }

    if (!text && m.quoted && m.quoted.text) text = m.quoted.text;

    try {
        let result = await translate(text, { to: lang, autoCorrect: true }).catch(_ => null);
        if (!result || !result.text) return replygcxlicon('âš ï¸ Translation failed. Please try again.');

        const caption = `ğŸŒ *Translated Text:* ${result.text}\n\n*ğŸ”¤ From:* ${text}\n*ğŸ”  To:* ${lang}`;
        const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg';

        // Send the message with the image URL directly
        await XliconBotInc.sendMessage(m.chat, {
            image: { url: imageUrl },
            caption: caption,
            mentions: [m.sender]
        }, { quoted: m });

    } catch (e) {
        console.error('Error in translation:', e);
        replygcxlicon('âš ï¸ An error occurred. Please try again later.');
    }
}
break;


    case 'coffee': case 'kopi': {
    await XliconStickWait()    
    try {
        // Get a random coffee image
        const imageUrl = 'https://coffee.alexflipnote.dev/random';
        const imageBuffer = await axios.get(imageUrl, { responseType: 'arraybuffer' }).then(res => Buffer.from(res.data));

        // Create the message content with emojis
        const caption = `â˜• Hi ${m.pushName}!\n_*Here is the result of: ${command}*_`;

        // Send the message with the coffee image
        await XliconBotInc.sendMessage(m.chat, {
            image: imageBuffer,
            caption: caption,
            mentions: [m.sender]
        });

    } catch (e) {
        console.error('Error:', e);
        return replygcxlicon('â— *Error:* Something went wrong! âš ï¸');
    }
}
break;

            case 'wallpaper': {
    if (!text) return replygcxlicon('Enter Query Title');

    await XliconStickWait();
    let { wallpaper } = require('./lib/scraper');
    anuwallpep = await wallpaper(text);
    let result = anuwallpep[Math.floor(Math.random() * anuwallpep.length)];

    const reply = `Hi ${m.pushName}\n_*Here is the result of ${text}*_\n\n`
        + `ğŸŒŸ *Title:* ${result.title}\n`
        + `ğŸ“ *Category:* ${result.type}\n`
        + `ğŸ“„ *Detail:* ${result.source}\n`
        + `ğŸ”— *Media URL:* ${result.image[2] || result.image[1] || result.image[0]}`;

    await XliconBotInc.sendMessage(m.chat, {
        image: { url: result.image[0] },
        caption: reply,
        mentions: [m.sender]
    });
}
break;

            case 'wikimedia': {
    if (!text) return replygcxlicon('Enter Query Title');

    await XliconStickWait();
    let { wikimedia } = require('./lib/scraper');
    let anumedia = await wikimedia(text);
    let result = anumedia[Math.floor(Math.random() * anumedia.length)];

    // Formatting the reply message
    const replyMessage = `Hi ${m.pushName}\n\n`
        + `ğŸ” *Title:* ${result.title}\n`
        + `ğŸŒ *Source:* ${result.source}\n`
        + `ğŸ“¸ *Media URL:* ${result.image}`;

    // Sending the response directly with image and text
    await XliconBotInc.sendMessage(m.chat, {
        image: { url: result.image },
        caption: replyMessage,
        mentions: [m.sender]
    });

}
break;

    case 'aesthetic': {
    await XliconStickWait();
    var notnot = JSON.parse(fs.readFileSync('./src/media/randompics/aesthetic.json'));
    var hasil = pickRandom(notnot);

    // Formatting the reply message with emojis
    const replyMessage = `ğŸŒŸ Hi ${m.pushName} ğŸŒŸ\n\n`
        + `âœ¨ *Here is the result of: ${command}* âœ¨\n\n`
        + `ğŸ–¼ï¸ *Image URL:* ${hasil.url}\n`
        + `ğŸ’¡ *Enjoy the aesthetic!*`;

    // Sending the image and caption directly
    await XliconBotInc.sendMessage(m.chat, {
        image: { url: hasil.url },
        caption: replyMessage,
        mentions: [m.sender]
    });

}
break;

			case 'ebinary': {
if (!q) return replygcxlicon(`Send/reply text with captions ${prefix + command}`)
await XliconStickWait()                
let { eBinary } = require('./lib/binary')
let eb = await eBinary(`${q}`)
replygcxlicon(eb)
}
break
        
case 'dbinary': {
if (!q) return replygcxlicon(`Send/reply text with captions ${prefix + command}`)
await XliconStickWait()    
let { dBinary } = require('./lib/binary')
let db = await dBinary(`${q}`)
replygcxlicon(db)
}
break
        
			  case 'volaudio': {
if (!args.join(" ")) return replygcxlicon(`Example: ${prefix + command} 10`)
await XliconStickWait()                  
media = await XliconBotInc.downloadAndSaveMediaMessage(quoted, "volume")
rname = getRandom('.mp3')
exec(`ffmpeg -i ${media} -filter:a volume=${args[0]} ${rname}`, (err, stderr, stdout) => {
fs.unlinkSync(media)
if (err) return replygcxlicon('Error!')
jadie = fs.readFileSync(rname)
XliconBotInc.sendMessage(m.chat, {audio:jadie, mimetype: 'audio/mp4', ptt: true}, {quoted: m})
fs.unlinkSync(rname)
})
}
break
        
case 'volvideo': {
if (!args.join(" ")) return replygcxlicon(`Example: ${prefix + command} 10`)
await XliconStickWait()    
media = await XliconBotInc.downloadAndSaveMediaMessage(quoted, "volume")
rname = getRandom('.mp4')
exec(`ffmpeg -i ${media} -filter:a volume=${args[0]} ${rname}`, (err, stderr, stdout) => {
fs.unlinkSync(media)
if (err) return replygcxlicon('Error!')
jadie = fs.readFileSync(rname)
XliconBotInc.sendMessage(m.chat, {video:jadie, mimetype: 'video/mp4'}, {quoted: m})
fs.unlinkSync(rname)
})
}
break
        
			case 'emojimix': {
                let [emoji1, emoji2] = text.split`+`
                if (!emoji1) return replygcxlicon(`Example : ${prefix + command} ğŸ˜…+ğŸ¤”`)
                if (!emoji2) return replygcxlicon(`Example : ${prefix + command} ğŸ˜…+ğŸ¤”`)
                await XliconStickWait()
                let anu = await fetchJson(`https://tenor.googleapis.com/v2/featured?key=AIzaSyAyimkuYQYF_FXVALexPuGQctUWRURdCYQ&contentfilter=high&media_filter=png_transparent&component=proactive&collection=emoji_kitchen_v5&q=${encodeURIComponent(emoji1)}_${encodeURIComponent(emoji2)}`)
                for (let res of anu.results) {
                    let encmedia = await XliconBotInc.sendImageAsSticker(m.chat, res.url, m, {
                        packname: global.packname,
                        author: global.author,
                        categories: res.tags
                    })
                }
            }
            break
        
			case 'bass': case 'blown': case 'deep': case 'earrape': case 'fast': case 'fat': case 'nightcore': case 'reverse': case 'robot': case 'slow': case 'smooth': case 'squirrel':
                try {
                let set
                if (/bass/.test(command)) set = '-af equalizer=f=54:width_type=o:width=2:g=20'
                if (/blown/.test(command)) set = '-af acrusher=.1:1:64:0:log'
                if (/deep/.test(command)) set = '-af atempo=4/4,asetrate=44500*2/3'
                if (/earrape/.test(command)) set = '-af volume=12'
                if (/fast/.test(command)) set = '-filter:a "atempo=1.63,asetrate=44100"'
                if (/fat/.test(command)) set = '-filter:a "atempo=1.6,asetrate=22100"'
                if (/nightcore/.test(command)) set = '-filter:a atempo=1.06,asetrate=44100*1.25'
                if (/reverse/.test(command)) set = '-filter_complex "areverse"'
                if (/robot/.test(command)) set = '-filter_complex "afftfilt=real=\'hypot(re,im)*sin(0)\':imag=\'hypot(re,im)*cos(0)\':win_size=512:overlap=0.75"'
                if (/slow/.test(command)) set = '-filter:a "atempo=0.7,asetrate=44100"'
                if (/smooth/.test(command)) set = '-filter:v "minterpolate=\'mi_mode=mci:mc_mode=aobmc:vsbmc=1:fps=120\'"'
                if (/squirrel/.test(command)) set = '-filter:a "atempo=0.5,asetrate=65100"'
                if (/audio/.test(mime)) {
                await XliconStickWait()
                let media = await XliconBotInc.downloadAndSaveMediaMessage(quoted)
                let ran = getRandom('.mp3')
                exec(`ffmpeg -i ${media} ${set} ${ran}`, (err, stderr, stdout) => {
                fs.unlinkSync(media)
                if (err) return replygcxlicon(err)
                let buff = fs.readFileSync(ran)
                XliconBotInc.sendMessage(m.chat, { audio: buff, mimetype: 'audio/mpeg' }, { quoted : m })
                fs.unlinkSync(ran)
                })
                } else replygcxlicon(`Reply to the audio you want to change with a caption *${prefix + command}*`)
                } catch (e) {
                replygcxlicon(e)
                }
                break
        
			case 'toonce':
            case 'toviewonce': {
                if (!m.quoted) return replygcxlicon(`Reply Image/Video`)
                await XliconStickWait()
                if (/image/.test(mime)) {
                    anuan = await XliconBotInc.downloadAndSaveMediaMessage(quoted)
                    XliconBotInc.sendMessage(m.chat, {
                        image: {
                            url: anuan
                        },
                        caption: mess.done,
                        fileLength: "999",
                        viewOnce: true
                    }, {
                        quoted: m
                    })
                } else if (/video/.test(mime)) {
                    anuanuan = await XliconBotInc.downloadAndSaveMediaMessage(quoted)
                    XliconBotInc.sendMessage(m.chat, {
                        video: {
                            url: anuanuan
                        },
                        caption: mess.done,
                        fileLength: "99999999",
                        viewOnce: true
                    }, {
                        quoted: m
                    })
                } else if (/audio/.test(mime)) {
                   bebasap = await XliconBotInc.downloadAndSaveMediaMessage(quoted)
                   XliconBotInc.sendMessage(m.chat, {
                     audio: {
                        url: bebasap
                     },
                     mimetype: 'audio/mpeg',
                     ptt: true,
                     viewOnce: true
                   })
                }
            }
        
            break
        
        
			case 'fliptext': {
                if (args.length < 1) return replygcxlicon(`Example:\n${prefix}fliptext dgxlicon`)
                quere = args.join(" ")
                flipe = quere.split('').reverse().join('')
                replygcxlicon(`\`\`\`ã€Œ FLIP TEXT ã€\`\`\`\n*â€¢> Normal :*\n${quere}\n*â€¢> Flip :*\n${flipe}`)
            }
            break
        
			case 'style': case 'styletext': {
		if (!text) return replygcxlicon('Enter Query text!')
                let anu = await styletext(text)
                let teks = `Style Text From ${text}\n\n`
                for (let i of anu) {
                    teks += `${themeemoji} *${i.name}* : ${i.result}\n\n`
                }
                replygcxlicon(teks)
	    }
	    break
        
			case 'obfus': case 'obfuscate':{
if (!text) return replygcxlicon(`Example ${prefix+command} const xliconbot = require('baileys')`)
await XliconStickWait()                
try {
let meg = await obfus(text)
replygcxlicon(`Success
${meg.result}`)
} catch {
	replygcxlicon(`Use the command properly\nExample ${prefix+command} const xliconbot = require('baileys')`)
}
}
break
        
        
			case 'autodownload': case 'autodl': {
    if (!XliconTheCreator) return XliconStickOwner();
await XliconStickWait()
    if (q == 'on') {
        db.settings[botNumber].autodownload = true;
        return replygcxlicon(`Successfully changed Auto Download to ${q} âœ…`);
    } else if (q == 'off') {
        db.settings[botNumber].autodownload = false;
        return replygcxlicon(`Successfully changed Auto Download to ${q} âŒ`);
    } else {
       
        const replyMessage = `Hi ${m.pushName},\n\nPlease choose to *${command}*:\n\n`
            + `âœ… *Enable Auto Download*\nâŒ *Disable Auto Download*`;

        return replygcxlicon(replyMessage);
    }
}
break;

			case 'weather':{
if (!text) return replygcxlicon('What location?')
await XliconStickWait()                
            let wdata = await axios.get(
                `https://api.openweathermap.org/data/2.5/weather?q=${text}&units=metric&appid=060a6bcfa19809c2cd4d97a212b19273&language=en`
            );
            let textw = "";
            textw += `ğŸŒ *Weather Report for ${text}*\n\n`;
            textw += `ğŸŒ¤ï¸ *Weather:* ${wdata.data.weather[0].main}\n`;
            textw += `ğŸŒ¥ï¸ *Description:* ${wdata.data.weather[0].description}\n`;
            textw += `ğŸŒ¡ï¸ *Avg Temp:* ${wdata.data.main.temp}Â°C\n`;
            textw += `ğŸ¤— *Feels Like:* ${wdata.data.main.feels_like}Â°C\n`;
            textw += `ğŸŒ¬ï¸ *Pressure:* ${wdata.data.main.pressure} hPa\n`;
            textw += `ğŸ’§ *Humidity:* ${wdata.data.main.humidity}%\n`;
            textw += `ğŸƒ *Wind Speed:* ${wdata.data.wind.speed} m/s\n`;
            textw += `ğŸ—ºï¸ *Latitude:* ${wdata.data.coord.lat}\n`;
            textw += `ğŸ—ºï¸ *Longitude:* ${wdata.data.coord.lon}\n`;
            textw += `ğŸ³ï¸ *Country:* ${wdata.data.sys.country}\n`;
            
           XliconBotInc.sendMessage(
                m.chat, {
                    text: textw,
                }, {
                    quoted: m,
                }
           )
           }
           break
        
        
           case 'happymod':{
if (!q) return replygcxlicon(`Example ${prefix+command} Sufway surfer mod`)
await XliconStickWait()
let kat = await scp2.happymod(q)
replygcxlicon(util.format(kat))
}
break
        
        
case 'gdrive': {
  if (!args[0]) return replygcxlicon(`âŒ *Please provide a Google Drive link!*`);

  await XliconStickWait();

  const fg = require('api-dylux');
  try {
    // Fetch Google Drive file details using the API
    const apiUrl = `${global.api}downloader/gdrive?apikey=${global.id}&url=${encodeURIComponent(args[0])}`;
    let res = await fetch(apiUrl);
    let apiResponse = await res.json();

    if (apiResponse.status !== 200 || !apiResponse.result) {
      return replygcxlicon('âŒ *Failed to fetch data from Google Drive link.* Please check the URL and try again.');
    }

    // Extract file details from API response
    const { fileName, fileSize, mimetype, downloadUrl } = apiResponse.result;

    // Determine the type of file and send accordingly
    if (mimetype.includes('image')) {
      // Send as an image
      await XliconBotInc.sendMessage(m.chat, {
        image: { url: downloadUrl },
        caption: `ğŸ–¼ *Image Name:* ${fileName}\nğŸ—‚ *Size:* ${fileSize}\nğŸ“¥ *Download Link:* ${downloadUrl}`
      });
    } else if (mimetype.includes('video')) {
      // Send as a video
      await XliconBotInc.sendMessage(m.chat, {
        video: { url: downloadUrl },
        caption: `ğŸ¬ *Video Name:* ${fileName}\nğŸ—‚ *Size:* ${fileSize}\nğŸ“¥ *Download Link:* ${downloadUrl}`
      });
    } else if (mimetype.includes('application')) {
      // Send as a document (for file types like PDF, DOC, etc.)
      await XliconBotInc.sendMessage(m.chat, {
        document: { url: downloadUrl },
        fileName: fileName,
        mimetype: mimetype,
        caption: `ğŸ“„ *File Name:* ${fileName}\nğŸ—‚ *Size:* ${fileSize}\nğŸ“¥ *Download Link:* ${downloadUrl}`
      });
    } else {
      // Default for other file types (this could be further customized)
      await XliconBotInc.sendMessage(m.chat, {
        document: { url: downloadUrl },
        fileName: fileName,
        mimetype: mimetype,
        caption: `ğŸ“‚ *File Name:* ${fileName}\nğŸ—‚ *Size:* ${fileSize}\nğŸ“¥ *Download Link:* ${downloadUrl}`
      });
    }
  } catch (error) {
    console.error('Error fetching Google Drive data:', error.message);
    return replygcxlicon('âŒ *An error occurred while processing the link. Please check the URL and try again.*');
  }
}
break;
        
        
           case 'git': case 'gitclone':
if (!args[0]) return replygcxlicon(`Where is the link?\nExample :\n${prefix}${command} https://github.com/salmanytofficial/XliconMedia`)
if (!isUrl(args[0]) && !args[0].includes('github.com')) return replygcxlicon(`Link invalid!!`)
await XliconStickWait()        
let regex1 = /(?:https|git)(?::\/\/|@)github\.com[\/:]([^\/:]+)\/(.+)/i
    let [, user, repo] = args[0].match(regex1) || []
    repo = repo.replace(/.git$/, '')
    let url = `https://api.github.com/repos/${user}/${repo}/zipball`
    let filename = (await fetch(url, {method: 'HEAD'})).headers.get('content-disposition').match(/attachment; filename=(.*)/)[1]
    XliconBotInc.sendMessage(m.chat, { document: { url: url }, fileName: filename+'.zip', mimetype: 'application/zip' }, { quoted: m }).catch((err) => replygcxlicon(mess.error))
break
        

case 'spotify': {
  if (!text) return replygcxlicon(`*Where is the Song Name?*\n_Example :_\n${prefix}${command} Metamorphosis`)
await XliconStickWait()
  try {
    // Fetch Spotify search results
    let api = await fetchJson(`https://api.junn4.my.id/search/spotify?query=${text}`);
    
    if (!api.data || api.data.length === 0) {
      await XliconBotInc.sendMessage(m.chat, 'âŒ No results found on Spotify. Please try again with a different query.', { quoted: m });
      return;
    }

    // Prepare the response message with song information
    const songInfo = `*ğŸ¶ S P O T I F Y - D L ğŸ¶*

â€¢ ğŸµ *Title*: ${api.data[0].title}
â€¢ â±ï¸ *Duration*: ${api.data[0].duration}
â€¢ â­ *Popularity*: ${api.data[0].popularity}
â€¢ ğŸ”— *Url*: ${api.data[0].url}`;

    // Send the song info to the user
    await XliconBotInc.sendMessage(m.chat, { text: songInfo }, { quoted: m });

    // Fetch the Spotify song download link
    let spodl = await fetchJson(`https://api.junn4.my.id/download/spotify?url=${api.data[0].url}`);
    const spoDl = spodl.data.download;

    // Send the Spotify song as an audio message with additional context (external ad reply)
    await XliconBotInc.sendMessage(m.chat, {
      audio: { url: spoDl },
      mimetype: 'audio/mpeg',
      contextInfo: {
        externalAdReply: {
          title: `ğŸµ - sá´˜á´á´›ÉªÒ“Ê -`,
          body: api.data[0].title,
          thumbnailUrl: spodl.data.image, // Use the song's album image as thumbnail
          sourceUrl: global.sourceurl || spodl.data.url, // URL to the source (you can customize this)
          mediaType: 2,
          showAdAttribution: true,
          renderLargerThumbnail: true
        }
      }
    }, { quoted: m });

  } catch (error) {
    console.error('Error fetching Spotify data:', error);
    await XliconBotInc.sendMessage(m.chat, { text: 'âŒ An error occurred while fetching the Spotify data. Please try again later.' }, { quoted: m });
  }
}
break;
        				

case 'soundcloud': {
  if (!text) return replygcxlicon(`*Where is the Song Name?*\n_Example:_\n${prefix}${command} Metamorphosis`);
await XliconStickWait()
  try {
    // Fetch SoundCloud search results using your API
    const apiUrl = `${global.api}downloader/sound-cloud?apikey=${global.id}&url=${encodeURIComponent(text)}`;
    let api = await fetchJson(apiUrl);

    // Log the API response for debugging
    console.log('SoundCloud API Response:', api);

    if (!api || api.status !== 200 || !api.result) {
      console.error('API response is invalid or no results found:', api);
      await XliconBotInc.sendMessage(m.chat, 'âŒ No results found on SoundCloud. Please try again with a different query.', { quoted: m });
      return;
    }

    // Prepare the response message with song information
    const songInfo = `*ğŸµ S O U N D C L O U D ğŸµ*\n\n` +
                     `â€¢ ğŸµ *Title*: ${api.result.title}\n` +
                     `â€¢ â±ï¸ *Duration*: ${api.result.duration}\n` +
                     `â€¢ ğŸµ *Quality*: ${api.result.quality}\n` +
                     `â€¢ ğŸ”— *Download Link*: [Click Here](${api.result.dl_url})`;

    // Send the song info to the user
    await XliconBotInc.sendMessage(m.chat, { text: songInfo }, { quoted: m });

    // Check if the download URL exists and is valid
    const downloadUrl = api.result.dl_url;
    if (!downloadUrl || !downloadUrl.startsWith('https://')) {
      console.error('Invalid download URL:', downloadUrl);
      await XliconBotInc.sendMessage(m.chat, 'âŒ No download link found or URL is invalid. Please try again.', { quoted: m });
      return;
    }

    // Log the download URL for debugging
    console.log('Download URL:', downloadUrl);

    // Fetch the audio file
    const audioResponse = await fetch(downloadUrl);
    if (!audioResponse.ok) {
      throw new Error(`Failed to fetch audio. Status: ${audioResponse.status}`);
    }

    const audioBuffer = await audioResponse.buffer();
    if (!audioBuffer || audioBuffer.length === 0) {
      await XliconBotInc.sendMessage(m.chat, 'âŒ Failed to fetch audio. The file might be empty or inaccessible.', { quoted: m });
      return;
    }

    // Send the SoundCloud song as an audio message with additional context (external ad reply)
    await XliconBotInc.sendMessage(m.chat, {
      audio: { buffer: audioBuffer },
      mimetype: 'audio/mpeg',
      contextInfo: {
        externalAdReply: {
          title: `ğŸµ - sá´á´œÉ´á´…á´„ÊŸá´á´œá´… -`,
          body: api.result.title,
          thumbnailUrl: api.result.thumb, // Use the song's thumbnail image
          sourceUrl: downloadUrl, // URL to the download link
          mediaType: 2,
          showAdAttribution: true,
          renderLargerThumbnail: true
        }
      }
    }, { quoted: m });

  } catch (error) {
    console.error('Error fetching SoundCloud data:', error.message);
    await XliconBotInc.sendMessage(m.chat, { text: 'âŒ An error occurred while fetching the SoundCloud data. Please try again later.' }, { quoted: m });
  }
}
break;
        

	case 'mediafire': {
  if (!args[0]) return replygcxlicon(`Enter the MediaFire link next to the command`);
  if (!args[0].match(/mediafire/gi)) return replygcxlicon(`Link incorrect`);
await XliconStickWait()
  const { mediafiredl } = require('@bochilteam/scraper');
  let full = /f$/i.test(command);
  let u = /https?:\/\//.test(args[0]) ? args[0] : 'https://' + args[0];

  // Notify the user that the download is starting
  replygcxlicon(`â³ *Downloading file, please wait...*`);

  try {
    let res = await mediafiredl(args[0]);
    let { url, url2, filename, ext, aploud, filesize, filesizeH } = res;
    
    let caption = `
   â‰¡ *MEDIAFIRE*

  â–¢ *Filename:* ${filename}
  â–¢ *Size:* ${filesizeH}
  â–¢ *Extension:* ${ext}
  â–¢ *Uploaded:* ${aploud}
  `.trim();

    // Send the file to the chat
    await XliconBotInc.sendMessage(m.chat, { document: { url: url }, fileName: filename, mimetype: ext }, { quoted: m });
    
    // Notify the user that the download is complete
    return replygcxlicon(`âœ… *Download complete!* ğŸ‰\n\n${caption}`);
  } catch (error) {
    console.error(`Error during MediaFire download: ${error.message}`);
    return replygcxlicon(`âŒ *Failed to download the file. Please try again later.*`);
  }
}
break;
             
   
case 'mediafire2': {
  if (!args[0]) return replygcxlicon(`ğŸš« *Please provide a MediaFire link next to the command!*`);
  if (!args[0].match(/mediafire/gi)) return replygcxlicon(`âŒ *Invalid link! Please provide a valid MediaFire link.*`);

  await XliconStickWait();

  // Construct the API URL
  const apiUrl = `https://bk9.fun/download/mediafire?url=${encodeURIComponent(args[0])}`;

  try {
    // Notify the user that the process is starting
    replygcxlicon(`â³ *Fetching file details, please wait...*`);

    // Fetch the API response
    const res = await fetch(apiUrl);
    const api_response = await res.json();

    // Check if the response is valid
    if (api_response.status && api_response.BK9) {
      const { link, alternativeUrl, name, mime, uploaded, size } = api_response.BK9;

      // Test the primary link
      const primaryLinkResponse = await fetch(link);
      let finalLink = link;

      // If the primary link fails, use the alternative link
      if (!primaryLinkResponse.ok) {
        console.warn('Primary link failed, switching to alternative link.');
        const alternativeLinkResponse = await fetch(alternativeUrl);
        if (alternativeLinkResponse.ok) {
          finalLink = alternativeUrl;
        } else {
          throw new Error('Both primary and alternative links failed.');
        }
      }

      const caption = `
ğŸ“‚ *MEDIAFIRE FILE DETAILS*
  
ğŸ“„ *Filename:* ${name}
ğŸ“ *Size:* ${size}
ğŸ“‚ *Extension:* ${mime}
ğŸ“… *Uploaded On:* ${uploaded}
      `.trim();

      // Send the file
      await XliconBotInc.sendMessage(m.chat, {
        document: { url: finalLink },
        fileName: name,
        mimetype: `application/${mime.toLowerCase()}`,
      }, { quoted: m });

      // Notify the user that the download is complete
      return replygcxlicon(`âœ… *Download Complete!* ğŸ‰\n\n${caption}`);
    }

    // Handle cases where the response does not contain the expected data
    return replygcxlicon(`âŒ *Failed to fetch the file details. Please check the link or try again later.*`);

  } catch (error) {
    console.error('Error fetching MediaFire data:', error.message);
    return replygcxlicon(`âš ï¸ *An error occurred while processing your request. Please try again later.*`);
  }
}
break;
              
                
       

			case 'remini': {
  if (!quoted) return replygcxlicon(`Where is the picture? ğŸ“¸`);
    if (!/image/.test(mime)) return replygcxlicon(`Send/Reply Photos With Captions ${prefix + command}`);

    await XliconStickWait();
    const { remini } = require('./lib/remini');
    let media = await quoted.download();
    let proses = await remini(media, "enhance");

    const replyMessage = `Hi ${m.pushName},\n_*Here is the result of: ${command}*_\n\n` +
                         `ğŸ“¸ *Enhanced Image*`;

    // Send the enhanced image
    await XliconBotInc.sendMessage(m.chat, {
        image: proses,
        caption: replyMessage,
        mentions: [m.sender]
    });
}
break;
    
			case 'imdb':
if (!text) return replygcxlicon(`_Name a Series or movie`)
await XliconStickWait()
            let fids = await axios.get(`http://www.omdbapi.com/?apikey=742b2d09&t=${text}&plot=full`)
            let imdbt = ""
            console.log(fids.data)
            imdbt += "âšâšâšâšâšâšâšâšâšâšâšâšâšâšâšâš\n" + " ``` IMDB SEARCH```\n" + "âšâšâšâšâšâšâšâšâšâšâšâšâšâšâšâš\n"
            imdbt += "ğŸ¬Title      : " + fids.data.Title + "\n"
            imdbt += "ğŸ“…Year       : " + fids.data.Year + "\n"
            imdbt += "â­Rated      : " + fids.data.Rated + "\n"
            imdbt += "ğŸ“†Released   : " + fids.data.Released + "\n"
            imdbt += "â³Runtime    : " + fids.data.Runtime + "\n"
            imdbt += "ğŸŒ€Genre      : " + fids.data.Genre + "\n"
            imdbt += "ğŸ‘¨ğŸ»â€ğŸ’»Director   : " + fids.data.Director + "\n"
            imdbt += "âœWriter     : " + fids.data.Writer + "\n"
            imdbt += "ğŸ‘¨Actors     : " + fids.data.Actors + "\n"
            imdbt += "ğŸ“ƒPlot       : " + fids.data.Plot + "\n"
            imdbt += "ğŸŒLanguage   : " + fids.data.Language + "\n"
            imdbt += "ğŸŒCountry    : " + fids.data.Country + "\n"
            imdbt += "ğŸ–ï¸Awards     : " + fids.data.Awards + "\n"
            imdbt += "ğŸ“¦BoxOffice  : " + fids.data.BoxOffice + "\n"
            imdbt += "ğŸ™ï¸Production : " + fids.data.Production + "\n"
            imdbt += "ğŸŒŸimdbRating : " + fids.data.imdbRating + "\n"
            imdbt += "âœ…imdbVotes  : " + fids.data.imdbVotes + ""
           XliconBotInc.sendMessage(m.chat, {
                image: {
                    url: fids.data.Poster,
                },
                caption: imdbt,
            }, {
                quoted: m,
            })
            break
        
        
     case 'itunes': {
  if (!text) return replygcxlicon('Please provide a song name ğŸ¶');
await XliconStickWait()
  try {
    let res = await fetch(`https://api.popcat.xyz/itunes?q=${encodeURIComponent(text)}`);
    if (!res.ok) {
      throw new Error(`API request failed with status ${res.status}`);
    }
    let json = await res.json();
    console.log('JSON response:', json);

    let songInfo = 
    `*Song Information* ğŸµ\n
â€¢ *Name:* ${json.name}\n
â€¢ *Artist:* ${json.artist}\n
â€¢ *Album:* ${json.album}\n
â€¢ *Release Date:* ${json.release_date}\n
â€¢ *Price:* ${json.price} ğŸ’²\n
â€¢ *Length:* ${json.length} â³\n
â€¢ *Genre:* ${json.genre}\n
â€¢ *URL:* ${json.url}`;

    // Check if thumbnail is present, then send it with songInfo as caption
    if (json.thumbnail) {
      let imageMessage = await prepareWAMessageMedia({ image: { url: json.thumbnail } }, { upload: XliconBotInc.waUploadToServer });
      await XliconBotInc.sendMessage(m.chat, { image: { url: json.thumbnail }, caption: songInfo }, { quoted: m });
    } else {
      replygcxlicon(songInfo);
    }
  } catch (error) {
    console.error(error);
    replygcxlicon('An error occurred while fetching the song details ğŸ˜');
  }
}
break;

            case 'lyrics': {
  if (!text) return replygcxlicon(`What lyrics are you looking for? ğŸ¶\nExample usage: ${prefix}lyrics Thunder`);

  await XliconStickWait();
  const { lyrics, lyricsv2 } = require('@bochilteam/scraper');

  try {
    const result = await lyricsv2(text).catch(async () => await lyrics(text));
    const xliconlirik = `
ğŸµ *Title:* ${result.title}
ğŸ¤ *Author:* ${result.author}
ğŸ”— *URL:* ${result.link}

ğŸ“ *Lyrics:*
${result.lyrics}
`.trim();

    // If there is an image URL in the result, we can send the lyrics with the image
    if (result.thumbnail) {
      await XliconBotInc.sendMessage(m.chat, { image: { url: result.thumbnail }, caption: xliconlirik }, { quoted: m });
    } else {
      replygcxlicon(xliconlirik);
    }
  } catch (error) {
    console.error(error);
    replygcxlicon(`Lyrics for "${text}" not found! ğŸ˜`);
  }
}
break;

            case 'friend':
case 'searchfriend':{
await XliconStickWait()
let teman = pickRandom(xliconverifieduser)
setTimeout(() => {
}, 1000)
setTimeout(() => {
replygcxlicon('Managed to Get One Person')
}, 5000)
setTimeout(() => {
XliconBotInc.sendMessage(m.chat, {text: `Here @${teman.split("@")[0]}`, mentions: [teman]}, { quoted : m })
}, 9000)
}
break
        
case 'wanumber': case 'nowa': case 'searchno': case 'searchnumber': {
  if (!text) return replygcxlicon(`ğŸ“± Provide Number with last number x\n\nExample: ${prefix + command} 91690913721x`);

  var inputnumber = text.split(" ")[0];
  await XliconStickWait();
  replygcxlicon(`ğŸ” Searching for WhatsApp account in the given range...`);

  function countInstances(string, word) {
      return string.split(word).length - 1;
  }

  var number0 = inputnumber.split('x')[0];
  var number1 = inputnumber.split('x')[countInstances(inputnumber, 'x')] ? inputnumber.split('x')[countInstances(inputnumber, 'x')] : '';
  var random_length = countInstances(inputnumber, 'x');
  var randomxx;

  if (random_length == 1) {
      randomxx = 10;
  } else if (random_length == 2) {
      randomxx = 100;
  } else if (random_length == 3) {
      randomxx = 1000;
  }

  var text66 = `*==[ List of WhatsApp Numbers ]==*\n\n`;
  var nobio = `\n*Bio:* || \nHey there! I am using WhatsApp.ğŸ“²\n`;
  var nowhatsapp = `\n*Numbers with no WhatsApp account within provided range.*âŒ\n`;

  for (let i = 0; i < randomxx; i++) {
      var nu = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];
      var status1 = nu[Math.floor(Math.random() * nu.length)];
      var status2 = nu[Math.floor(Math.random() * nu.length)];
      var status3 = nu[Math.floor(Math.random() * nu.length)];
      var dom4 = nu[Math.floor(Math.random() * nu.length)];
      var random21;

      if (random_length == 1) {
          random21 = `${status1}`;
      } else if (random_length == 2) {
          random21 = `${status1}${status2}`;
      } else if (random_length == 3) {
          random21 = `${status1}${status2}${status3}`;
      } else if (random_length == 4) {
          random21 = `${status1}${status2}${status3}${dom4}`;
      }

      var anu = await XliconBotInc.onWhatsApp(`${number0}${i}${number1}@s.whatsapp.net`);
      var anuu = anu.length !== 0 ? anu : false;

      try {
          try {
              var anu1 = await XliconBotInc.fetchStatus(anu[0].jid);
          } catch {
              var anu1 = '401';
          }
          if (anu1 == '401' || anu1.status.length == 0) {
              nobio += `wa.me/${anu[0].jid.split("@")[0]} ğŸ’¬\n`;
          } else {
              text66 += `ğŸª€ *Number:* wa.me/${anu[0].jid.split("@")[0]}\n ğŸ—ï¸*Bio:* ${anu1.status}\nğŸ§*Last update:* ${moment(anu1.setAt).tz('Asia/Karachi').format('HH:mm:ss DD/MM/YYYY')}\n\n`;
          }
      } catch {
          nowhatsapp += `${number0}${i}${number1} âŒ\n`;
      }
  }

  replygcxlicon(`${text66}${nobio}${nowhatsapp}`);
}
break;

        
        
case 'stickersearch': {
  if (!text) return replygcxlicon(`Example: ${m.prefix + command} kururmi`);
await XliconStickWait()
  var js = await fetch(`https://dikaardnt.com/api/search/sticker?q=${q}`);
  var json = await js.json();

  let response = `
â— *Note:* Bot will give random results. If the results don't match what you want, please try again using ${prefix + command} ${text}

ğŸ’¼ *Title:* ${json[0].title}
ğŸ”— *Link:* ${json[0].url}
â­ *Total Results:* ${json[0].total}
  `;

  if (json[0].url) {
    const imageUrl = 'https://i.ibb.co/xz5JwB6/Xlicon-Pic.jpg'; // URL for the image to send
    await XliconBotInc.sendMessage(m.chat, {
      image: { url: imageUrl },
      caption: response,
      mentions: [m.sender]
    });
  } else {
    replygcxlicon(`No results found for ${text}. Please try another search.`);
  }
}
break;

        
			case 'apksearch': {
  if (!text) return replygcxlicon(`Example: ${prefix + command} whatsapp`);
await XliconStickWait()
  try {
    var js = await fetch(`https://dikaardnt.com/api/search/apk?q=${q}`);
    var json = await js.json();

    // Check if the API response status is false (indicating error)
    if (!json.status) {
      // Construct a message to notify the user
      const errorMsg = `
â— *Error:* ${json.message}

ğŸ’¬ For access, contact the owner:
- *Full Contact:* ${json.owner.fullContact}
- *WhatsApp:* ${json.owner.whatsapp}
- *Telegram:* ${json.owner.telegram}
      `;
      return replygcxlicon(errorMsg); // Send error message to the user
    }

    // Proceed with normal processing if API call is successful
    var capt = `
â— *Note:* Bot will give random results. If the results do not match what you want, please try again using ${prefix + command} ${text}

ğŸ’¼ *Title:* ${json[0].package}
ğŸ”— *Link:* ${json[0].url}
ğŸ‘¤ *Developer:* ${json[0].developer}
â­ *Rating:* ${json[0].rating}
    `;

    if (json[0].thumbnail) {
      const imageUrl = json[0].thumbnail; // Use the thumbnail URL from the API response
      await XliconBotInc.sendMessage(m.chat, {
        image: { url: imageUrl },
        caption: capt,
        mentions: [m.sender]
      });
    } else {
      // If no thumbnail is available, just send the message without image
      replygcxlicon(capt);
    }

  } catch (error) {
    console.error("Error:", error);
    return replygcxlicon(`â— *Error:* Unable to fetch data at this time. Please try again later.`);
  }
}
break;


case 'readmore': {
	let [l, r] = text.split`|`
    if (!l) l = ''
    if (!r) r = ''
    XliconBotInc.sendMessage(m.chat, {text: l + readmore + r}, {quoted: m})
}
break;
        
        
			case 'xvideodl': case 'xvideosearch': case 'xvideo': case 'xvideos': case 'xvideosdl': {
    if (!m.isGroup) return XliconStickGroup();  // Ensure it's a group chat
    if (!AntiNsfw) return replygcxlicon(mess.nsfw);  // Check if NSFW content is allowed
    if (!text) return replygcxlicon(`What do you want to search?\nUsage: *${prefix + command} <search>*\n\nExample: ${prefix + command} hot japanese\nYou can use a link as well.\nExample: ${prefix + command} link <URL>`);

    const isURL = /^(https?:\/\/)?(www\.)?xvideos\.com\/.+$/i.test(text);  // Check if input is a URL
    try {
        if (isURL) {
            // If it's a valid URL, directly download the video
            const result = await xvideosdl(text);
            const { title, url } = result.result; 
            
            const response = await fetch(url);  // Fetch the video file
            const buffer = await response.arrayBuffer();  // Convert to buffer
            
            await XliconBotInc.sendMessage(m.chat, {
                video: { url: buffer },
                caption: `Here you go!!\nTitle: ${title}`,
                mentions: [m.sender]  // Mention the user who requested it
            });
        } else {
            // If it's not a URL, perform a search
            const results = await xvideosSearch(text);
            if (results.length === 0) {
                replygcxlicon('No search results found for the given query.');
            } else {
                const searchResults = results.map((result, index) => {
                    return `${index + 1}. *${result.title}*\nDuration: ${result.duration}\nQuality: ${result.quality}\nURL: ${result.url}`;
                }).join('\n\n');
                
                replygcxlicon(`*Search Results for "${text}":*\n\n${searchResults}`);
            }
        }
    } catch (error) {
        console.error(error);
        replygcxlicon('Failed to fetch Xvideos video details.');
    }
};
break;

case 'xnxxdl': case 'xnxx': case 'xnxxsearch': {
    if (!m.isGroup) return XliconStickGroup();  // Ensure it's a group chat
    if (!AntiNsfw) return replygcxlicon(mess.nsfw);  // Check if NSFW content is allowed
    if (!text) return replygcxlicon(`What do you want to search?\nUsage: *${prefix + command} <search>*\n\nExample: Hot japanese\nor you can use a link as well\nExample: .${prefix + command} link <URL>`);

    let url;
    try {
        url = new URL(text);  // Try to convert text into a valid URL
    } catch (error) {
        url = null;  // Not a valid URL
    }

    if (url) {
        try {
            const files = await xnxxdl(url.href);
            if (files && files.high) {
                await XliconBotInc.sendMessage(m.chat, {
                    video: { url: files.high },
                    caption: 'Here you go!!',
                    mentions: [m.sender]  // Mention the user
                });
            } else {
                replygcxlicon('ğŸ”´ Error: Failed to retrieve the download URL.');
            }
        } catch (e) {
            console.error(e);
            replygcxlicon('ğŸ”´ Error: We encountered a problem while processing the request.');
        }
    } else {
        try {
            const results = await xnxxSearch(text);
            if (results.length > 0) {
                const message = results.map((r, i) => `${i + 1}. [${r.title}](${r.link})`).join('\n');
                await XliconBotInc.sendMessage(m.chat, {
                    text: message,
                    mentions: [m.sender]  // Mention the user
                });
            } else {
                replygcxlicon('ğŸ”´ Error: No search results found.');
            }
        } catch (e) {
            console.error(e);
            replygcxlicon('ğŸ”´ Error: We encountered a problem while processing the request.');
        }
    }
};
break;

case 'yts': case 'ytsearch': {
    if (!text) return await replygcxlicon(`*Example :* ${prefix + command} title`);
await XliconStickWait()
    try {
        let yts = require("yt-search");
        let search = await yts(text);
        let videos = search.all;
        console.log(videos);

        if (!videos || videos.length === 0) {
            return await replygcxlicon('âŒ No video found');
        }

        // Prepare the combined message for up to 10 videos
        let message = `*Search Results for: ${text}*\n\n`;
        const numVideos = Math.min(videos.length, 10);  // Send up to 10 videos, or fewer if there are less than 10

        for (let i = 0; i < numVideos; i++) {
            const video = videos[i];
            message += `\nğŸ“¹ *Title:* _${video.title}_\n` +
                       `â³ *Duration:* _${video.timestamp}_ _(${video.seconds} seconds)_\n` +
                       `ğŸ—“ï¸ *Uploaded:* _${video.ago}_\n` +
                       `ğŸ‘€ *Views:* _${video.views.toLocaleString()}_ _views_\n` +
                       `ğŸ‘¤ *Author:* _${video.author.name}_\n` +
                       `ğŸ”— *URL:* ${video.url}\n`;
        }

        // Send the combined message with all the details
        await replygcxlicon(message);

    } catch (e) {
        console.error(e);
        await replygcxlicon('âš ï¸ Error: Something went wrong while fetching video details.');
    }
}
break;

case 'wikipedia': case 'wiki': {
  if (!text) return await replygcxlicon('â— Enter what you want to search for on Wikipedia');

  try {
      // Fetch Wikipedia page content
      const link = await axios.get(`https://en.wikipedia.org/wiki/${text}`);
      const $ = cheerio.load(link.data);

      // Extract title and summary
      let wik = $('#firstHeading').text().trim();
      let resulw = $('#mw-content-text > div.mw-parser-output').find('p').text().trim();

      // Create a message body with the title and summary
      let message = `â–¢ *Wikipedia Search Result* ğŸ§\n\n`;
      message += `â€£ *Title*: ${wik} ğŸ“š\n\n`;
      message += `${resulw} ğŸ“–\n`;

      // Send the response message
      await replygcxlicon(message);

  } catch (e) {
      console.error(e);
      await replygcxlicon('âš ï¸ No results found or failed to fetch data. Try again later!');
  }
}
break;

case 'google': {
  if (!q) return replygcxlicon(`â— Example : ${prefix + command} ${botname}`);

  await XliconStickWait();

  let google = require('google-it');
  google({'query': text}).then(res => {
      let teks = `ğŸ” *Google Search Results for*: ${text}\n\n`;
      for (let g of res) {
          teks += `â­” *Title*: ${g.title} ğŸ“‘\n`;
          teks += `â­” *Description*: ${g.snippet} ğŸ“\n`;
          teks += `â­” *Link*: [Click Here](${g.link}) ğŸŒ\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n`;
      }

      replygcxlicon(teks);
  }).catch(err => {
      console.error(err);
      replygcxlicon('âš ï¸ Error: Could not fetch results. Please try again later.');
  });
}
break;


case 'img': case 'image': case 'picture': {
  if (!text) return replygcxlicon(`*â€¢ Example:* ${prefix + command} luffy one piece,10`);
await XliconStickWait()
  try {
      // Split the input text to get the search term and the amount
      let [searchTerm, amount] = text.split(',').map(item => item.trim());
      // Default to 1 if no amount is provided
      amount = amount ? parseInt(amount) : 1;

      // Limit the maximum number of images to 30
      if (amount > 30) {
          amount = 30;
          replygcxlicon('âš ï¸ *Maximum limit is 30 images.* Sending 30 images.');
      } else if (amount <= 0 || isNaN(amount)) {
          return replygcxlicon('âŒ *Invalid number of images.* Please enter a number between 1 and 30.');
      }

      // List of new API URLs for fetching images
      const apiUrls = [
          'https://aemt.uk.to/googleimage?query=',
          'https://meitang.xyz/googleimage?query=',
          'https://btch.us.kg/googleimage?query=',
          'https://api.tioo.eu.org/googleimage?query=',
          'https://api.tioprm.eu.org/googleimage?query='
      ];

      // Select a random API URL
      const randomApiUrl = apiUrls[Math.floor(Math.random() * apiUrls.length)];

      // Fetch the image URLs from the selected API
      let response = await fetch(randomApiUrl + encodeURIComponent(searchTerm));

      // Check if the response is okay
      if (!response.ok) {
          return replygcxlicon('âŒ *Failed to fetch the images.* Please try again.');
      }

      // Parse the response JSON
      let data = await response.json();
      if (!data.result || data.result.length === 0) {
          return replygcxlicon('âŒ *No images found for the given query.*');
      }

      // Select a random set of images from the fetched URLs
      let imageUrls = [];
      for (let i = 0; i < amount; i++) {
          let randomImageUrl = data.result[Math.floor(Math.random() * data.result.length)];
          imageUrls.push(randomImageUrl);
      }

      // Send each selected image with a caption
      for (let imageUrl of imageUrls) {
          try {
              let imgResponse = await fetch(imageUrl);
              if (imgResponse.status === 403) {
                  console.warn(`âš ï¸ *403 Forbidden* for URL: ${imageUrl}. Skipping.`);
                  continue; // Skip to the next image URL
              }

              await XliconBotInc.sendMessage(m.chat, {
                  image: { url: imageUrl },
                  caption: `ğŸ–¼ï¸ *Image Result* ğŸ¨\n\nâœ¨ _Here is the result of: ${searchTerm}_ ğŸ”`
              }, { quoted: m });
          } catch (error) {
              console.error(`âŒ Error sending image ${imageUrl}:`, error);
              continue; // Continue to the next image in case of an error
          }
      }

  } catch (e) {
      console.error('âš ï¸ Error fetching the images:', e);
      return replygcxlicon("â— *Error fetching the images.* Please try again.");
  }
}
break;

case 'gimage': case 'googleimg': case 'imggoogle': {
  if (!text) return replygcxlicon(`*â€¢ Example:* ${prefix + command} a girl ğŸ‘§`);
await XliconStickWait()
  try {
      // List of new API URLs
      const apiUrls = [
          'https://aemt.uk.to/googleimage?query=',
          'https://meitang.xyz/googleimage?query=',
          'https://btch.us.kg/googleimage?query=',
          'https://api.tioo.eu.org/googleimage?query=',
          'https://api.tioprm.eu.org/googleimage?query='
      ];

      // Randomly select an API URL
      const apiUrl = apiUrls[Math.floor(Math.random() * apiUrls.length)] + encodeURIComponent(text);

      // Fetch the image from the selected API
      let response = await fetch(apiUrl);

      // Check if the response is okay
      if (!response.ok) {
          return replygcxlicon('âŒ *Failed to fetch the image.* Please try again. ğŸ”„');
      }

      // Get the image URL from the response
      let data = await response.json();

      if (!data.result || data.result.length === 0) {
          return replygcxlicon('âŒ *No images found.* Please try again with a different search term. ğŸ”„');
      }

      // Select a random image from the result
      let imageUrl = data.result[Math.floor(Math.random() * data.result.length)];

      // Send the image with a caption
      await XliconBotInc.sendMessage(m.chat, {
          image: { url: imageUrl },
          caption: `ğŸŒŸ *Google Image Search* ğŸŒŸ\n\n_*Here is the result for: ${text}*_ ğŸ“¸âœ¨`
      }, { quoted: m });

  } catch (e) {
      console.error(e);
      return replygcxlicon('â— *Error fetching the image.* Please try again. âš ï¸');
  }
}
break;



			case 'getjoinrequest':{
	if (!m.isGroup) return XliconStickGroup()
	if (!m.isBotAdmin) return XliconStickBotAdmin()
if (!m.isAdmin && !XliconTheCreator) return XliconStickAdmin()
	const response = await XliconBotInc.groupRequestParticipantsList(m.chat);
  if (!response || !response.length) {
    XliconBotInc.sendMessage(m.chat, {text: 'No pending join requests. âœ…'}, {quoted:m});
    return;
  }
  let replyMessage = `${themeemoji} Join Request List:\n`;
  response.forEach((request, index) => {
    const { jid, request_method, request_time } = request;
    const formattedTime = new Date(parseInt(request_time) * 1000).toLocaleString();
    replyMessage += `\n*No.: ${index + 1} Request Details. ğŸ‘‡*`;
    replyMessage += `\nğŸ§Ÿâ€â™‚ï¸ *JID:* ${jid}`;
    replyMessage += `\nğŸ§ª *Method:* ${request_method}`;
    replyMessage += `\nâ° *Time:* ${formattedTime}\n`;
  });

  XliconBotInc.sendMessage(m.chat, {text: replyMessage}, {quoted:m});
};
break
			case 'addbadword': case 'addbd':
               if (!XliconTheCreator) return XliconStickOwner()
               if (args.length < 1) return replygcxlicon( `Send command ${prefix}addbadword [harsh word]. Example ${prefix}addbadword asshole`)
               bad.push(q)
               fs.writeFileSync('./src/badword.json', JSON.stringify(bad))
               replygcxlicon('Successfully Added Bad Word!')
            break
            case 'delbadword': case 'deldb':
               if (!XliconTheCreator) return XliconStickOwner()
               if (args.length < 1) return replygcxlicon( `Send commands ${prefix}addbadword [bad word]. Example ${prefix}addbadword asshole`)                 
               bad.splice(q)
               fs.writeFileSync('./src/badword.json', JSON.stringify(bad))
               replygcxlicon('Successfully Deleted Bad Word!')
            break 
        
        
            case 'listbadword':{
let teks = 'â”Œâ”€â”€â­“ã€Œ *VN List* ã€\nâ”‚\n'
for (let x of bad) {
teks += `â”‚â­” ${x}\n`
}
teks += `â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â­“\n\n*Totally there are : ${bad.length}*`
replygcxlicon(teks)
}
break
			case 'antibadword':
case 'antitoxic': {
   if (!m.isGroup) return XliconStickGroup();
    if (!m.isBotAdmin) return await replygcxlicon('I need to be an admin to use this command.');
    if (!m.isAdmin && !XliconTheCreator) return await replygcxlicon('You need to be an admin or the bot creator to use this command.');

    if (args[0] === 'on') {
        db.groups[m.chat].badword = true;
        await replygcxlicon(`${command} is enabled.`);
    } else if (args[0] === 'off') {
        db.groups[m.chat].badword = false;
        await replygcxlicon(`${command} is disabled.`);
    } else {
        await replygcxlicon(`Hi ${m.pushName},\nPlease use the command with 'on' or 'off'.\nExample: *${prefix + command} on* or *${prefix + command} off*`);
    }
}
break;
        
        
            case 'antinsfw':
case 'nsfw': {
   if (!m.isGroup) return XliconStickGroup();
    if (!m.isBotAdmin) return await replygcxlicon('I need to be an admin to use this command.');
    if (!m.isAdmin && !XliconTheCreator) return await replygcxlicon('You need to be an admin or the bot creator to use this command.');

    if (args[0] === 'on') {
        db.groups[m.chat].ntnsfw = true;
        await replygcxlicon(`${command} is enabled.`);
    } else if (args[0] === 'off') {
        db.groups[m.chat].ntnsfw = false;
        await replygcxlicon(`${command} is disabled.`);
    } else {
        await replygcxlicon(`Hi ${m.pushName},\nPlease use the command with 'on' or 'off'.\nExample: *${prefix + command} on* or *${prefix + command} off*`);
    }
}
break;

			case 'getbio':{
              try {
    let who
    if (m.isGroup) who = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted.sender
    else who = m.quoted.sender ? m.quoted.sender : m.sender
    let bio = await XliconBotInc.fetchStatus(who)
    replygcxlicon(bio.status)
  } catch {
    if (text) return replygcxlicon(`bio is private or you haven't replied to the person's message!`)
    else try {
      let who = m.quoted ? m.quoted.sender : m.sender
      let bio = await XliconBotInc.fetchStatus(who)
      replygcxlicon(bio.status)
    } catch {
      return replygcxlicon(`bio is private or you haven't replied to the person's message!`)
    }
  }
}
break
        
        
       
        case 'vote': {
            if (!m.isGroup) return XliconStickGroup()
            if (m.chat in vote) return replygcxlicon(`_There are still votes in this chat!_\n\n*${prefix}deletevote* - to delete votes`)
            if (!text) return replygcxlicon(`Enter Reason for Vote, Example: *${prefix + command} Handsome Owner*`)
            replygcxlicon(`Voting starts!\n\n*${prefix}upvote* - for upvote\n*${prefix}downvote* - for downvote\n*${prefix}checkvote* - to check the vote\n*${prefix}deletevote* - to delete vote`)
            vote[m.chat] = [q, [], []]
            await sleep(1000)
            upvote = vote[m.chat][1]
            devote = vote[m.chat][2]
            teks_vote = `* VOTE *

*Reason:* ${vote[m.chat][0]}

â”Œã€” UPVOTE ã€•
â”‚ 
â”œ Total: ${vote[m.chat][1].length}
â”‚
â”‚ 
â””â”€â”€â”€â”€

â”Œã€” DOWNVOTE ã€•
â”‚ 
â”œ Total: ${vote[m.chat][2].length}
â”‚
â”‚ 
â””â”€â”€â”€â”€

Please Type Below
*${prefix}upvote* - to cast vote
*${prefix}downvote* -  to downvote
*${prefix}deletevote* - to delete vote`
            XliconBotInc.sendMessage(m.chat, {text: teks_vote}, {quoted:m})
	    }
            break
               case 'upvote': {
            if (!m.isGroup) return XliconStickGroup()
            if (!(m.chat in vote)) return replygcxlicon(`_*no voting in this group!*_\n\n*${prefix}vote* - to start voting`)
            isVote = vote[m.chat][1].concat(vote[m.chat][2])
            wasVote = isVote.includes(m.sender)
            if (wasVote) return replygcxlicon('You have Voted')
            vote[m.chat][1].push(m.sender)
            menvote = vote[m.chat][1].concat(vote[m.chat][2])
            teks_vote = `* VOTE *

*Reason:* ${vote[m.chat][0]}

â”Œã€” UPVOTE ã€•
â”‚ 
â”œ Total: ${vote[m.chat][1].length}
${vote[m.chat][1].map((v, i) => `â”œ ${i + 1}. @${v.split`@`[0]}`).join('\n')}
â”‚ 
â””â”€â”€â”€â”€

â”Œã€” DOWNVOTE ã€•
â”‚ 
â”œ Total: ${vote[m.chat][2].length}
${vote[m.chat][2].map((v, i) => `â”œ ${i + 1}. @${v.split`@`[0]}`).join('\n')}
â”‚ 
â””â”€â”€â”€â”€

Please Type Below
*${prefix}upvote* - to upvote
*${prefix}downvote* -  to downvote
*${prefix}deletevote* - to delete vote`
            XliconBotInc.sendMessage(m.chat, {text: teks_vote, mentions: menvote}, {quoted:m})
	    }
             break
        
        
                case 'downvote': {
            if (!m.isGroup) return XliconStickGroup()
            if (!(m.chat in vote)) return replygcxlicon(`_*no voting in this group!*_\n\n*${prefix}vote* - to start voting`)
            isVote = vote[m.chat][1].concat(vote[m.chat][2])
            wasVote = isVote.includes(m.sender)
            if (wasVote) return replygcxlicon('You have Voted')
            vote[m.chat][2].push(m.sender)
            menvote = vote[m.chat][1].concat(vote[m.chat][2])
            teks_vote = `* VOTE *

*Reason:* ${vote[m.chat][0]}

â”Œã€” UPVOTE ã€•
â”‚ 
â”œ Total: ${vote[m.chat][1].length}
${vote[m.chat][1].map((v, i) => `â”œ ${i + 1}. @${v.split`@`[0]}`).join('\n')}
â”‚ 
â””â”€â”€â”€â”€

â”Œã€” DOWNVOTE ã€•
â”‚ 
â”œ Total: ${vote[m.chat][2].length}
${vote[m.chat][2].map((v, i) => `â”œ ${i + 1}. @${v.split`@`[0]}`).join('\n')}
â”‚ 
â””â”€â”€â”€â”€

Please Type Below
*${prefix}upvote* - to upvote
*${prefix}downvote* -  to downvote
*${prefix}deletevote* - to delete vote`
            XliconBotInc.sendMessage(m.chat, {text: teks_vote, mentions: menvote}, {quoted:m})
	}
            break
                 
case 'checkvote':
if (!m.isGroup) return XliconStickGroup()
if (!(m.chat in vote)) return replygcxlicon(`_*no voting in this group!*_\n\n*${prefix}vote* - to start voting`)
teks_vote = `* VOTE *

*Reason:* ${vote[m.chat][0]}

â”Œã€” UPVOTE ã€•
â”‚ 
â”œ Total: ${upvote.length}
${vote[m.chat][1].map((v, i) => `â”œ ${i + 1}. @${v.split`@`[0]}`).join('\n')}
â”‚ 
â””â”€â”€â”€â”€

â”Œã€” DOWNVOTE ã€•
â”‚ 
â”œ Total: ${devote.length}
${vote[m.chat][2].map((v, i) => `â”œ ${i + 1}. @${v.split`@`[0]}`).join('\n')}
â”‚ 
â””â”€â”€â”€â”€

*${prefix}deletevote* - to delete votes


Â©${XliconBotInc.user.id}
`
XliconBotInc.sendTextWithMentions(m.chat, teks_vote, m)
break
        
        
		case 'deletevote': case'delvote': case 'hapusvote': {
            if (!m.isGroup) return XliconStickGroup()
            if (!(m.chat in vote)) return replygcxlicon(`_*no voting in this group!*_\n\n*${prefix}vote* - to start voting`)
            delete vote[m.chat]
            replygcxlicon('Successfully Deleted Vote Session In This Group')
	    }
            break

            case 'opentime':
              if (!m.isGroup) return XliconStickGroup(); // Ensure the command is used in a group
              if (!m.isAdmin && !XliconTheCreator) return replygcxlicon(mess.admin); // Check if the user is an admin
              if (!m.isBotAdmin) return XliconStickBotAdmin(); // Check if the bot is an admin
          
              // Determine the time based on the user's input
              if (args[1] == 'second') {
                  var timer = args[0] * `1000`; // Convert to milliseconds
              } else if (args[1] == 'minute') {
                  var timer = args[0] * `60000`; // Convert to milliseconds
              } else if (args[1] == 'hour') {
                  var timer = args[0] * `3600000`; // Convert to milliseconds
              } else if (args[1] == 'day') {
                  var timer = args[0] * `86400000`; // Convert to milliseconds
              } else {
                  return replygcxlicon('*Select:*\nsecond\nminute\nhour\n\n*Example:*\n10 second');
              }
          
              // Notify about the open time
              replygcxlicon(`â° *Open time* ${q} starting from now...`);
          
              setTimeout(() => {
                  var nomor = m.participant;
                  const open = `ğŸ”“ *Open time*: The group is now opened by admin. Members can send messages.`;
                  XliconBotInc.groupSettingUpdate(m.chat, 'not_announcement'); // Set group to normal mode
                  replygcxlicon(open); // Notify the group that the group is open again
              }, timer);
              break;
            
        
        
              case 'editinfo': {
                if (!m.isGroup) return XliconStickGroup(); // Ensure the command is used in a group
                if (!m.isBotAdmin) return await replygcxlicon('âŒ I need to be an admin to use this command.');
                if (!m.isAdmin && !XliconTheCreator) return await replygcxlicon('âŒ You need to be an admin or the bot creator to use this command.');
            
                if (args[0] === 'open') {
                    await XliconBotInc.groupSettingUpdate(m.chat, 'unlocked');
                    await replygcxlicon('ğŸ”“ Successfully opened the group info edit settings. Now, all members can edit group info.');
                } else if (args[0] === 'close') {
                    await XliconBotInc.groupSettingUpdate(m.chat, 'locked');
                    await replygcxlicon('ğŸ”’ Successfully closed the group info edit settings. Only admins can edit group info now.');
                } else {
                    await replygcxlicon(`ğŸ‘‹ Hi ${m.pushName},\nPlease use the command with 'open' or 'close'.\nExample: *${prefix + command} open* or *${prefix + command} close*`);
                }
            }
            break;
            
			case 'getcontact': case 'getcon': {
if (!m.isGroup) return XliconStickGroup()
if (!(m.isAdmin || XliconTheCreator)) return XliconStickAdmin()
xliconbigpp = await XliconBotInc.sendMessage(m.chat, {
    text: `\nGroup: *${groupMetadata.subject}*\nMember: *${participants.length}*`
}, {quoted: m, ephemeralExpiration: 86400})
await sleep(1000)
XliconBotInc.sendContact(m.chat, participants.map(a => a.id), xliconbigpp)
}
break
case 'savecontact': case 'svcontact':{
if (!m.isGroup) return XliconStickGroup()
if (!(m.isAdmin || XliconTheCreator)) return XliconStickAdmin()
let cmiggc = await XliconBotInc.groupMetadata(m.chat)
let orgiggc = participants.map(a => a.id)
vcard = ''
noPort = 0
for (let a of cmiggc.participants) {
    vcard += `BEGIN:VCARD\nVERSION:3.0\nFN:[${noPort++}] +${a.id.split("@")[0]}\nTEL;type=CELL;type=VOICE;waid=${a.id.split("@")[0]}:+${a.id.split("@")[0]}\nEND:VCARD\n`
}
let nmfilect = './contacts.vcf'
replygcxlicon('\nBe patient bro, saving... '+cmiggc.participants.length+' contact')
require('fs').writeFileSync(nmfilect, vcard.trim())
await sleep(2000)
XliconBotInc.sendMessage(m.chat, {
    document: require('fs').readFileSync(nmfilect), mimetype: 'text/vcard', fileName: 'Contact.vcf', caption: '\nSucceed\nGroup: *'+cmiggc.subject+'*\nContact: *'+cmiggc.participants.length+'*'
}, {ephemeralExpiration: 86400, quoted: m})
require('fs').unlinkSync(nmfilect)
}
break
case 'sendcontact': case 'sencontact': {
if (!m.isGroup) return XliconStickGroup()
if (!m.mentionedJid[0]) return replygcxlicon('\nUse like this\n Example:.sendcontact @tag name')
let snTak = text.split(' ')[1] ? text.split(' ')[1] : 'Contact'
let snContact = {
	displayName: "Contact", contacts: [{displayName: snTak, vcard: "BEGIN:VCARD\nVERSION:3.0\nN:;"+snTak+";;;\nFN:"+snTak+"\nitem1.TEL;waid="+m.mentionedJid[0].split('@')[0]+":"+m.mentionedJid[0].split('@')[0]+"\nitem1.X-ABLabel:Mobile\nEND:VCARD"}]
}
XliconBotInc.sendMessage(m.chat, {contacts: snContact}, {ephemeralExpiration: 86400})
}
break
case 'contacttag': case 'contag':{
if (!m.isGroup) return XliconStickGroup()
if (!(m.isAdmin || XliconTheCreator)) return XliconStickAdmin()
if (!m.mentionedJid[0]) return replygcxlicon('\nUse like this\n Example:.contacttag @tag|name')
let sngTak = text.split(' ')[1] ? text.split(' ')[1] : 'Contact'
let sngContact = {
	displayName: "Contact", contacts: [{displayName: sngTak, vcard: "BEGIN:VCARD\nVERSION:3.0\nN:;"+sngTak+";;;\nFN:"+sngTak+"\nitem1.TEL;waid="+m.mentionedJid[0].split('@')[0]+":"+m.mentionedJid[0].split('@')[0]+"\nitem1.X-ABLabel:Mobile\nEND:VCARD"}]
}
XliconBotInc.sendMessage(m.chat, {contacts: sngContact, mentions: participants.map(a => a.id)}, {ephemeralExpiration: 86400})
}
break
			case 'kickall': {
 if (!m.isGroup) return XliconStickGroup()
 if (!m.isAdmin && !XliconTheCreator) return XliconStickAdmin()
 if (!m.isBotAdmin) return XliconStickBotAdmin()
  const xliconkickall = (args[0] === 'numBut')
  ? text.replace(`${args[0]} `, '').split('|')
  : (Number(args[0]))
    ? groupMetadata.participants
      .filter(item => item.id.startsWith(args[0].replace('+', '')) && item.id !== botNumber && item.id !== `${ownernumber}@s.whatsapp.net`)
      .map(item => item.id)
    : groupMetadata.participants
      .filter(item => item.id !== botNumber && item.id !== `${ownernumber}@s.whatsapp.net`)
      .map(item => item.id);
 if (global.db.groups[m.chat].welcome === true) {
 global.db.groups[m.chat].welcome = false;
  }
 for (let remove of xliconkickall) {
 await XliconBotInc.groupParticipantsUpdate(m.chat, [(args[0] === "numBut") ? `${remove}@s.whatsapp.net` : remove], "remove");
 await sleep(100);
 }
 replygcxlicon(`âœ… Success`);

}
break



case 'promoteall': {
 if (!m.isGroup) return XliconStickGroup()
 if (!m.isAdmin && !XliconTheCreator) return XliconStickAdmin()
 if (!m.isBotAdmin) return XliconStickBotAdmin()
  const xliconpromoteall = (args[0] === 'numBut')
  ? text.replace(`${args[0]} `, '').split('|')
  : (Number(args[0]))
    ? groupMetadata.participants
      .filter(item => item.id.startsWith(args[0].replace('+', '')) && item.id !== botNumber && item.id !== `${ownernumber}@s.whatsapp.net`)
      .map(item => item.id)
    : groupMetadata.participants
      .filter(item => item.id !== botNumber && item.id !== `${ownernumber}@s.whatsapp.net`)
      .map(item => item.id);
 for (let promote of xliconpromoteall) {
 await XliconBotInc.groupParticipantsUpdate(m.chat, [(args[0] === "numBut") ? `${promote}@s.whatsapp.net` : promote], "promote");
 await sleep(100);
 }
 replygcxlicon(`âœ… Success`);

}
break



case 'demoteall': {
 if (!m.isGroup) return XliconStickGroup()
 if (!m.isAdmin && !XliconTheCreator) return XliconStickAdmin()
 if (!m.isBotAdmin) return XliconStickBotAdmin()
  const xlicondemoteall = (args[0] === 'numBut')
  ? text.replace(`${args[0]} `, '').split('|')
  : (Number(args[0]))
    ? groupMetadata.participants
      .filter(item => item.id.startsWith(args[0].replace('+', '')) && item.id !== botNumber && item.id !== `${ownernumber}@s.whatsapp.net`)
      .map(item => item.id)
    : groupMetadata.participants
      .filter(item => item.id !== botNumber && item.id !== `${ownernumber}@s.whatsapp.net`)
      .map(item => item.id);
 for (let demote of xlicondemoteall) {
 await XliconBotInc.groupParticipantsUpdate(m.chat, [(args[0] === "numBut") ? `${demote}@s.whatsapp.net` : demote], "demote");
 await sleep(100);
 }
 replygcxlicon(`âœ… Success`);

}
break



			case 'ephemeral': {
    if (!m.isGroup) return XliconStickGroup();
    if (!m.isBotAdmin) return await replygcxlicon('I need to be an admin to use this command.');
    if (!m.isAdmin) return await replygcxlicon('You need to be an admin to use this command.');

    if (args[0] === 'on') {
        await XliconBotInc.sendMessage(m.chat, { disappearingMessagesInChat: WA_DEFAULT_EPHEMERAL });
        await replygcxlicon('Ephemeral messages are now enabled.');
    } else if (args[0] === 'off') {
        await XliconBotInc.sendMessage(m.chat, { disappearingMessagesInChat: false });
        await replygcxlicon('Ephemeral messages are now disabled.');
    } else {
        await replygcxlicon(`Hi ${m.pushName},\nPlease use the command with 'on' or 'off'.\nExample: *${prefix + command} on* or *${prefix + command} off*`);
    }
}
break;

case 'invite': {
  if (!m.isGroup) return XliconStickGroup();
  if (!m.isBotAdmin) return XliconStickBotAdmin();

  if (!text) return replygcxlicon(`â— Please provide the number you want to invite to the group.\n\nExample: *${prefix + command} 916909137213*`);
  if (text.includes('+')) return replygcxlicon(`âš ï¸ Please enter the number without the '+' sign.`);
  if (isNaN(text)) return replygcxlicon(`ğŸš« Please enter only the digits, along with your country code, without spaces.`);

  let group = m.chat;
  let link = 'https://chat.whatsapp.com/' + await XliconBotInc.groupInviteCode(group);

  try {
      await XliconBotInc.sendMessage(text + '@s.whatsapp.net', {
          text: `ğŸŒŸ *GROUP INVITATION*\n\nYou have been invited to join the group. Click the link below to join:\n\nğŸ”— ${link}`,
          mentions: [m.sender]
      });
      replygcxlicon(`âœ… An invite link has been successfully sent to the user.`);
  } catch (error) {
      console.error(error);
      replygcxlicon(`âš ï¸ Failed to send the invite. Please check the number and try again.`);
  }
}
break;

case 'tagadmin': case 'listadmin': case 'admin': {
  if (!m.isGroup) return XliconStickGroup();

  const groupAdmins = participants.filter(p => p.admin);
  const listAdmin = groupAdmins.map((v, i) => `${i + 1}. @${v.id.split('@')[0]}`).join('\n');
  const owner = groupMetadata.owner || groupAdmins.find(p => p.admin === 'superadmin')?.id || m.chat.split`-`[0] + '@s.whatsapp.net';

  let text = `ğŸ‘‘ *Group Admins:*\n${listAdmin}\n\nğŸ“œ *Group Owner*: @${owner.split('@')[0]}`;

  // Send message with admin list
  await replygcxlicon(text);
}
break;


			case 'linkgroup':
            case 'linkgrup':
            case 'linkgc':
            case 'gclink':
            case 'grouplink':
            case 'gruplink':{
                if (!m.isGroup) return XliconStickGroup()
                if (!m.isAdmin && !isGroupOwner && !XliconTheCreator) return XliconStickAdmin()
                if (!m.isBotAdmin) return XliconStickBotAdmin()
                let response = await XliconBotInc.groupInviteCode(m.chat)
                XliconBotInc.sendText(m.chat, `ğŸ‘¥ *GROUP LINK*\nğŸ“› *Name :* ${groupMetadata.subject}\nğŸ‘¤ *Group Owner :* ${groupMetadata.owner !== undefined ? '+'+ groupMetadata.owner.split`@`[0] : 'Not known'}\nğŸŒ± *ID :* ${groupMetadata.id}\nğŸ”— *Chat Link :* https://chat.whatsapp.com/${response}\nğŸ‘¥ *Member :* ${groupMetadata.participants.length}\n`, m, {
                    detectLink: true
                })
                }
            break
        
        
			case 'antipoll': {
    if (!m.isGroup) return XliconStickGroup();
    if (!m.isBotAdmin) return XliconStickBotAdmin();
    if (!m.isAdmin && !XliconTheCreator) return XliconStickAdmin();

    if (args[0] === 'on') {
        db.groups[m.chat].antipoll = true;
        replygcxlicon(`${command} is enabled`);
    } else if (args[0] === 'off') {
        db.groups[m.chat].antipoll = false;
        replygcxlicon(`${command} is disabled`);
    } else {
        replygcxlicon(`Please use *${prefix + command} on* to enable and *${prefix + command} off* to disable.`);
    }
}
break;

case 'antiaudio': {
    if (!m.isGroup) return XliconAudioGroup();
    if (!m.isBotAdmin) return XliconAudioBotAdmin();
    if (!m.isAdmin && !XliconTheCreator) return XliconAudioAdmin();

    if (args[0] === 'on') {
        db.groups[m.chat].antiaudio = true;
        replygcxlicon(`${command} is enabled`);
    } else if (args[0] === 'off') {
        db.groups[m.chat].antiaudio = false;
        replygcxlicon(`${command} is disabled`);
    } else {
        replygcxlicon(`Please use *${prefix + command} on* to enable and *${prefix + command} off* to disable.`);
    }
}
break;
            case 'antisticker': {
    if (!m.isGroup) return XliconStickGroup();
    if (!m.isBotAdmin) return XliconStickBotAdmin();
    if (!m.isAdmin && !XliconTheCreator) return XliconStickAdmin();

    if (args[0] === 'on') {
        db.groups[m.chat].antisticker = true;
        replygcxlicon(`${command} is enabled`);
    } else if (args[0] === 'off') {
        db.groups[m.chat].antisticker = false;
        replygcxlicon(`${command} is disabled`);
    } else {
        replygcxlicon(`Please use *${prefix + command} on* to enable and *${prefix + command} off* to disable.`);
    }
}
break;

case 'antiemoji': {
    if (!m.isGroup) return XliconStickGroup();
    if (!m.isBotAdmin) return XliconStickBotAdmin();
    if (!m.isAdmin && !XliconTheCreator) return XliconStickAdmin();

    if (args[0] === 'on') {
        db.groups[m.chat].antiemoji = true;
        replygcxlicon(`${command} is enabled`);
    } else if (args[0] === 'off') {
        db.groups[m.chat].antiemoji = false;
        replygcxlicon(`${command} is disabled`);
    } else {
        replygcxlicon(`Please use *${prefix + command} on* to enable and *${prefix + command} off* to disable.`);
    }
}
break;

          


          
           case 'antiimage': {
    if (!m.isGroup) return XliconStickGroup();
    if (!m.isBotAdmin) return XliconStickBotAdmin();
    if (!m.isAdmin && !XliconTheCreator) return XliconStickAdmin();

    if (args[0] === 'on') {
        db.groups[m.chat].antiimage = true;
        replygcxlicon(`${command} is enabled`);
    } else if (args[0] === 'off') {
        db.groups[m.chat].antiimage = false;
        replygcxlicon(`${command} is disabled`);
    } else {
        replygcxlicon(`Please use *${prefix + command} on* to enable and *${prefix + command} off* to disable.`);
    }
}
break;

case 'antivideo': {
    if (!m.isGroup) return XliconStickGroup();
    if (!m.isBotAdmin) return XliconStickBotAdmin();
    if (!m.isAdmin && !XliconTheCreator) return XliconStickAdmin();

    if (args[0] === 'on') {
        db.groups[m.chat].antivideo = true;
        replygcxlicon(`${command} is enabled`);
    } else if (args[0] === 'off') {
        db.groups[m.chat].antivideo = false;
        replygcxlicon(`${command} is disabled`);
    } else {
        replygcxlicon(`Please use *${prefix + command} on* to enable and *${prefix + command} off* to disable.`);
    }
}
break;

case 'antivirtex': case 'antivirus': {
    if (!m.isGroup) return XliconStickGroup();
    if (!m.isBotAdmin) return XliconStickBotAdmin();
    if (!m.isAdmin && !XliconTheCreator) return XliconStickAdmin();

    if (args[0] === 'on') {
        db.groups[m.chat].antivirtex = true;
        replygcxlicon(`${command} is enabled`);
    } else if (args[0] === 'off') {
        db.groups[m.chat].antivirtex = false;
        replygcxlicon(`${command} is disabled`);
    } else {
        replygcxlicon(`Please use *${prefix + command} on* to enable and *${prefix + command} off* to disable.`);
    }
}
break;
            
			case 'unavailable': {
    if (!XliconTheCreator) return XliconStickOwner();

    if (q === 'on') {
        db.settings[botNumber].online = true;
        replygcxlicon(`Successfully changed unavailable to ${q}`);
    } else if (q === 'off') {
        db.settings[botNumber].online = false;
        replygcxlicon(`Successfully changed unavailable to ${q}`);
    } else {
        replygcxlicon(`Please use *${prefix + command} on* to enable and *${prefix + command} off* to disable.`);
    }
}
break;

case 'welcome':
case 'left': {
    if (!m.isGroup) return XliconStickGroup();
    if (!m.isAdmin && !XliconTheCreator) return XliconStickAdmin();

    if (args[0] === 'on') {
        db.groups[m.chat].welcome = true;
        replygcxlicon(`${command} is enabled`);
    } else if (args[0] === 'off') {
        db.groups[m.chat].welcome = false;
        replygcxlicon(`${command} is disabled`);
    } else {
        replygcxlicon(`Please use *${prefix + command} on* to enable and *${prefix + command} off* to disable.`);
    }
}
break;

          
case 'groupevent': {
    if (!m.isGroup) return XliconStickGroup();
    if (!m.isAdmin && !XliconTheCreator) return XliconStickAdmin();

    if (args[0] === 'on') {
        db.groups[m.chat].setinfo = true;
        replygcxlicon(`${command} is enabled`);
    } else if (args[0] === 'off') {
        db.groups[m.chat].setinfo = false;
        replygcxlicon(`${command} is disabled`);
    } else {
        replygcxlicon(`Please use *${prefix + command} on* to enable and *${prefix + command} off* to disable.`);
    }
}
break;

case 'antiviewonce': {
    if (!m.isGroup) return XliconStickGroup();
    if (!m.isBotAdmin) return XliconStickBotAdmin();
    if (!m.isAdmin && !XliconTheCreator) return XliconStickAdmin();

    if (args[0] === 'on') {
        db.groups[m.chat].antiviewonce = true;
        replygcxlicon(`${command} is enabled`);
    } else if (args[0] === 'off') {
        db.groups[m.chat].antiviewonce = false;
        replygcxlicon(`${command} is disabled`);
    } else {
        replygcxlicon(`Please use *${prefix + command} on* to enable and *${prefix + command} off* to disable.`);
    }
}
break;

case 'antimedia': {
    if (!m.isGroup) return XliconStickGroup();
    if (!m.isBotAdmin) return XliconStickBotAdmin();
    if (!m.isAdmin && !XliconTheCreator) return XliconStickAdmin();

    if (args[0] === 'on') {
        db.groups[m.chat].antimedia = true;
        replygcxlicon(`${command} is enabled`);
    } else if (args[0] === 'off') {
        db.groups[m.chat].antimedia = false;
        replygcxlicon(`${command} is disabled`);
    } else {
        replygcxlicon(`Please use *${prefix + command} on* to enable and *${prefix + command} off* to disable.`);
    }
}
break;
           
            case 'antidocument': {
  if (!m.isGroup) return XliconStickGroup();
  if (!m.isBotAdmin) return XliconStickBotAdmin();
  if (!m.isAdmin && !XliconTheCreator) return XliconStickAdmin();

  if (args[0] === 'on') {
    db.groups[m.chat].antidocument = true;
    return replygcxlicon(`${command} is enabled âœ…`);
  } else if (args[0] === 'off') {
    db.groups[m.chat].antidocument = false;
    return replygcxlicon(`${command} is disabled âŒ`);
  } else {
    return replygcxlicon(`Please specify 'on' or 'off' to ${command}.`);
  }
  break;
}

case 'anticontact': {
  if (!m.isGroup) return XliconStickGroup();
  if (!m.isBotAdmin) return XliconStickBotAdmin();
  if (!m.isAdmin && !XliconTheCreator) return XliconStickAdmin();

  if (args[0] === 'on') {
    db.groups[m.chat].anticontact = true;
    return replygcxlicon(`${command} is enabled âœ…`);
  } else if (args[0] === 'off') {
    db.groups[m.chat].anticontact = false;
    return replygcxlicon(`${command} is disabled âŒ`);
  } else {
    return replygcxlicon(`Please specify 'on' or 'off' to ${command}.`);
  }
  break;
}

            
            case 'antilocation': {
  if (!m.isGroup) return XliconStickGroup();
  if (!m.isBotAdmin) return XliconStickBotAdmin();
  if (!m.isAdmin && !XliconTheCreator) return XliconStickAdmin();

  if (args[0] === 'on') {
    db.groups[m.chat].antilocation = true;
    return replygcxlicon(`${command} is enabled âœ…`);
  } else if (args[0] === 'off') {
    db.groups[m.chat].antilocation = false;
    return replygcxlicon(`${command} is disabled âŒ`);
  } else {
    return replygcxlicon(`Please specify 'on' or 'off' to ${command}.`);
  }
  break;
}

case 'antilink': {
  if (!m.isGroup) return XliconStickGroup();
  if (!m.isBotAdmin) return XliconStickBotAdmin();
  if (!m.isAdmin && !XliconTheCreator) return XliconStickAdmin();

  if (args[0] === 'on') {
    db.groups[m.chat].antilink = true;
    return replygcxlicon(`${command} is enabled âœ…`);
  } else if (args[0] === 'off') {
    db.groups[m.chat].antilink = false;
    return replygcxlicon(`${command} is disabled âŒ`);
  } else {
    return replygcxlicon(`Please specify 'on' or 'off' to ${command}.`);
  }
  break;
}

case 'antibot': {
  if (!m.isGroup) return XliconStickGroup();
  if (!m.isBotAdmin) return XliconStickBotAdmin();
  if (!m.isAdmin && !XliconTheCreator) return XliconStickAdmin();

  if (args[0] === 'on') {
    db.groups[m.chat].antibot = true;
    return replygcxlicon(`${command} is enabled âœ…`);
  } else if (args[0] === 'off') {
    db.groups[m.chat].antibot = false;
    return replygcxlicon(`${command} is disabled âŒ`);
  } else {
    return replygcxlicon(`Please specify 'on' or 'off' to ${command}.`);
  }
  break;
}

            
			case 'pinchat': {
if (!XliconTheCreator) return XliconStickOwner()
if (m.isGroup) return XliconStickPrivate()
XliconBotInc.chatModify({ pin: true }, m.chat)
}
break
case 'unpinchat': {
if (!XliconTheCreator) return XliconStickOwner()
if (m.isGroup) return XliconStickPrivate()
XliconBotInc.chatModify({ pin: false }, m.chat)
}
break
			case 'clearchat': {
if (!XliconTheCreator) return XliconStickOwner()
XliconBotInc.chatModify({ delete: true, lastMessages: [{ key: m.key, messageTimestamp: m.messageTimestamp }] }, m.chat)
}
break




			case 'checkmember': case 'cekmember':{
                                if (!m.isAdmin && !XliconTheCreator) return XliconStickAdmin()
                                if (!m.isGroup) return XliconStickGroup()
replygcxlicon(`Group: *${groupMetadata.subject}*\nTotal participants: *${participants.length}*`)
                                }
                                break




			case 'jpm': case 'post': case 'pushcontactgc': {
if (!XliconTheCreator) return XliconStickOwner()
if (!m.isGroup) return XliconStickGroup()
if (!text) return replygcxlicon(`*Incorrect Usage Please Use Like This*\n${prefix+command} text|pause\n\nReply Image To Send Images to All Groups\nFor a pause, 1000 = 1 second\n\nExample: ${prefix + command} hello|9000`)
await replygcxlicon(`In progress...`)
let getGroups = await XliconBotInc.groupFetchAllParticipating()
let groups = Object.entries(getGroups).slice(0).map((entry) => entry[1])
let anu = groups.map((v) => v.id)
for (let xnxx of anu) {
let metadat72 = await XliconBotInc.groupMetadata(xnxx)
let participanh = await metadat72.participants
if (/image/.test(mime)) {
media = await XliconBotInc.downloadAndSaveMediaMessage(quoted)
mem = await TelegraPh(media)
await XliconBotInc.sendMessage(xnxx, { image: { url: mem }, caption: text.split('|')[0], mentions: participanh.map(a => a.id) })
await sleep(text.split('|')[1])
} else {
await XliconBotInc.sendMessage(xnxx, { text: text.split('|')[0], mentions: participanh.map(a => a.id) })
await sleep(text.split('|')[1])
}}
replygcxlicon(`âœ… Success!`);

}
break
			case 'pushcontact': {
    if (!XliconTheCreator) return XliconStickOwner()
    if (!m.isGroup) return XliconStickGroup()
    if (!text) return replygcxlicon(`text?`)
    let mem = await participants.filter(v => v.id.endsWith('.net')).map(v => v.id)
    replygcxlicon(`Success in pushing the message to contacts`)
    for (let pler of mem) {
    XliconBotInc.sendMessage(pler, { text: q})
     }  
     replygcxlicon(`âœ”ï¸ Done!`);

      }
      break
case 'pushcontactv2':{
if (!XliconTheCreator) return XliconStickOwner()
if (!q) return replygcxlicon(`Incorrect Usage Please Use Command Like This\n${prefix+command} idgc|text`)
try {
const metadata2 = await XliconBotInc.groupMetadata(q.split("|")[0])
const halss = metadata2.participants
for (let mem of halss) {
XliconBotInc.sendMessage(`${mem.id.split('@')[0]}` + "@s.whatsapp.net", { text: q.split("|")[1] })
await sleep(5000)
}
replygcxlicon(`âœ… Success!`);

} catch {
	replygcxlicon(`Incorrect Usage Please Use Command Like This\n${prefix+command} idgc|text`)
	}
}
break
case 'pushcontactv3': {
if (!XliconTheCreator) return XliconStickOwner()
if (!m.isGroup) return XliconStickGroup()
if (!text) return replygcxlicon(
`
*Usage example :*

${prefix+command} pause|text

â€¼ï¸Reply Image To Send Images to All Participants, For a pause, 1000 = 1 second
`
)
try {
let jedany = text.split("|")[0]
let captny = text.split("|")[1]
const halsss = await participants.filter(v => v.id.endsWith('.net')).map(v => v.id)
for (let men of halsss) {
if (/image/.test(mime)) {
media = await XliconBotInc.downloadAndSaveMediaMessage(quoted)
mem = await TelegraPh(media)
await XliconBotInc.sendMessage(men, { image: { url: mem }, caption: captny }, { quoted: m })
await sleep(jedany)
} else {
await XliconBotInc.sendMessage(men, { text: captny  }, { quoted: m })
await sleep(jedany)
}
}
replygcxlicon(`âœ… Success!`);

} catch {
	replygcxlicon(
`
*Usage example :*

${prefix+command} pause|text

â€¼ï¸Reply Image To Send Images to All Participants, For a pause, 1000 = 1 second
`
)
}
}
break
			case 'autosticker': case 'autostickergc': {
  if (!XliconTheCreator) return XliconStickOwner();

  if (q === 'on') {
    db.settings[botNumber].autosticker = true;
    return replygcxlicon(`Auto Sticker has been successfully enabled âœ…`);
  } else if (q === 'off') {
    db.settings[botNumber].autosticker = false;
    return replygcxlicon(`Auto Sticker has been successfully disabled âŒ`);
  } else {
    return replygcxlicon(`Please specify 'on' or 'off' to change the Auto Sticker setting.`);
  }
  break;
}

case 'addvideo': {
  if (!XliconTheCreator) return XliconStickOwner();
  if (args.length < 1) return replygcxlicon('ğŸ¥ Please provide the video name.');
  if (VideoXlicon.includes(q)) return replygcxlicon("âŒ The name is already in use.");

  let delb = await XliconBotInc.downloadAndSaveMediaMessage(quoted);
  VideoXlicon.push(q);
  await fsx.copy(delb, `./XliconMedia/video/${q}.mp4`);
  fs.writeFileSync('./XliconMedia/database/xliconvideo.json', JSON.stringify(VideoXlicon));
  fs.unlinkSync(delb);

  replygcxlicon(`âœ… Success adding video\nCheck by typing ${prefix}listvideo`);
}
break;

case 'delvideo': {
  if (!XliconTheCreator) return XliconStickOwner();
  if (args.length < 1) return replygcxlicon('âŒ Enter the video name.');
  if (!VideoXlicon.includes(q)) return replygcxlicon("âŒ The name does not exist in the database.");

  let wanu = VideoXlicon.indexOf(q);
  VideoXlicon.splice(wanu, 1);
  fs.writeFileSync('./XliconMedia/database/xliconvideo.json', JSON.stringify(VideoXlicon));
  fs.unlinkSync(`./XliconMedia/video/${q}.mp4`);

  replygcxlicon(`âœ… Success deleting video: ${q}`);
}
break;

case 'listvideo': {
  let teks = 'ğŸ¬â”Œâ”€â”€â­“ã€Œ *Video List* ã€\nâ”‚\n';
  for (let x of VideoXlicon) {
      teks += `â”‚ğŸ“¹ ${x}\n`;
  }
  teks += `â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â­“\n\n*Total: ${VideoXlicon.length} videos*`;
  replygcxlicon(teks);
}
break;

case 'addimage': {
  if (!XliconTheCreator) return XliconStickOwner();
  if (args.length < 1) return replygcxlicon('ğŸ–¼ï¸ Please provide the image name.');
  if (ImageXlicon.includes(q)) return replygcxlicon("âŒ The name is already in use.");

  let delb = await XliconBotInc.downloadAndSaveMediaMessage(quoted);
  ImageXlicon.push(q);
  await fsx.copy(delb, `./XliconMedia/image/${q}.jpg`);
  fs.writeFileSync('./XliconMedia/database/xliconimage.json', JSON.stringify(ImageXlicon));
  fs.unlinkSync(delb);

  replygcxlicon(`âœ… Success adding image\nCheck by typing ${prefix}listimage`);
}
break;

case 'delimage': {
  if (!XliconTheCreator) return XliconStickOwner();
  if (args.length < 1) return replygcxlicon('âŒ Enter the image name.');
  if (!ImageXlicon.includes(q)) return replygcxlicon("âŒ The name does not exist in the database.");

  let wanu = ImageXlicon.indexOf(q);
  ImageXlicon.splice(wanu, 1);
  fs.writeFileSync('./XliconMedia/database/xliconimage.json', JSON.stringify(ImageXlicon));
  fs.unlinkSync(`./XliconMedia/image/${q}.jpg`);

  replygcxlicon(`âœ… Success deleting image: ${q}`);
}
break;

case 'listimage': {
  let teks = 'ğŸ–¼ï¸â”Œâ”€â”€â­“ã€Œ *Image List* ã€\nâ”‚\n';
  for (let x of ImageXlicon) {
      teks += `â”‚ğŸ–¼ï¸ ${x}\n`;
  }
  teks += `â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â­“\n\n*Totally there are: ${ImageXlicon.length}*`;
  replygcxlicon(teks);
}
break;

case 'addsticker': {
  if (!XliconTheCreator) return XliconStickOwner();
  if (args.length < 1) return replygcxlicon('ğŸ’¬ Whatâ€™s the sticker name?');
  if (StickerXlicon.includes(q)) return replygcxlicon("âŒ The name is already in use");
  let delb = await XliconBotInc.downloadAndSaveMediaMessage(quoted);
  StickerXlicon.push(q);
  await fsx.copy(delb, `./XliconMedia/sticker/${q}.webp`);
  fs.writeFileSync('./XliconMedia/database/xliconsticker.json', JSON.stringify(StickerXlicon));
  fs.unlinkSync(delb);
  replygcxlicon(`âœ… Success Adding Sticker\nCheck by typing ${prefix}liststicker`);
}
break;

case 'delsticker': {
  if (!XliconTheCreator) return XliconStickOwner();
  if (args.length < 1) return replygcxlicon('âŒ Enter the sticker name');
  if (!StickerXlicon.includes(q)) return replygcxlicon("âŒ The name does not exist in the database");
  let wanu = StickerXlicon.indexOf(q);
  StickerXlicon.splice(wanu, 1);
  fs.writeFileSync('./XliconMedia/database/xliconsticker.json', JSON.stringify(StickerXlicon));
  fs.unlinkSync(`./XliconMedia/sticker/${q}.webp`);
  replygcxlicon(`âœ… Success deleting sticker ${q}`);
}
break;

case 'liststicker': {
  let teks = 'ğŸ’¬â”Œâ”€â”€â­“ã€Œ *Sticker List* ã€\nâ”‚\n';
  for (let x of StickerXlicon) {
      teks += `â”‚ğŸ’¥ ${x}\n`;
  }
  teks += `â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â­“\n\n*Totally there are: ${StickerXlicon.length}*`;
  replygcxlicon(teks);
}
break;

case 'addvn': {
  if (!XliconTheCreator) return XliconStickOwner();
  if (args.length < 1) return replygcxlicon('ğŸµ Whatâ€™s the audio name?');
  if (VoiceNoteXlicon.includes(q)) return replygcxlicon("âŒ The name is already in use");
  let delb = await XliconBotInc.downloadAndSaveMediaMessage(quoted);
  VoiceNoteXlicon.push(q);
  await fsx.copy(delb, `./XliconMedia/audio/${q}.mp3`);
  fs.writeFileSync('./XliconMedia/database/xliconvn.json', JSON.stringify(VoiceNoteXlicon));
  fs.unlinkSync(delb);
  replygcxlicon(`âœ… Success Adding Audio\nCheck by typing ${prefix}listvn`);
}
break;

case 'delvn': {
  if (!XliconTheCreator) return XliconStickOwner();
  if (args.length < 1) return replygcxlicon('âŒ Enter the vn name');
  if (!VoiceNoteXlicon.includes(q)) return replygcxlicon("âŒ The name does not exist in the database");
  let wanu = VoiceNoteXlicon.indexOf(q);
  VoiceNoteXlicon.splice(wanu, 1);
  fs.writeFileSync('./XliconMedia/database/xliconvn.json', JSON.stringify(VoiceNoteXlicon));
  fs.unlinkSync(`./XliconMedia/audio/${q}.mp3`);
  replygcxlicon(`âœ… Success deleting vn ${q}`);
}
break;

case 'listvn': {
  let teks = 'ğŸµâ”Œâ”€â”€â­“ã€Œ *VN List* ã€\nâ”‚\n';
  for (let x of VoiceNoteXlicon) {
      teks += `â”‚ğŸ¶ ${x}\n`;
  }
  teks += `â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â­“\n\n*Totally there are: ${VoiceNoteXlicon.length}*`;
  replygcxlicon(teks);
}
break;

case 'addzip': {
  if (!XliconTheCreator) return XliconStickOwner();
  if (args.length < 1) return replygcxlicon('ğŸ“¦ Whatâ€™s the zip name?');
  let teks = `${text}`;
  {
      if (ZipXlicon.includes(teks)) return replygcxlicon("âŒ This name is already in use");
      let delb = await XliconBotInc.downloadAndSaveMediaMessage(quoted);
      ZipXlicon.push(teks);
      await fsx.copy(delb, `./XliconMedia/zip/${teks}.zip`);
      fs.writeFileSync('./XliconMedia/database/zip.json', JSON.stringify(ZipXlicon));
      fs.unlinkSync(delb);
      replygcxlicon(`âœ… Success Adding Zip\nTo check type ${prefix}listzip`);
  }
}
break;

case 'delzip': {
  if (!XliconTheCreator) return XliconStickOwner();
  if (args.length < 1) return replygcxlicon('âŒ Enter the text in the zip list');
  let teks = `${text}`;
  {
      if (!ZipXlicon.includes(teks)) return replygcxlicon("âŒ This name does not exist in the database");
      let wanu = ZipXlicon.indexOf(teks);
      ZipXlicon.splice(wanu, 1);
      fs.writeFileSync('./XliconMedia/database/zip.json', JSON.stringify(ZipXlicon));
      fs.unlinkSync(`./XliconMedia/zip/${teks}.zip`);
      replygcxlicon(`âœ… Successfully deleted zip ${teks}`);
  }
}
break;

case 'listzip': {
  let teksooooo = 'ğŸ“¦â”Œâ”€â”€â­“ã€Œ *ZIP LIST* ã€\nâ”‚\n';
  for (let x of ZipXlicon) {
      teksooooo += `â”‚ğŸ—‚ï¸ ${x}\n`;
  }
  teksooooo += `â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â­“\n\n*Total: ${ZipXlicon.length}*`;
  replygcxlicon(teksooooo);
}
break;


case 'addapk': {
  if (!XliconTheCreator) return XliconStickOwner();

  if (args.length < 1) return replygcxlicon('ğŸ“± What is the name of the apk?');
  let teks = `${text}`;
  {
      if (ApkXlicon.includes(teks)) return replygcxlicon("âŒ This name is already in use");
      let delb = await XliconBotInc.downloadAndSaveMediaMessage(quoted);
      ApkXlicon.push(teks);
      await fsx.copy(delb, `./XliconMedia/apk/${teks}.apk`);
      fs.writeFileSync('./XliconMedia/database/apk.json', JSON.stringify(ApkXlicon));
      fs.unlinkSync(delb);
      replygcxlicon(`âœ… Successfully added apk\nTo Check type ${prefix}listapk`);
  }
}
break;

case 'delapk': {
  if (!XliconTheCreator) return XliconStickOwner();

  if (args.length < 1) return replygcxlicon('âŒ Enter the name of the apk to delete');
  let teks = `${text}`;
  {
      if (!ApkXlicon.includes(teks)) return replygcxlicon("âŒ This name does not exist in the database");
      let wanu = ApkXlicon.indexOf(teks);
      ApkXlicon.splice(wanu, 1);
      fs.writeFileSync('./XliconMedia/database/apk.json', JSON.stringify(ApkXlicon));
      fs.unlinkSync(`./XliconMedia/apk/${teks}.apk`);
      replygcxlicon(`âœ… Successfully deleted Apk: ${teks}`);
  }
}
break;

case 'listapk': {
  let teksoooooo = 'ğŸ“±â”Œâ”€â”€â­“ã€Œ *APK LIST* ã€\nâ”‚\n';
  for (let x of ApkXlicon) {
      teksoooooo += `â”‚ğŸ“¦ ${x}\n`;
  }
  teksoooooo += `â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â­“\n\n*Total: ${ApkXlicon.length} APKs*`;
  replygcxlicon(teksoooooo);
}
break;

case 'addpdf': {
  if (!XliconTheCreator) return XliconStickOwner();

  if (args.length < 1) return replygcxlicon('ğŸ“„ What is the name of the pdf?');
  let teks = `${text}`;
  {
      if (DocXlicon.includes(teks)) return replygcxlicon("âŒ This name is already in use");
      let delb = await XliconBotInc.downloadAndSaveMediaMessage(quoted);
      DocXlicon.push(teks);
      await fsx.copy(delb, `./XliconMedia/doc/${teks}.pdf`);
      fs.writeFileSync('./XliconMedia/database/doc.json', JSON.stringify(DocXlicon));
      fs.unlinkSync(delb);
      replygcxlicon(`âœ… Successfully added PDF\nTo check type ${prefix}listpdf`);
  }
}
break;

case 'delpdf': {
  if (!XliconTheCreator) return XliconStickOwner();

  if (args.length < 1) return replygcxlicon('âŒ Enter the name of the PDF to delete');
  let teks = `${text}`;
  {
      if (!DocXlicon.includes(teks)) return replygcxlicon("âŒ This name does not exist in the database");
      let wanu = DocXlicon.indexOf(teks);
      DocXlicon.splice(wanu, 1);
      fs.writeFileSync('./XliconMedia/database/doc.json', JSON.stringify(DocXlicon));
      fs.unlinkSync(`./XliconMedia/doc/${teks}.pdf`);
      replygcxlicon(`âœ… Successfully deleted PDF: ${teks}`);
  }
}
break;

case 'listpdf': {
  let teksoooo = 'ğŸ“„â”Œâ”€â”€â­“ã€Œ *PDF LIST* ã€\nâ”‚\n';
  for (let x of DocXlicon) {
      teksoooo += `â”‚ğŸ“‘ ${x}\n`;
  }
  teksoooo += `â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â­“\n\n*Total: ${DocXlicon.length} PDFs*`;
  replygcxlicon(teksoooo);
}
break;

case 'addmsg': {
  if (!XliconTheCreator) return XliconStickOwner();
  if (!m.quoted) return replygcxlicon('ğŸ”„ Please reply to the message you want to save in the database');
  if (!text) return replygcxlicon(`ğŸ’¡ Example: ${prefix + command} file name`);
  
  let msgs = global.db.database;
  if (text.toLowerCase() in msgs) return replygcxlicon(`âŒ '${text}' is already registered in the message list`);
  
  msgs[text.toLowerCase()] = m.quoted;
  delete msgs[text.toLowerCase()].chat;
  
  replygcxlicon(`âœ… Successfully added the message to the message list as '${text}'\nAccess it with ${prefix}getmsg ${text}\nView the list of messages with ${prefix}listmsg`);
}
break;

case 'delmsg': case 'deletemsg': {
  if (!XliconTheCreator) return XliconStickOwner();
  if (!text) return replygcxlicon('âŒ What is the name of the message you want to delete?');
  
  let msgs = global.db.database;
  if (text == 'allmsg') {
      global.db.database = {};
      replygcxlicon('ğŸ§¹ Successfully deleted all messages from the message list');
  } else {
      if (!(text.toLowerCase() in msgs)) return replygcxlicon(`âŒ '${text}' not found in the message list`);
      delete msgs[text.toLowerCase()];
      replygcxlicon(`âœ… Successfully deleted '${text}' from the message list`);
  }
}
break;

case 'getmsg': {
  if (!text) return replygcxlicon(`ğŸ’¡ Example: ${prefix + command} file name\n\nYou can view the list of messages with ${prefix}listmsg`);
  
  let msgs = global.db.database;
  if (!(text.toLowerCase() in msgs)) return replygcxlicon(`âŒ '${text}' not found in the message list`);
  
  await XliconBotInc.relayMessage(m.chat, msgs[text.toLowerCase()], {});
}
break;

case 'listmsg': {
  let seplit = Object.entries(global.db.database).map(([nama, isi]) => { return { nama, ...isi } });
  let teks = 'ğŸ“œã€Œ *LIST DATABASE* ã€\n\n';
  
  for (let i of seplit) {
      teks += `${setv} *Name:* ${i.nama}\n${setv} *Type:* ${getContentType(i.message)?.replace(/Message/i, '')}\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n`;
  }
  
  replygcxlicon(teks);
}
break;


			case 'addowner':
    if (!XliconTheCreator) return XliconStickOwner();
    if (!args[0]) return replygcxlicon(`ğŸ”‘ Use ${prefix + command} number\nExample: ${prefix + command} ${ownernumber}`);
    
    bnnd = q.split("|")[0].replace(/[^0-9]/g, '');
    let ceknye = await XliconBotInc.onWhatsApp(bnnd);
    
    if (ceknye.length == 0) return replygcxlicon(`âš ï¸ Enter a valid and registered number on WhatsApp!!!`);
    
    owner.push(bnnd);
    fs.writeFileSync('./src/owner.json', JSON.stringify(owner));
    
    replygcxlicon(`âœ… Number ${bnnd} has become an owner!!!`);
    break;

case 'delowner':
    if (!XliconTheCreator) return XliconStickOwner();
    if (!args[0]) return replygcxlicon(`âŒ Use ${prefix + command} number\nExample: ${prefix + command} 916909137213`);
    
    ya = q.split("|")[0].replace(/[^0-9]/g, '');
    unp = owner.indexOf(ya);
    owner.splice(unp, 1);
    fs.writeFileSync('./src/owner.json', JSON.stringify(owner));
    
    replygcxlicon(`âš ï¸ The number ${ya} has been deleted from the owner list by the owner!!!`);
    break;

case 'listowner':
    let teks = 'â”Œâ”€â”€â­“ã€Œ *List Owner* ã€\nâ”‚\n';
    for (let x of owner) {
        teks += `â”‚ğŸ‘‘ ${x}\n`;
    }
    teks += `â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â­“\n\n*Total Owners: ${owner.length}*`;
    
    replygcxlicon(teks);
    break;

case 'shutdown':
    if (!XliconTheCreator) return XliconStickOwner();
    replygcxlicon(`ğŸ”„ Restarting the bot. This will take a few seconds...`);
    
    await sleep(3000);
    process.exit();
    break;

			  case 'userjid':
  case 'jid':
  case 'groupjid':
            case 'id':{
            replygcxlicon(m.chat)
           }
          break


          case 'banchat': {
            if (!XliconTheCreator) {
                if (m.isGroup) {
                    const groupId = m.chat;
                    
                    try {
                        // Load the list of banned groups from the JSON file
                        let bannedGroups = require('./database/jid.json');
                        
                        // Check if the group is already banned
                        if (!bannedGroups.includes(groupId)) {
                            // Add the group ID to the list of banned groups
                            bannedGroups.push(groupId);
                            
                            // Save the updated list to the JSON file
                            const fs = require('fs');
                            fs.writeFileSync('./database/jid.json', JSON.stringify(bannedGroups, null, 2));
                            
                            // Notify the group that it has been banned
                            replygcxlicon(`ğŸš« This chat has been banned from using the bot.`);
                            
                            // Leave the group
                            await XliconBotInc.groupLeave(groupId);
                            replygcxlicon(`ğŸ‘‹ The bot has left the group.`);
                        } else {
                            replygcxlicon(`âš ï¸ This chat is already banned.`);
                        }
                    } catch (error) {
                        console.error(error);
                        replygcxlicon(`âŒ An error occurred while banning this chat.`);
                    }
                } else {
                    replygcxlicon(`âš ï¸ This command can only be used in a group chat.`);
                }
            } else {
                replygcxlicon(`âŒ Only the bot owner can use this command.`);
            }
        }
        break;
          
           



        case 'getexif': case 'getwm': case 'getwatermark': {
          if (!XliconTheCreator) return XliconStickOwner()
          replygcxlicon(`*Water Mark/Exif of ${botname} is* ğŸ–¼ï¸\n\n${setv} ğŸ“¦ Packname : ${packname}\n${setv} âœ’ï¸ Author : ${author}`)
      }
      break
      
      case 'getautoblocknumber': case 'getautoblockno': case 'getautoblock': {
          if (!XliconTheCreator) return XliconStickOwner()
          replygcxlicon(`*Auto Block Country Code of ${botname} is* ğŸŒ\n\n${setv} ğŸ‡ºğŸ‡³ Country Code : ${autoblocknumber}\n\n_Note: Once autoblock number is activated, numbers related to this country code will be blocked automatically_ ğŸš«`)
      }
      break
      
      case 'getantiforeign': case 'getantiforeignno': case 'getantiforeignnumber': {
          if (!XliconTheCreator) return XliconStickOwner()
          replygcxlicon(`*Anti Foreign Country Code of ${botname} is* ğŸ›¡ï¸\n\n${setv} ğŸŒ Country Code : ${antiforeignnumber}\n\n_Note: Once antiforeign number is activated in any group chat, only members related to this country code are allowed to stay in the group chat, others will be kicked immediately, if chatted._ âŒ`)
      }
      break
      
      case 'setexif': case 'setwm': {
          if (!XliconTheCreator) return XliconStickOwner()
          if (!text) return replygcxlicon(`Example : ${prefix + command} packname|author ğŸ’¡`)
          global.packname = text.split("|")[0]
          global.author = text.split("|")[1]
          replygcxlicon(`Exif successfully changed to âœ…\n\nâ€¢ ğŸ“¦ Packname : ${global.packname}\nâ€¢ âœ’ï¸ Author : ${global.author}`)
      }
      break
      
      case 'creategc': case 'creategroup': {
          if (!XliconTheCreator) return XliconStickOwner()
          if (!args.join(" ")) return replygcxlicon(`Use ${prefix + command} groupname âœï¸`)
          try {
              let cret = await XliconBotInc.groupCreate(args.join(" "), [])
              let response = await XliconBotInc.groupInviteCode(cret.id)
              const teksop = `     ã€Œ Create Group ã€ ğŸ—ï¸
      
      â–¸ ğŸ·ï¸ Name : ${cret.subject}
      â–¸ ğŸ‘¤ Owner : @${cret.owner.split("@")[0]}
      â–¸ ğŸ“… Creation : ${moment(cret.creation * 1000).tz("Asia/Karachi").format("DD/MM/YYYY HH:mm:ss")}
      
      ğŸ”— https://chat.whatsapp.com/${response}`
              XliconBotInc.sendMessage(m.chat, { text: teksop, mentions: await XliconBotInc.parseMention(teksop)}, {quoted: m})
          } catch {
              replygcxlicon(`Error âš ï¸`)
          }
      }
      break
      
      case 'resetuser': case 'resetdbuser': {
          if (!XliconTheCreator) return XliconStickOwner()
          let totalusernya = db.users[0]
          replygcxlicon(`Successfully Deleted ${totalusernya} Users in Database ğŸ—‘ï¸`)
          db.users = []
      }
      break
      
      case 'resethit': case 'resettotalhit': {
          if (!XliconTheCreator) return XliconStickOwner()
          global.db.settings[botNumber].totalhit = 0
          replygcxlicon(`Done! âœ…`)
      }
      break
      
      case 'setreply': {
          if (!XliconTheCreator) return XliconStickOwner()
          if (!text) return replygcxlicon(`There are 4 reply options (v1, v2, v3, v4) ğŸ“¬\nPlease select one.\nExample: ${prefix + command} v1 ğŸ’­`)
      
          // Handle button responses
          if (text.startsWith('v')) {
              typereply = text;  // Set the selected reply option
      
              // Map button IDs to reply text
              const buttonTextMap = {
                  [`${prefix + command} v1`]: "ğŸ“ QUOTED NORMALLY",
                  [`${prefix + command} v2`]: "ğŸ”— LINK + FAKE THUMBNAIL",
                  [`${prefix + command} v3`]: "ğŸ“ LARGE LINK + THUMBNAIL",
                  [`${prefix + command} v4`]: "ğŸ“¡ CHANNEL + LINK THUMB"
              };
      
              // Check if the selected reply is valid
              if (buttonTextMap[text]) {
                  return replygcxlicon(`You selected: ${buttonTextMap[text]} âœ”ï¸`);
              } else {
                  return replygcxlicon("Invalid reply option selected. âŒ");
              }
          } else {
              return replygcxlicon(`There are 4 reply options (v1, v2, v3, v4) ğŸ“¬\nPlease select one.\nExample: ${prefix + command} v1 ğŸ’­`);
          }
          break;
      }
      
            case 'statustext': 
            case 'upswtext':
            case 'upswteks': {
               if (!XliconTheCreator) return XliconStickOwner()
               if (!q) return replygcxlicon('Text?')
               await XliconBotInc.sendMessage('status@broadcast', { text: q }, { backgroundColor: '#FF000000', font: 3, statusJidList: Object.keys(global.db.users) })
               replygcxlicon(mess.done)
            }
            break
            case 'statusvideo':
            case 'upswvideo': {
               if (!XliconTheCreator) return XliconStickOwner()
               if (/video/.test(mime)) {
                  var videosw = await XliconBotInc.downloadAndSaveMediaMessage(quoted)
                  await XliconBotInc.sendMessage('status@broadcast', {
                     video: {
                        url: videosw
                     },
                     caption: q ? q : ''
                  }, { statusJidList: Object.keys(global.db.users) })
                  await replygcxlicon(mess.done)
               } else {
                  replygcxlicon('Reply to video')
               }
            }
            break
            case 'statusimg':
            case 'statusimage':
            case 'upswimg': {
               if (!XliconTheCreator) return XliconStickOwner()
               if (/image/.test(mime)) {
                  var imagesw = await XliconBotInc.downloadAndSaveMediaMessage(quoted)
                  await XliconBotInc.sendMessage('status@broadcast', {
                     image: {
                        url: imagesw
                     },
                     caption: q ? q : ''
                  }, { statusJidList: Object.keys(global.db.users)})
                  await replygcxlicon(mess.done)
               } else {
                  replygcxlicon('Reply to image')
               }
            }
            break
            case 'statusaudio':
            case 'upswaudio': {
               if (!XliconTheCreator) return XliconStickOwner()
               if (/audio/.test(mime)) {
                  var audiosw = await XliconBotInc.downloadAndSaveMediaMessage(quoted)
                  await XliconBotInc.sendMessage('status@broadcast', {
                     audio: {
                        url: audiosw
                     },
                     mimetype: 'audio/mp4',
                     ptt: true
                  }, {
                     backgroundColor: '#FF000000',
                     statusJidList: Object.keys(global.db.users)
                  })
                  await replygcxlicon(mess.done)
               } else {
                  replygcxlicon('Reply to audio')
               }
            }
            break
            case 'setvidmenu':
              case 'svm':
              case 'setvgifmenu':
              case 'sgm': {
                  if (!XliconTheCreator) return XliconStickOwner()
                  try {
                      let delb = await XliconBotInc.downloadAndSaveMediaMessage(quoted)
                      await fsx.copy(delb, './XliconMedia/theme/Xlicon-Video.mp4')
                      fs.unlinkSync(delb)
                      replygcxlicon(`Done! ğŸ‰ Video menu successfully set! ğŸ¬`)
                  } catch {
                      replygcxlicon(`Please reply to a video with caption ${prefix + command} ğŸ¥`)
                  }
              }
              break
              
              case 'setimgmenu':
              case 'sim': {
                  if (!XliconTheCreator) return XliconStickOwner()
                  try {
                      let delb = await XliconBotInc.downloadAndSaveMediaMessage(quoted)
                      await fsx.copy(delb, './XliconMedia/theme/XliconPic.jpg')
                      fs.unlinkSync(delb)
                      replygcxlicon(`Done! ğŸ‰ Image menu successfully set! ğŸ–¼ï¸`)
                  } catch {
                      replygcxlicon(`Please reply to an image with caption ${prefix + command} ğŸ“¸`)
                  }
              }
              break
              
              case 'setmenu': {
                  if (!XliconTheCreator) return XliconStickOwner()
              
                  // Check if the input starts with 'v' and set the menu accordingly
                  if (text.startsWith('v')) {
                      typemenu = text;  // Set the selected menu type
                      return replygcxlicon(`Successfully set menu to: ${text} âœ…`);  // Notify the user
                  } else {
                      // If the input is not valid, show the available menu options
                      return replygcxlicon(`
                          Please select a menu option by specifying 'v' followed by the choice ğŸ“‹.
              
                          Available menu options:
                          - v12: BUTTON + CHANNEL V2 ğŸ“± + ğŸ“º
                          - v11: BUTTON + CHANNEL ğŸ“± + ğŸ“º
                          - v10: ONLY BUTTON ğŸ”˜
                          - v9: CHANNEL + FAKE THUMBNAIL V2 ğŸ“º + ğŸ–¼ï¸
                          - v8: CHANNEL + FAKE THUMBNAIL ğŸ“º + ğŸ–¼ï¸
                          - v7: FAKE THUMBNAIL + DOCUMENT ğŸ–¼ï¸ + ğŸ“„
                          - v6: FAKE PAYMENT ğŸ’³
                          - v5: CALL SCHEDULE ğŸ“ğŸ“…
                          - v4: GIF THUMBNAIL ğŸï¸
                          - v3: VIDEO THUMBNAIL ğŸ¥ğŸ–¼ï¸
                          - v2: CHANNEL + THUMBNAIL ğŸ“º + ğŸ–¼ï¸
                          - v1: IMAGE THUMBNAIL ğŸ–¼ï¸
              
                          Example: ${prefix + command} v1
                      `);
                  }
                  break;
              }
              
			case 'bc':
            case 'broadcast': {
               if (!XliconTheCreator) return XliconStickOwner()
               if (!text) return replygcxlicon('Text?')
               let teksnya = `${text}\n\n\n\nDate: ${xdate} ${xtime}`
               for (let i of Object.keys(global.db.users)) {
               await sleep(1500)
                  if (/image/.test(mime)) {
                     var media = await quoted.download()
                     await XliconBotInc.sendMessage(i, { 
                        image:media,
                        caption: teksnya
                     })
                  } else if (/video/.test(mime)) {
                     var media = await quoted.download()
                     await XliconBotInc.sendMessage(i, {
                        video: media,
                        caption: teksnya
                     })
                  } else if (text) {
                     await XliconBotInc.sendMessage(i, {
                        text: teksnya
                     })
                  }
               }
               replygcxlicon(`Success ${command} To ${Object.keys(global.db.users).length} Users`)
            }
            break
            case 'bcgc':
            case 'bcgroup': {
                if (!XliconTheCreator) return XliconStickOwner()
                if (!text) return replygcxlicon(`Text mana?\n\nExample : ${prefix + command} Besok Libur `)
                let getGroups = await XliconBotInc.groupFetchAllParticipating()
                let groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
                let anu = groups.map(v => v.id)
                replygcxlicon(`Sending Broadcast To ${anu.length} Group Chat, End Time ${anu.length * 1.5} seconds`)
                for (let i of anu) {
                    await sleep(1500)
                    let a = `${ownername}'s Broadcast\n\n` + '```' + `Message: ${text}\n\n` + '```'
                    XliconBotInc.sendMessage(i, {
                        text: a,
                        contextInfo: {
                            externalAdReply: {
                                showAdAttribution: true,
                                title: botname,
                                body: `Sent in ${i.length} Group`,
                                thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
                                sourceUrl: wagc,
                                mediaType: 1,
                                renderLargerThumbnail: true
                            }
                        }
                    })
                }
                replygcxlicon(`Successful in sending Broadcast To ${anu.length} Group`)
            }
            break
            case 'spam':
              if (!XliconTheCreator) return XliconStickOwner()
              if (!text) return replygcxlicon(`Use ${prefix + command} text|amount ğŸ“`)
              
              xliconarg = text.split("|")
              if (!xliconarg) return replygcxlicon(`Use ${prefix + command} text|amount ğŸ“`)
              
              if (Number(xliconarg[1]) >= 50) return replygcxlicon('Max 50! ğŸš«')
              
              if (isNaN(xliconarg[1])) return replygcxlicon(`The amount must be a number ğŸ”¢`)
          
              // Send the message multiple times
              for (let i = 0; i < xliconarg[1]; i++) {
                  XliconBotInc.sendMessage(m.chat, {text: xliconarg[0]})
              }
          
              replygcxlicon(`Successfully sent ${xliconarg[1]} messages âœ‰ï¸!`)
              break
          
			case 'antiforeign': {
    if (!m.isGroup) return XliconStickGroup();
    if (!m.isBotAdmin) return XliconStickBotAdmin();
    if (!m.isAdmin && !XliconTheCreator) return XliconStickAdmin();

    // Check the command argument for enabling or disabling the feature
    if (args[0] === 'on') {
        db.groups[m.chat].antiforeignnum = true;
        return replygcxlicon(`${command} is enabled.`);
    } else if (args[0] === 'off') {
        db.groups[m.chat].antiforeignnum = false;
        return replygcxlicon(`${command} is disabled.`);
    } else {
        // Show message with options when invalid argument is provided
        return replygcxlicon(`
            Please choose an option to enable or disable ${command}.

            Usage:
            - ${prefix + command} on  : Enable ${command}
            - ${prefix + command} off : Disable ${command}

            Example: ${prefix + command} on
        `);
    }
    break;
}


            case 'poll': {
	if (!XliconTheCreator) return XliconStickOwner()
            let [poll, opt] = text.split("|")
            if (text.split("|") < 2)
                return await replygcxlicon(
                    `Mention question and atleast 2 options\nExample: ${prefix}poll Who is best admin?|Xlicon,Cheems,Doge...`
                )
            try {
            let options = []
            for (let i of opt.split(',')) {
                options.push(i)
            }
            await XliconBotInc.sendMessage(m.chat, {
                poll: {
                    name: poll,
                    values: options
                }
            })
            } catch {
            	replygcxlicon(
                    `Mention question and atleast 2 options\nExample: ${prefix}poll Who is best admin?|Xlicon,Cheems,Doge...`
                )
                }
        }
        break
			case 'autoblock':
    if (!XliconTheCreator) return XliconStickOwner();
    
    if (q == 'on') {
        db.settings[botNumber].autoblocknum = true;
        return replygcxlicon(`Successfully changed Auto-Block to ${q}`);
    } else if (q == 'off') {
        db.settings[botNumber].autoblocknum = false;
        return replygcxlicon(`Successfully changed Auto-Block to ${q}`);
    } else {
        return replygcxlicon(`
            Please choose an option to enable or disable ${command}.

            Usage:
            - ${prefix + command} on  : Enable Auto-Block
            - ${prefix + command} off : Disable Auto-Block

            Example: ${prefix + command} on
        `);
    }
    break;

case 'onlygroup':
case 'onlygc':
    if (!XliconTheCreator) return XliconStickOwner();
    
    if (q == 'on') {
        db.settings[botNumber].onlygrub = true;
        return replygcxlicon(`Successfully changed Onlygroup to ${q}`);
    } else if (q == 'off') {
        db.settings[botNumber].onlygrub = false;
        return replygcxlicon(`Successfully changed Onlygroup to ${q}`);
    } else {
        return replygcxlicon(`
            Please choose an option to enable or disable ${command}.

            Usage:
            - ${prefix + command} on  : Enable Onlygroup
            - ${prefix + command} off : Disable Onlygroup

            Example: ${prefix + command} on
        `);
    }
    break;

        case 'onlyprivatechat':
case 'onlypc':
    if (!XliconTheCreator) return XliconStickOwner();
    if (q == 'on') {
        db.settings[botNumber].onlypc = true;
        replygcxlicon(`Successfully Changed Only-Pc To ${q}`);
    } else if (q == 'off') {
        db.settings[botNumber].onlypc = false;
        replygcxlicon(`Successfully Changed Only-Pc To ${q}`);
    } else {
        return replygcxlicon(`
            Please choose an option to enable or disable ${command}.

            Usage:
            - ${prefix + command} on  : Enable Only-Pc
            - ${prefix + command} off : Disable Only-Pc

            Example: ${prefix + command} on
        `);
    }
    break;

case 'onlyindia':
case 'onlyindianumber':
    if (!XliconTheCreator) return XliconStickOwner();
    if (q == 'on') {
        db.settings[botNumber].onlyindia = true;
        replygcxlicon(`Successfully Changed Only-Indian To ${q}`);
    } else if (q == 'off') {
        db.settings[botNumber].onlyindia = false;
        replygcxlicon(`Successfully Changed Only-Indian To ${q}`);
    } else {
        return replygcxlicon(`
            Please choose an option to enable or disable ${command}.

            Usage:
            - ${prefix + command} on  : Enable Only-Indian
            - ${prefix + command} off : Disable Only-Indian

            Example: ${prefix + command} on
        `);
    }
    break;

case 'onlyindo':
case 'onlyindonumber':
    if (!XliconTheCreator) return XliconStickOwner();
    if (q == 'on') {
        db.settings[botNumber].onlyindo = true;
        replygcxlicon(`Successfully Changed Only-Indonesian To ${q}`);
    } else if (q == 'off') {
        db.settings[botNumber].onlyindo = false;
        replygcxlicon(`Successfully Changed Only-Indonesian To ${q}`);
    } else {
        return replygcxlicon(`
            Please choose an option to enable or disable ${command}.

            Usage:
            - ${prefix + command} on  : Enable Only-Indonesian
            - ${prefix + command} off : Disable Only-Indonesian

            Example: ${prefix + command} on
        `);
    }
    break;

case 'setautoblock':
    if (!XliconTheCreator) return XliconStickOwner();
    if (!text) return replygcxlicon(`Example : ${prefix + command} 92`);
    global.autoblocknumber = text;
    replygcxlicon(`Auto-Block number successfully changed to ${text}`);
    break;

case 'setantiforeign':
    if (!XliconTheCreator) return XliconStickOwner();
    if (!text) return replygcxlicon(`Example : ${prefix + command} 91`);
    global.antiforeignnumber = text;
    replygcxlicon(`Anti-foreign number successfully changed to ${text}`);
    break;

case 'autoswview':
case 'autostatusview':
    if (!XliconTheCreator) return XliconStickOwner();
    if (args[0] === 'on') {
        db.settings[botNumber].antiswview = true;
        replygcxlicon(`${command} is enabled`);
    } else if (args[0] === 'off') {
        db.settings[botNumber].antiswview = false;
        replygcxlicon(`${command} is disabled`);
    } else {
        return replygcxlicon(`
            Please choose an option to enable or disable ${command}.

            Usage:
            - ${prefix + command} on  : Enable ${command}
            - ${prefix + command} off : Disable ${command}

            Example: ${prefix + command} on
        `);
    }
    break;

case 'anticall':
    if (!XliconTheCreator) return XliconStickOwner();
    if (args[0] === 'on') {
        db.settings[botNumber].anticall = true;
        replygcxlicon(`${command} is enabled`);
    } else if (args[0] === 'off') {
        db.settings[botNumber].anticall = false;
        replygcxlicon(`${command} is disabled`);
    } else {
        return replygcxlicon(`
            Please choose an option to enable or disable ${command}.

            Usage:
            - ${prefix + command} on  : Enable Anti-Call
            - ${prefix + command} off : Disable Anti-Call

            Example: ${prefix + command} on
        `);
    }
    break;

case 'autorecordtype':
    if (!XliconTheCreator) return XliconStickOwner();
    if (q === 'on') {
        db.settings[botNumber].autorecordtype = true;
        replygcxlicon(`Successfully changed Auto-RecordingTyping to ${q}`);
    } else if (q === 'off') {
        db.settings[botNumber].autorecordtype = false;
        replygcxlicon(`Successfully changed Auto-RecordingTyping to ${q}`);
    } else {
        return replygcxlicon(`
            Please choose an option to enable or disable ${command}.

            Usage:
            - ${prefix + command} on  : Enable Auto-RecordingTyping
            - ${prefix + command} off : Disable Auto-RecordingTyping

            Example: ${prefix + command} on
        `);
    }
    break;

case 'autorecord':
    if (!XliconTheCreator) return XliconStickOwner();
    if (q === 'on') {
        db.settings[botNumber].autorecord = true;
        replygcxlicon(`Successfully changed Auto-Recording to ${q}`);
    } else if (q === 'off') {
        db.settings[botNumber].autorecord = false;
        replygcxlicon(`Successfully changed Auto-Recording to ${q}`);
    } else {
        return replygcxlicon(`
            Please choose an option to enable or disable ${command}.

            Usage:
            - ${prefix + command} on  : Enable Auto-Recording
            - ${prefix + command} off : Disable Auto-Recording

            Example: ${prefix + command} on
        `);
    }
    break;

        
case 'autotype':
    if (!XliconTheCreator) return XliconStickOwner();

    if (q === 'on') {
        db.settings[botNumber].autotype = true;
        return replygcxlicon(`Successfully changed Auto-Typing to ${q}`);
    } else if (q === 'off') {
        db.settings[botNumber].autotype = false;
        return replygcxlicon(`Successfully changed Auto-Typing to ${q}`);
    } else {
        return replygcxlicon(`
            Please choose an option to enable or disable ${command}.

            Usage:
            - ${prefix + command} on  : Enable Auto-Typing
            - ${prefix + command} off : Disable Auto-Typing

            Example: ${prefix + command} on
        `);
    }
    break;

case 'autoread':
    if (!XliconTheCreator) return XliconStickOwner();

    if (q === 'on') {
        db.settings[botNumber].autoread = true;
        return replygcxlicon(`Successfully changed Auto-Read to ${q}`);
    } else if (q === 'off') {
        db.settings[botNumber].autoread = false;
        return replygcxlicon(`Successfully changed Auto-Read to ${q}`);
    } else {
        return replygcxlicon(`
            Please choose an option to enable or disable ${command}.

            Usage:
            - ${prefix + command} on  : Enable Auto-Read
            - ${prefix + command} off : Disable Auto-Read

            Example: ${prefix + command} on
        `);
    }
    break;

case 'autobio':
    if (!XliconTheCreator) return XliconStickOwner();

    if (q == 'on') {
        db.settings[botNumber].autobio = true;
        return replygcxlicon(`Successfully changed AutoBio to ${q}`);
    } else if (q == 'off') {
        db.settings[botNumber].autobio = false;
        return replygcxlicon(`Successfully changed AutoBio to ${q}`);
    } else {
        return replygcxlicon(`
            Please choose an option to enable or disable ${command}.

            Usage:
            - ${prefix + command} on  : Enable AutoBio
            - ${prefix + command} off : Disable AutoBio

            Example: ${prefix + command} on
        `);
    }
    break;

        
			case 'self': case 'public': case 'mode': {
    if (!XliconTheCreator) return XliconStickOwner();

    // Check if the command is to toggle on or off directly
    if (q == 'on') {
        XliconBotInc.public = true;
        replygcxlicon('*Successfully changed to Public Usage*');
    } else if (q == 'off') {
        XliconBotInc.public = false;
        replygcxlicon('*Successfully changed to Self Usage*');
    } else {
        // Send a direct message indicating the change
        replygcxlicon('Please specify the mode you want to switch to:\n- `on` for Public Usage\n- `off` for Self Usage');
    }
}
break;

			case 'setbio': case 'setbotbio': {
				if (!XliconTheCreator) return XliconStickOwner()
				if (!text) return replygcxlicon(`Where's the text??`)
				XliconBotInc.setStatus(q)
				replygcxlicon(`*Bio has been changed to ${q}*`)
			}
			break


			case 'setbotpp':
            case 'setpp':
            case 'setpp':
            case 'setppbot':
                if (!XliconTheCreator) return XliconStickOwner()
                if (!quoted) return replygcxlicon(`Send/Reply Image With Caption ${prefix + command}`)
                if (!/image/.test(mime)) return replygcxlicon(`Send/Reply Image With Caption ${prefix + command}`)
                if (/webp/.test(mime)) return replygcxlicon(`Send/Reply Image With Caption ${prefix + command}`)
                var medis = await XliconBotInc.downloadAndSaveMediaMessage(quoted, 'ppbot.jpeg')
                if (args[0] == 'full') {
                    var {
                        img
                    } = await generateProfilePicture(medis)
                    await XliconBotInc.query({
                        tag: 'iq',
                        attrs: {
                            to: botNumber,
                            type: 'set',
                            xmlns: 'w:profile:picture'
                        },
                        content: [{
                            tag: 'picture',
                            attrs: {
                                type: 'image'
                            },
                            content: img
                        }]
                    })
                    fs.unlinkSync(medis)
                    replygcxlicon(mess.done)
                } else {
                    var memeg = await XliconBotInc.updateProfilePicture(botNumber, {
                        url: medis
                    })
                    fs.unlinkSync(medis)
                    replygcxlicon(mess.done)
                }
                break
			case 'join': {
				if (!XliconTheCreator) return XliconStickOwner()
				if (!text) return replygcxlicon('Enter Group Link!')
				if (!isUrl(args[0]) && !args[0].includes('whatsapp.com')) return replygcxlicon('Link Invalid!')
				const result = args[0].split('https://chat.whatsapp.com/')[1]
				XliconStickWait()
				await XliconBotInc.groupAcceptInvite(result).catch((res) => {
					if (res.data == 400) return replygcxlicon('Group Not Foundâ—');
					if (res.data == 401) return replygcxlicon('Bot Kicked From The Groupâ—');
					if (res.data == 409) return replygcxlicon('Bots Have Joined the Groupâ—');
					if (res.data == 410) return replygcxlicon('Group URL Has Been Resetâ—');
					if (res.data == 500) return replygcxlicon('Full Groupâ—');
				})
			}
			break
			case 'leave': case 'leavegc': {
				if (!XliconTheCreator) return XliconStickOwner()
				await XliconBotInc.groupLeave(m.chat).then((res) => replygcxlicon(jsonformat(res))).catch((err) => replygcxlicon(jsonformat(err)))
			}
			break
			case 'blokir': case 'block': {
				if (!XliconTheCreator) return XliconStickOwner()
				if (!text && !m.quoted) {
					replygcxlicon(`Example: ${prefix + command} 91xxx`)
				} else {
					const numbersOnly = m.isGroup ? (text ? text.replace(/\D/g, '') + '@s.whatsapp.net' : m.quoted?.sender) : m.chat
					await XliconBotInc.updateBlockStatus(numbersOnly, 'block').then((a) => replygcxlicon(mess.done)).catch((err) => replygcxlicon('Fail!'))
				}
			}
			break
			case 'openblokir': case 'unblokir': case 'openblock': case 'unblock': {
				if (!XliconTheCreator) return XliconStickOwner()
				if (!text && !m.quoted) {
					replygcxlicon(`Example: ${prefix + command} 91xxx`)
				} else {
					const numbersOnly = m.isGroup ? (text ? text.replace(/\D/g, '') + '@s.whatsapp.net' : m.quoted?.sender) : m.chat
					await XliconBotInc.updateBlockStatus(numbersOnly, 'unblock').then((a) => replygcxlicon(mess.done)).catch((err) => replygcxlicon('Fail!'))
				}
			}
			break
			case 'listpc': {
				if (!XliconTheCreator) return XliconStickOwner()
				let anu = await store.chats.all().filter(v => v.id.endsWith('.net')).map(v => v.id)
				let teks = `â¬£ *LIST PERSONAL CHAT*\n\nTotal Chat : ${anu.length} Chat\n\n`
				for (let i of anu) {
					let nama = store.messages[i].array[0].pushName
					teks += `${setv} *Name :* ${nama}\n${setv} *User :* @${i.split('@')[0]}\n${setv} *Chat :* https://wa.me/${i.split('@')[0]}\n\n=====================\n\n`
				}
				XliconBotInc.sendTextMentions(m.chat, teks, m)
			}
			break
			case 'listgc': {
				if (!XliconTheCreator) return XliconStickOwner()
				let anu = await store.chats.all().filter(v => v.id.endsWith('@g.us')).map(v => v.id)
				let teks = `â¬£ *LIST GROUP CHAT*\n\nTotal Group : ${anu.length} Group\n\n`
				for (let i of anu) {
					let metadata = await XliconBotInc.groupMetadata(i)
					teks += `${setv} *Name :* ${metadata.subject}\n${setv} *Admin :* ${metadata.owner ? `@${metadata.owner.split('@')[0]}` : '-' }\n${setv} *ID :* ${metadata.id}\n${setv} *Made :* ${moment(metadata.creation * 1000).tz('Asia/Karachi').format('DD/MM/YYYY HH:mm:ss')}\n${setv} *Member :* ${metadata.participants.length}\n\n=====================\n\n`
				}
				XliconBotInc.sendTextMentions(m.chat, teks, m)
			}
			break
			case 'creategc': {
				if (!XliconTheCreator) return XliconStickOwner()
				if (!text) return replygcxlicon(`Example:\n${prefix + command} *Gc Name*`)
				let group = await XliconBotInc.groupCreate(q, [m.sender])
				let res = await XliconBotInc.groupInviteCode(group.id)
				await XliconBotInc.sendMessage(m.chat, { text: `*Link Group :* *https://chat.whatsapp.com/${res}*\n\n*Group Name :* *${q}*`, detectLink: true }, { quoted: m });
				await XliconBotInc.groupParticipantsUpdate(group.id, [m.sender], 'promote')
				await XliconBotInc.sendMessage(group.id, { text: 'Done' })
			}
			break
			case 'addpr': case 'addprem': case 'addpremium': {
				if (!XliconTheCreator) return XliconStickOwner()
				if (!text) return replygcxlicon(`Example:\n${prefix + command} @tag|time(s/m/h/d)`)
				let [teks1, teks2] = text.split`|`
				const nmrnya = teks1.replace(/[^0-9]/g, '') + '@s.whatsapp.net'
				const onWa = await XliconBotInc.onWhatsApp(nmrnya)
				if (!onWa.length > 0) return replygcxlicon('This number is not registered on WhatsApp!')
				if (teks2) {
					prem.addPremiumUser(nmrnya, teks2, premium);
					replygcxlicon(`Success ${command} @${nmrnya.split('@')[0]} During ${teks2}`)
					global.db.users[nmrnya].limit = global.db.users[nmrnya].vip ? global.limit.vip : global.limit.premium
					global.db.users[nmrnya].uang = global.db.users[nmrnya].vip ? global.uang.vip : global.uang.premium
				} else {
					replygcxlicon(`Enter the time!\nExample: ${prefix + command} @tag|time`)
				}
			}
			break
			case 'delpr': case 'delprem': case 'delpremium': {
				if (!XliconTheCreator) return XliconStickOwner()
				if (!text) return replygcxlicon(`Example:\n${prefix + command} @tag`)
				const nmrnya = text.replace(/[^0-9]/g, '') + '@s.whatsapp.net'
				if (prem.checkPremiumUser(nmrnya, premium)) {
					premium.splice(prem.getPremiumPosition(nmrnya, premium), 1);
					fs.writeFileSync('./database/premium.json', JSON.stringify(premium));
					replygcxlicon(`Sukses ${command} @${nmrnya.split('@')[0]}`)
					global.db.users[nmrnya].limit = global.db.users[nmrnya].vip ? global.limit.vip : global.limit.free
					global.db.users[nmrnya].uang = global.db.users[nmrnya].vip ? global.uang.vip : global.uang.free
				} else {
					replygcxlicon(`User @${nmrnya.split('@')[0]} Not Premiumâ—`)
				}
			}
			break
			case 'listpr': case 'listprem': case 'listpremium': {
				if (!XliconTheCreator) return XliconStickOwner()
				let txt = `*------ã€Œ LIST PREMIUM ã€------*\n\n`
				for (let userprem of premium) {
					txt += `â¸ *Number*: @${userprem.id.split('@')[0]}\nâ¸ *Limit*: ${global.db.users[userprem.id].limit}\nâ¸ *Money*: ${global.db.users[userprem.id].uang.toLocaleString('id-ID')}\nâ¸ *Expired*: ${formatDate(userprem.expired)}\n\n`
				}
				replygcxlicon(txt)
			}
			break
			
			// Group Menu
			case 'add': {
				if (!m.isGroup) return XliconStickGroup()
				if (!m.isAdmin) return XliconStickAdmin()
				if (!m.isBotAdmin) return XliconStickBotAdmin()
				if (!text && !m.quoted) {
					replygcxlicon(`EXAMPLE: ${prefix + command} 91xxx`)
				} else {
					const numbersOnly = text ? text.replace(/\D/g, '') + '@s.whatsapp.net' : m.quoted?.sender
					try {
						await XliconBotInc.groupParticipantsUpdate(m.chat, [numbersOnly], 'add').then(async (res) =>{
							for (let i of res) {
								let invv = await XliconBotInc.groupInviteCode(m.chat)
								if (i.status == 408) return replygcxlicon('User Just Left This Group!')
								if (i.status == 401) return replygcxlicon('User Blocked The Bot!')
								if (i.status == 409) return replygcxlicon('User has joined!')
								if (i.status == 500) return replygcxlicon('Group Full!')
								if (i.status == 403) {
									await XliconBotInc.sendMessage(m.chat, { text: `@${numbersOnly.split('@')[0]} Cannot Be Added\n\nBecause Target Private\n\nInvitations will be sent to\n-> wa.me/${numbersOnly.replace(/\D/g, '')}\nVia Private Chat`, mentions: [numbersOnly] }, { quoted : m })
									await XliconBotInc.sendMessage(`${numbersOnly ? numbersOnly : '916909137213@s.whatsapp.net'}`, { text: `${'https://chat.whatsapp.com/' + invv}\n------------------------------------------------------\n\nAdmin: wa.me/${m.sender}\nInvite you to this group\nPlease enter if you wishğŸ™‡`, detectLink: true, mentions: [numbersOnly] }, { quoted : floc2 }).catch((err) => replygcxlicon('Failed to Send Invitation!'))
								} else {
									replygcxlicon('Success!!')
								}
							}
						})
					} catch (e) {
						replygcxlicon('Failed to Add User')
					}
				}
			}
			break
			case 'kick': {
				if (!m.isGroup) return XliconStickGroup()
				if (!m.isAdmin) return XliconStickAdmin()
				if (!m.isBotAdmin) return XliconStickBotAdmin()
				if (!text && !m.quoted) {
					replygcxlicon(`Example: ${prefix + command} 91xxx`)
				} else {
					const numbersOnly = text ? text.replace(/\D/g, '') + '@s.whatsapp.net' : m.quoted?.sender
					await XliconBotInc.groupParticipantsUpdate(m.chat, [numbersOnly], 'remove').catch((err) => replygcxlicon('Failed to Kick User!'))
				}
			}
			break
			case 'promote': {
				if (!m.isGroup) return XliconStickGroup()
				if (!m.isAdmin) return XliconStickAdmin()
				if (!m.isBotAdmin) return XliconStickBotAdmin()
				if (!text && !m.quoted) {
					replygcxlicon(`Example: ${prefix + command} 91xxx`)
				} else {
					const numbersOnly = text ? text.replace(/\D/g, '') + '@s.whatsapp.net' : m.quoted?.sender
					await XliconBotInc.groupParticipantsUpdate(m.chat, [numbersOnly], 'promote').catch((err) => replygcxlicon('Fail!'))
					replygcxlicon(mess.done)
				}
			}
			break
			case 'demote': {
				if (!m.isGroup) return XliconStickGroup()
				if (!m.isAdmin) return XliconStickAdmin()
				if (!m.isBotAdmin) return XliconStickBotAdmin()
				if (!text && !m.quoted) {
					replygcxlicon(`Example: ${prefix + command} 91xxx`)
				} else {
					const numbersOnly = text ? text.replace(/\D/g, '') + '@s.whatsapp.net' : m.quoted?.sender
					await XliconBotInc.groupParticipantsUpdate(m.chat, [numbersOnly], 'demote').catch((err) => replygcxlicon('Failed!'))
					replygcxlicon(mess.done)
				}
			}
			break
			case 'setnamegc': case 'setsubject': case 'setname': case 'setnamegc': case 'setsubject': case 'setsubjectgc': {
				if (!m.isGroup) return XliconStickGroup()
				if (!m.isAdmin) return XliconStickAdmin()
				if (!m.isBotAdmin) return XliconStickBotAdmin()
				if (!text && !m.quoted) {
					replygcxlicon(`Example: ${prefix + command} text`)
				} else {
					const teksnya = text ? text : m.quoted.text
					await XliconBotInc.groupUpdateSubject(m.chat, teksnya).catch((err) => replygcxlicon('Fail!'))
				}
			}
			break
			case 'setdesc': case 'setdescgc': case 'setdesk': case 'setdeskgc': {
				if (!m.isGroup) return XliconStickGroup()
				if (!m.isAdmin) return XliconStickAdmin()
				if (!m.isBotAdmin) return XliconStickBotAdmin()
				if (!text && !m.quoted) {
					replygcxlicon(`Example: ${prefix + command} textnya`)
				} else {
					const teksnya = text ? text : m.quoted.text
					await XliconBotInc.groupUpdateDescription(m.chat, teksnya).catch((err) => replygcxlicon('Fail!'))
				}
			}
			break
			case 'setppgroup':
            case 'setppgrup':
            case 'setppgc':
            case 'setgrouppp':
            case 'setgruppp':
            case 'setgcpp':
                if (!m.isGroup) return XliconStickGroup()
                if (!m.isAdmin) return replygcxlicon(mess.admin)
                if (!m.isBotAdmin) return XliconStickBotAdmin()
                if (!quoted) return replygcxlicon(`Send/Reply Image With Caption ${prefix + command}`)
                if (!/image/.test(mime)) return replygcxlicon(`Send/Reply Image Caption Caption ${prefix + command}`)
                if (/webp/.test(mime)) return replygcxlicon(`Send/Reply Image With Caption ${prefix + command}`)
                var medis = await XliconBotInc.downloadAndSaveMediaMessage(quoted, 'ppbot.jpeg')
                if (args[0] == 'full') {
                    var {
                        img
                    } = await generateProfilePicture(medis)
                    await XliconBotInc.query({
                        tag: 'iq',
                        attrs: {
                            to: m.chat,
                            type: 'set',
                            xmlns: 'w:profile:picture'
                        },
                        content: [{
                            tag: 'picture',
                            attrs: {
                                type: 'image'
                            },
                            content: img
                        }]
                    })
                    fs.unlinkSync(medis)
                    replygcxlicon(mess.done)
                } else {
                    var memeg = await XliconBotInc.updateProfilePicture(m.chat, {
                        url: medis
                    })
                    fs.unlinkSync(medis)
                    replygcxlicon(mess.done)
                }
                break
			case 'delete': case 'del': case 'd': {
				if (!m.quoted) return replygcxlicon('Reply to the message you want to delete')
				await XliconBotInc.sendMessage(m.chat, { delete: { remoteJid: m.chat, fromMe: m.isBotAdmin ? false : true, id: m.quoted.id, participant: m.quoted.sender }})
			}
			break
			case 'linkgroup': case 'linkgrup': case 'linkgc': case 'urlgroup': case 'urlgrup': case 'urlgc': {
				if (!m.isGroup) return XliconStickGroup()
				if (!m.isAdmin) return XliconStickAdmin()
				if (!m.isBotAdmin) return XliconStickBotAdmin()
				let response = await XliconBotInc.groupInviteCode(m.chat)
				await XliconBotInc.sendMessage(m.chat, { text: `https://chat.whatsapp.com/${response}\n\nLink Group : ${(await XliconBotInc.groupMetadata(m.chat)).subject}`, detectLink: true }, { quoted: m });
			}
			break
			case 'resetlink': case 'revoke': case 'newlink': case 'newurl': {
				if (!m.isGroup) return XliconStickGroup()
				if (!m.isAdmin) return XliconStickAdmin()
				if (!m.isBotAdmin) return XliconStickBotAdmin()
				await XliconBotInc.groupRevokeInvite(m.chat).then((a) => {
					replygcxlicon(`Reset Success, Group Invite Link ${m.metadata.subject}`)
				}).catch((err) => replygcxlicon('Fail!'))
			}
			break
			case 'group': case 'grup': {
				if (!m.isGroup) return XliconStickGroup()
				if (!m.isAdmin) return XliconStickAdmin()
				if (!m.isBotAdmin) return XliconStickBotAdmin()
				if (text === 'close') {
					await XliconBotInc.groupSettingUpdate(m.chat, 'announcement').then((res) => replygcxlicon(`*Successfully Closing The Group*`))
				} else if (text === 'open') {
					await XliconBotInc.groupSettingUpdate(m.chat, 'not_announcement').then((res) => replygcxlicon(`*Successfully Opening The Group*`))
				} else {
					let button = [{
						name: 'single_select',
						buttonParamsJson: {
							title: 'SELECT',
							sections: [{
								title: 'Group Mode',
								rows: [
									{ title: 'Open Group', description: 'Open Group', id: 'grup open' },
									{ title: 'Close Group', description: 'Close Group', id: 'grup close' },
								]
							}]
						}
					}]
					await XliconBotInc.sendButtonMsg(m.chat, 'Group Mode', xliconytimewisher, 'Please choose', null, button, m);
				}
			}
			break
			case 'deleteppgroup': case 'delppgc': case 'deleteppgc': case 'delppgroup': {
if (!m.isGroup) return XliconStickGroup()
if (!m.isAdmin && !XliconTheCreator) return XliconStickAdmin()
if (!m.isBotAdmin) return XliconStickBotAdmin()
    await XliconBotInc.removeProfilePicture(m.chat)
    }
    break
    case 'deleteppbot': case 'delbotpp': case 'delppbot': {
if (!XliconTheCreator) return XliconStickOwner()
    await XliconBotInc.removeProfilePicture(XliconBotInc.user.id)
    replygcxlicon(`Success in deleting bot's profile picture`)
    }
    break
			case 'antidelete': {
    if (!m.isGroup) return XliconStickGroup();
    if (!m.isAdmin) return XliconStickAdmin();
    if (!m.isBotAdmin) return XliconStickBotAdmin();
    if (text === 'on') {
        if (db.groups[m.chat].antidelete) return replygcxlicon('*Anti Delete is already active!*');
        db.groups[m.chat].antidelete = true;
        replygcxlicon('*Anti Delete Activated!*');
    } else if (text === 'off') {
        db.groups[m.chat].antidelete = false;
        replygcxlicon('*Anti Delete Disabled!*');
    } else {
        return replygcxlicon(`
            Please choose an option to enable or disable Anti-Delete.

            Usage:
            - ${prefix + command} on  : Enable Anti-Delete
            - ${prefix + command} off : Disable Anti-Delete

            Example: ${prefix + command} on
        `);
    }
}
break;

			case 'tagall': {
				if (!m.isGroup) return XliconStickGroup()
				if (!m.isAdmin) return XliconStickAdmin()
				if (!m.isBotAdmin) return XliconStickBotAdmin()
				let teks = `*Tag All*\n\n*Message :* ${q ? q : ''}\n\n`
				for (let mem of m.metadata.participants) {
					teks += `${setv} @${mem.id.split('@')[0]}\n`
				}
				await XliconBotInc.sendMessage(m.chat, { text: teks, mentions: m.metadata.participants.map(a => a.id) }, { quoted: m })
			}
			break
			case 'hidetag': case 'h': {
				if (!m.isGroup) return XliconStickGroup()
          if (!XliconTheCreator) return XliconStickAdmin()
				XliconBotInc.sendMessage(m.chat, { text : q ? q : '' , mentions: m.metadata.participants.map(a => a.id)}, { quoted: m })
			}
			break
			case 'totag': {
				if (!m.isGroup) return XliconStickGroup()
				if (!m.isAdmin) return XliconStickAdmin()
				if (!m.isBotAdmin) return XliconStickBotAdmin()
				if (!m.quoted) return replygcxlicon(`Reply messages with captions ${prefix + command}`)
				delete m.quoted.chat
				await XliconBotInc.sendMessage(m.chat, { forward: m.quoted.fakeObj, mentions: m.metadata.participants.map(a => a.id) })
			}
			break
			case 'listonline': case 'liston': {
				if (!m.isGroup) return XliconStickGroup()
				let id = args && /\d+\-\d+@g.us/.test(args[0]) ? args[0] : m.chat
				let online = [...Object.keys(store.presences[id]), botNumber]
				await XliconBotInc.sendMessage(m.chat, { text: 'List Online:\n\n' + online.map(v => `${setv} @` + v.replace(/@.+/, '')).join`\n`, mentions: online }, { quoted: m }).catch((e) => replygcxlicon('Fail'))
			}
			break
			
			// Bot Menu
			case 'owner': {
				let list = []
for (let i of owner) {
list.push({
	    	displayName: await XliconBotInc.getName(i),
	    	vcard: `BEGIN:VCARD\nVERSION:3.0\nN:${await XliconBotInc.getName(i)}\nFN:${await XliconBotInc.getName(i)}\nitem1.TEL;waid=${i}:${i}\nitem1.X-ABLabel:Click here to chat\nitem2.EMAIL;type=INTERNET:${ytname}\nitem2.X-ABLabel:YouTube\nitem3.URL:${socialm}\nitem3.X-ABLabel:GitHub\nitem4.ADR:;;${location};;;;\nitem4.X-ABLabel:Region\nEND:VCARD`
	    })
	}
                XliconBotInc.sendMessage(m.chat, {
                    contacts: {
                        displayName: `${list.length} Contact`,
                        contacts: list
                    }, contextInfo: {
                            externalAdReply: {
                                showAdAttribution: true,
                                title: botname,
                                body: ownername,
                                thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
                                sourceUrl: wagc,
                                mediaType: 1,
                                renderLargerThumbnail: true
                            }
                        }
                }, {
                    quoted: m
                })
            }
            break
			case 'profile': case 'cekme': case 'cek': {
				const user = Object.keys(global.db.users)
				const infoUser = global.db.users[m.sender]
				const teks = `*Profile @${m.sender.split('@')[0]}* :\nUser Bot : ${user.includes(m.sender) ? 'True' : 'False'}\nUser : ${isVip ? 'VIP' : isPremium ? 'PREMIUM' : 'FREE'}\nLimit : ${infoUser.limit}\nMoney : ${infoUser ? infoUser.uang.toLocaleString('id-ID') : '0'}`
				await XliconBotInc.sendTextMentions(m.chat, teks, m)
			}
			break
			case 'req': case 'request': {
				if (!text) return replygcxlicon('What do you want to request from the owner??')
				await XliconBotInc.sendMessage(m.chat, { text: `*Request Has Been Sent To Owner*\n_Thank YouğŸ™_` }, { quoted: m })
				await XliconBotInc.sendFromOwner(ownernumber, `Order From : @${m.sender.split('@')[0]}\nFor Owners\n\nRequest ${text}`, m, { contextInfo: { mentionedJid: [m.sender], isForwarded: true }})
			}
			break
			case 'daily': case 'claim': {
				daily(XliconBotInc, m, global.db.users)
			}
			break
			case 'transferlimit': case 'tflimit': case 'tlimit': {
				transferLimit(XliconBotInc, m, args, global.db.users)
			}
			break
			case 'transfermoney': case 'tmoney': case 'transfer': {
				transferUang(XliconBotInc, m, args, global.db.users)
			}
			break
			case 'buy': {
				buy(m, args, db)
			}
			break
			case 'react': {
				XliconBotInc.sendMessage(m.chat, { react: { text: args[0], key: m.quoted ? m.quoted.key : m.key }})
			}
			break
			case 'tagme': {
				XliconBotInc.sendMessage(m.chat, { text: `@${m.sender.split('@')[0]}`, mentions: [m.sender] }, { quoted: m })
			}
			break
                
case 'runcode': {
    if (!text) return replygcxlicon(`Example: ${prefix + command} <JavaScript code>`);

    try {
        // Variable to capture console output
        let consoleOutput = '';
        const customConsole = {
            log: (...args) => {
                consoleOutput += args.join(' ') + '\n'; // Capture console.log output
            }
        };

        // Wrap the code execution in a Function and pass in the custom console
        const codeFunction = new Function('console', text);
        let result = codeFunction(customConsole); // Execute the code

        // If the result is a Promise (async code), await it
        if (result instanceof Promise) {
            result = await result;
        }

        // Prepare the output message
        const output = consoleOutput ? `\nğŸ–¥ï¸ *Console Output:*\n\`\`\`${consoleOutput}\`\`\`` : '';
        const resultMessage = result !== undefined ? `\nâœ… *Execution Result:*\n\`\`\`${result}\`\`\`` : '';

        replygcxlicon(`${resultMessage}${output || ''}`);
    } catch (error) {
        // Return an error message if execution fails
        replygcxlicon(`âŒ *Error:* \n\`\`\`${error.message}\`\`\``);
    }
}
break;

                
            case 'p': case 'ping': case 'botstatus': case 'statusbot': {
    let timestamp = speed();
    let latensi = speed() - timestamp;
    neww = performance.now();
    oldd = performance.now();

    const respon = `
âœ¨ *Bot Response Status* âœ¨\n
ğŸ“¡ *Response Speed*: \n ${latensi.toFixed(4)} _seconds_
ğŸ•’ *Ping*: \n ${oldd - neww} _milliseconds_
â± *Runtime*: \n ${runtime(process.uptime())}
ğŸ—„ *RAM Usage*: \n ${formatp(os.totalmem() - os.freemem())} / ${formatp(os.totalmem())}
\nğŸ‰ *Keeping the bot in top shape!*
`.trim();

    replygcxlicon(respon);
}
break;
    
			
			case 'p2': case 'ping2': case 'botstatus2': case 'statusbot2': {
    const used = process.memoryUsage();
    const cpus = os.cpus().map(cpu => {
        cpu.total = Object.keys(cpu.times).reduce((last, type) => last + cpu.times[type], 0);
        return cpu;
    });
    
    const cpu = cpus.reduce((last, cpu, _, { length }) => {
        last.total += cpu.total;
        last.speed += cpu.speed / length;
        last.times.user += cpu.times.user;
        last.times.nice += cpu.times.nice;
        last.times.sys += cpu.times.sys;
        last.times.idle += cpu.times.idle;
        last.times.irq += cpu.times.irq;
        return last;
    }, {
        speed: 0,
        total: 0,
        times: {
            user: 0,
            nice: 0,
            sys: 0,
            idle: 0,
            irq: 0
        }
    });
    
    let timestamp = speed();
    let latensi = speed() - timestamp;
    neww = performance.now();
    oldd = performance.now();

    respon = `
ğŸ“¡ *Response Speed*: ${latensi.toFixed(4)} _seconds_
ğŸ•’ ${oldd - neww} _milliseconds_
â± *Runtime*: ${runtime(process.uptime())}

ğŸ’» *Server Info*
ğŸ—„ *RAM Usage*: ${formatp(os.totalmem() - os.freemem())} / ${formatp(os.totalmem())}

ğŸ›  *NodeJS Memory Usage*
${Object.keys(used)
    .map(
        (key, _, arr) =>
            `${key.padEnd(Math.max(...arr.map(v => v.length)), ' ')}: ${formatp(used[key])}`
    )
    .join('\n')}

${cpus[0] ? `ğŸ–¥ï¸ *Total CPU Usage*
${cpus[0].model.trim()} (${cpu.speed} MHz)
${Object.keys(cpu.times)
    .map(
        type =>
            `- ${type.padEnd(6)}: ${(100 * cpu.times[type] / cpu.total).toFixed(2)}%`
    )
    .join('\n')}

*CPU Core(s) Usage* (${cpus.length} Core CPU)
${cpus
    .map(
        (cpu, i) =>
            `${i + 1}. ${cpu.model.trim()} (${cpu.speed} MHz)\n${Object.keys(cpu.times)
                .map(
                    type =>
                        `- ${type.padEnd(6)}: ${(100 * cpu.times[type] / cpu.total).toFixed(2)}%`
                )
                .join('\n')}`
    )
    .join('\n\n')}` : ''}`.trim();

    replygcxlicon(respon);
}
break;



case 'speedtest':
case 'speed': {
    replygcxlicon('âš¡ Testing Speed... âš¡');
    let cp = require('child_process');
    let { promisify } = require('util');
    let exec = promisify(cp.exec).bind(cp);
    let o;
    
    try {
        o = await exec('python3 speed.py');
    } catch (e) {
        o = e;
    } finally {
        let { stdout, stderr } = o;
        if (stdout.trim()) replygcxlicon(`ğŸŒŸ Speed Test Results ğŸŒŸ\n\n${stdout}`);
        if (stderr.trim()) replygcxlicon(`âš ï¸ Error:\n${stderr}`);
    }
}
break;
			case 'afk': {
				let user = global.db.users[m.sender]
				user.afkTime = + new Date
				user.afkReason = text
				replygcxlicon(`@${m.sender.split('@')[0]} Been Afk ${text ? ': ' + text : ''}`)
			}
			break
        
			case 'readviewonce': case 'vv': case 'readviewone': case 'rvo': {
				if (!m.quoted) return replygcxlicon(`Reply view once message\nExample: ${prefix + command}`)
				if (m.quoted.msg.viewOnce) {
					m.quoted.msg.viewOnce = false
					await XliconBotInc.sendMessage(m.chat, { forward: m.quoted }, { quoted: m })
				} else if (m.quoted.msg.message && m.quoted.msg.message.audioMessage && m.quoted.msg.message.audioMessage.viewOnce) {
					m.quoted.msg.message.audioMessage.viewOnce = false
					m.quoted.msg.message.audioMessage.contextInfo = { forwardingScore: 1, isForwarded: true, mentionedJid: [m.sender] }
					await XliconBotInc.relayMessage(m.chat, m.quoted.msg.message, {})
				} else {
					replygcxlicon(`Reply view once message\nExample: ${prefix + command}`)
				}
			}
			break
			case 'inspect': {
				if (!text) return replygcxlicon('Enter Group Link!')
				let code = q.match(/chat.whatsapp.com\/([\w\d]*)/g);
				if (code === null) return replygcxlicon('No invite url detected.');
				code = code[0].replace('chat.whatsapp.com/', '');
				await XliconBotInc.groupGetInviteInfo(code).then(anu => {
					let { id, subject, owner, subjectOwner, creation, desc, descId, participants, size, descOwner } = anu
					console.log(anu);
					let par = `*Gc Name* : ${subject}\n*ID* : ${id}\n${owner ? `*Creator* : @${owner.split('@')[0]}` : '*Creator* : -'}\n*Number of Members* : ${size}\n*Gc Created Date* : ${new Date(creation * 1000).toLocaleString()}\n*DescID* : ${descId ? descId : '-'}\n${subjectOwner ? `*GC Name Changed By* : @${subjectOwner.split('@')[0]}` : '*GC Name Changed By* : -'}\n${descOwner ? `*Desc changed by* : @${descOwner.split('@')[0]}` : '*Desc changed by* : -'}\n\n*Desc* : ${desc ? desc : '-'}\n`;
					XliconBotInc.sendTextMentions(m.chat, par, m);
				}).catch((res) => {
					if (res.data == 406) return replygcxlicon('Group Not Foundâ—');
					if (res.data == 410) return replygcxlicon('Group URL Has Been Resetâ—');
				});
			}
			break
                
                
			case 'q': case 'quoted': {
				if (!m.quoted) return replygcxlicon('Reply the message!')
				const anu = await m.getQuotedObj()
				if (!anu) return replygcxlicon('Format Not Available!')
				if (!anu.quoted) return replygcxlicon('The Message You Reply Does Not Contain a Reply')
				await XliconBotInc.relayMessage(m.chat, { [anu.quoted.type]: anu.quoted.msg }, {})
			}
			break
                
                
			case 'confes': case 'confess': case 'menfes': case 'menfess': {
				if (m.isGroup) return XliconStickPrivate();
				if (game.menfes[m.sender]) return replygcxlicon(`You're In Session ${command}!`)
				if (!text) return replygcxlicon(`Example : ${prefix + command} 91xxxx|Fake name`)
				let [teks1, teks2] = text.split`|`
				if (!isNaN(teks1) && !teks1.startsWith('0') && teks1) {
					const tujuan = teks1.replace(/[^0-9]/g, '') + '@s.whatsapp.net'
					const onWa = await XliconBotInc.onWhatsApp(tujuan)
					if (!onWa.length > 0) return replygcxlicon('This number is not registered on WhatsApp!')
					game.menfes[m.sender] = {
						tujuan: tujuan,
						nama: teks2,
						waktu: setTimeout(() => {
							if (game.menfes[m.sender]) replygcxlicon(`_Time ${command} finished_`)
							delete game.menfes[m.sender];
						}, 600000)
					};
					game.menfes[tujuan] = {
						tujuan: m.sender,
						nama: 'Recipient',
						waktu: setTimeout(() => {
							if (game.menfes[tujuan]) XliconBotInc.sendMessage(tujuan, { text: `_Time ${command} finished_` });
							delete game.menfes[tujuan];
						}, 600000)
					};
					XliconBotInc.sendMessage(tujuan, { text: `_${command} connected_\n*Note :* if you want to end, type _*${prefix}del${command}*_` });
					replygcxlicon(`_Start ${command}..._\n*Please start sending messages/media*\n*Duration ${command} only for 10 minutes*\n*Note :* if you want to end, type _*${prefix}del${command}*_`)
				} else {
					replygcxlicon(`Enter the number!\nExample : ${prefix + command} 91xxxx|Fake name`)
				}
			}
			break
                
			case 'delconfes': case 'delconfess': case 'delmenfes': case 'delmenfess': {
				if (!game.menfes[m.sender]) return replygcxlicon(`You Are Not In ${command.split('del')[1]} session!`)
				let anu = game.menfes[m.sender]
				XliconBotInc.sendMessage(anu.tujuan, { text: `Chat Ended By ${anu.nama ? anu.nama : 'Somebody'}` })
				replygcxlicon(`Successfully Ends Session ${command.split('del')[1]}!`)
				delete game.menfes[anu.tujuan];
				delete game.menfes[m.sender];
			}
			break
			
			// Tools Menu
			case 'fetch': case 'get': {
				if (!text.startsWith('http')) return replygcxlicon(`No Query?\n\nExample : ${prefix + command} https://google.com`)
				try {
					const res = await axios.get(isUrl(text) ? isUrl(text)[0] : text)
					if (!/json|html|plain/.test(res.headers['content-type'])) {
						await replygcxlicon(text)
					} else {
						replygcxlicon(util.format(res.data))
					}
				} catch (e) {
					replygcxlicon(util.format(e))
				}
			}
			break
                
			case 'toaud': case 'toaudio': {
				if (!/video/.test(mime) && !/audio/.test(mime)) return replygcxlicon(`Send/Reply Video/Audio that you want to make into audio with captions ${prefix + command}`)
				XliconStickWait()
				let media = await (m.quoted ? m.quoted.download() : m.download())
				let audio = await toAudio(media, 'mp4')
				await XliconBotInc.sendMessage(m.chat, { audio: audio, mimetype: 'audio/mpeg'}, { quoted : m })
			}
			break
                
			case 'tomp3': {
				if (!/video/.test(mime) && !/audio/.test(mime)) return replygcxlicon(`Send/Reply Video/Audio that you want to make into audio with captions ${prefix + command}`)
				XliconStickWait()
				let media = await (m.quoted ? m.quoted.download() : m.download())
				let audio = await toAudio(media, 'mp4')
				await XliconBotInc.sendMessage(m.chat, { document: audio, mimetype: 'audio/mpeg', fileName: `dgxlicon.mp3`}, { quoted : m })
			}
			break
                
			case 'tovn': case 'toptt': case 'tovoice': {
				if (!/video/.test(mime) && !/audio/.test(mime)) return replygcxlicon(`Send/Reply Video/Audio that you want to make into audio with captions ${prefix + command}`)
				XliconStickWait()
				let media = await (m.quoted ? m.quoted.download() : m.download())
				let audio = await toPTT(media, 'mp4')
				await XliconBotInc.sendMessage(m.chat, { audio: audio, mimetype: 'audio/ogg; codecs=opus', ptt: true }, { quoted: m })
			}
			break
                
			case 'togif': {
				if (!/webp/.test(mime) && !/video/.test(mime)) return replygcxlicon(`Reply Video/Sticker with caption *${prefix + command}*`)
				XliconStickWait()
				let { webp2mp4File } = require('./lib/uploader')
				let media = await XliconBotInc.downloadAndSaveMediaMessage(qmsg)
				let webpToMp4 = await webp2mp4File(media)
				await XliconBotInc.sendMessage(m.chat, { video: { url: webpToMp4.result, caption: 'Convert Webp To Video' }, gifPlayback: true }, { quoted: m })
				await fs.unlinkSync(media)
			}
			break
                
			case 'tovideo': case 'tomp4': {
				if (!/webp/.test(mime) && !/video/.test(mime)) return replygcxlicon(`Reply Video/Sticker with caption *${prefix + command}*`)
				XliconStickWait()
				let { webp2mp4File } = require('./lib/uploader')
				let media = await XliconBotInc.downloadAndSaveMediaMessage(qmsg)
				let webpToMp4 = await webp2mp4File(media)
				await XliconBotInc.sendMessage(m.chat, { video: { url: webpToMp4.result }, caption: 'Convert Webp To Video' }, { quoted: m })
				await fs.unlinkSync(media)
			}
			break
                
			case 'toimage': case 'toimg': {
				if (!/webp/.test(mime)) return replygcxlicon(`Reply Video/Sticker with caption *${prefix + command}*`)
				XliconStickWait()
				let media = await XliconBotInc.downloadAndSaveMediaMessage(qmsg)
				let ran = await getRandom('.png')
				exec(`ffmpeg -i ${media} ${ran}`, (err) => {
					fs.unlinkSync(media)
					if (err) return replygcxlicon('Failâ—')
					let buffer = fs.readFileSync(ran)
					XliconBotInc.sendMessage(m.chat, { image: buffer }, { quoted: m })
					fs.unlinkSync(ran)
				})
			}
			break
                
			case 'toptv': {
				if (!/video/.test(mime)) return replygcxlicon(`Send/Reply the video you want to use as a PTV message with caption ${prefix + command}`)
				if ((m.quoted ? m.quoted.type : m.type) === 'videoMessage') {
					const anu = await (m.quoted ? m.quoted.download() : m.download())
					const msg = await generateWAMessageContent({ video: anu }, { upload: XliconBotInc.waUploadToServer })
					await XliconBotInc.relayMessage(m.chat, { ptvMessage: msg.videoMessage }, {})
				} else {
					replygcxlicon('Reply Videos You Want to Convert to PTV Messages!')
				}
			}
			break
                
case 'tourl': {
  const fileType = require('file-type');  // Import the correct function
  const FormData = require('form-data');
  const fetch = require('node-fetch');
  const MAX_FILE_SIZE_MB = 200;  // Define the maximum allowed file size

  // Function to upload media
  async function uploadMedia(buffer) {
    try {
      const { ext } = await fileType.fromBuffer(buffer);  // Use fromBuffer() to get file type
      const bodyForm = new FormData();
      bodyForm.append("fileToUpload", buffer, "file." + ext);
      bodyForm.append("reqtype", "fileupload");

      const res = await fetch("https://catbox.moe/user/api.php", {
        method: "POST",
        body: bodyForm,
      });

      if (!res.ok) {
        throw new Error(`Upload failed with status ${res.status}: ${res.statusText}`);
      }

      const data = await res.text();
      return data;
    } catch (error) {
      console.error("Error during media upload:", error);
      throw new Error('Failed to upload media');
    }
  }

  // Checking for supported media types
  if (/jpg|jpeg|png/.test(mime)) {
    XliconStickWait();  // Notify user of the wait
    let media = await (m.quoted ? m.quoted.download() : m.download());
    const fileSizeMB = media.length / (1024 * 1024);
    if (fileSizeMB > MAX_FILE_SIZE_MB) {
      return replygcxlicon(`File size exceeds the limit of ${MAX_FILE_SIZE_MB}MB.`);
    }
    let mediaUrl = await uploadMedia(media);  // Upload the media and get the URL
    replygcxlicon('Url : ' + mediaUrl);  // Reply with the media URL
  } else if (/webp|video|sticker|audio/.test(mime)) {
    XliconStickWait();  // Notify user of the wait
    let media = await (m.quoted ? m.quoted.download() : m.download());
    const fileSizeMB = media.length / (1024 * 1024);
    if (fileSizeMB > MAX_FILE_SIZE_MB) {
      return replygcxlicon(`File size exceeds the limit of ${MAX_FILE_SIZE_MB}MB.`);
    }
    let mediaUrl = await uploadMedia(media);  // Upload the media and get the URL
    replygcxlicon('Url : ' + mediaUrl);  // Reply with the media URL
  } else {
    replygcxlicon('Send the media you want to upload!');  // If no media is provided
  }
}
break;
                  
			case 'texttospeech-indo': case 'tts-indo': case 'ttsindo': {
				if (!text) return replygcxlicon('Where is the text you want to convert to audio??')
				let { tts } = require('./lib/tts')
				let anu = await tts(text)
				XliconBotInc.sendMessage(m.chat, { audio: anu, ptt: true, mimetype: 'audio/mpeg' }, { quoted: m })
			}
			break


			case 'say': case 'tts': case 'gtts':{
if (!text) return replygcxlicon('Where is the text?')
            let texttts = text
            const xliconrl = googleTTS.getAudioUrl(texttts, {
                lang: "en",
                slow: false,
                host: "https://translate.google.com",
            })
            return XliconBotInc.sendMessage(m.chat, {
                audio: {
                    url: xliconrl,
                },
                mimetype: 'audio/mp4',
                ptt: true,
                fileName: `${text}.mp3`
            }, {
                quoted: m,
            })
        }
        break
                
			case 'toqr': case 'qr': {
				if (!text) return replygcxlicon(`Please include a text or link\n\nFor Example:\n*${prefix + command}* wassup`)
				XliconStickWait()
				await XliconBotInc.sendMessage(m.chat, { image: { url: 'https://api.qrserver.com/v1/create-qr-code/?size=1000x1000&data=' + text }, caption: 'Here you go!' }, { quoted: m })
			}
			break
                
                
			case 'ssweb': {
				if (!text) return replygcxlicon(`Example: ${prefix + command} https://github.com/salmanytofficial`)
				if (!text.startsWith('http')) {
					let buf = 'https://image.thum.io/get/width/1900/crop/1000/fullpage/https://' + q;
					await XliconBotInc.sendMessage(m.chat, { image: { url: buf }, caption: 'Done' }, { quoted: m })
				} else {
					let buf = 'https://image.thum.io/get/width/1900/crop/1000/fullpage/' + q;
					await XliconBotInc.sendMessage(m.chat, { image: { url: buf }, caption: 'Done' }, { quoted: m })
				}
			}
			break
                
			case'smeta': {
if (!/webp/.test(mime)) return replygcxlicon('Reply sticker!')
  var stiker = false
    try {
        let [packname, ...author] = q.split('|')
            //var author = (author  []).join('|')
                let mime = m.quoted.mimetype || ''
                        //let img = await q.download()
                            let img = await XliconBotInc.downloadAndSaveMediaMessage(quoted, makeid(5))
                                if (!img) return replygcxlicon('Reply a sticker!')
                                    var stiker = await addExifAvatar(img, `Made by`, `Cheems Bot`)
                                      } catch (e) {
                                          console.error(e)
                                              if (Buffer.isBuffer(e)) stiker = e
                                                } finally {
                                                    if (stiker) XliconBotInc.sendMessage(m.chat, {
                                                          sticker: stiker
                                                              }, {
                                                                    quoted: m
                                                                        })
                                                                            else return replygcxlicon('reply sticker')
                                                                              }
                                                                              }       
                                                                              break
			
            case 's': case 'sticker': case 'stiker': {
if (!quoted) return replygcxlicon(`Send/Reply Images/Videos/Gifs With Captions ${prefix+command}\nVideo Duration 1-9 Seconds`)
if (/image/.test(mime)) {
let media = await quoted.download()
let encmedia = await XliconBotInc.sendImageAsSticker(m.chat, media, m, { packname: global.packname, author: global.author })
} else if (/video/.test(mime)) {
if ((quoted.msg || quoted).seconds > 11) return replygcxlicon('Send/Reply Images/Videos/Gifs With Captions ${prefix+command}\nVideo Duration 1-9 Seconds')
let media = await quoted.download()
let encmedia = await XliconBotInc.sendVideoAsSticker(m.chat, media, m, { packname: global.packname, author: global.author })
} else {
replygcxlicon(`Send/Reply Images/Videos/Gifs With Captions ${prefix+command}\nVideo Duration 1-9 Seconds`)
}
}
break

case 'swm': case 'steal': case 'stickerwm': case 'take':{
if (!args.join(" ")) return replygcxlicon(`Where is the text?`)
const swn = args.join(" ")
const pcknm = swn.split("|")[0]
const atnm = swn.split("|")[1]
if (m.quoted.isAnimated === true) {
XliconBotInc.downloadAndSaveMediaMessage(quoted, "gifee")
XliconBotInc.sendMessage(m.chat, {sticker:fs.readFileSync("gifee.webp")}, m, { packname: pcknm, author: atnm })
} else if (/image/.test(mime)) {
let media = await quoted.download()
let encmedia = await XliconBotInc.sendImageAsSticker(m.chat, media, m, { packname: pcknm, author: atnm })
} else if (/video/.test(mime)) {
if ((quoted.msg || quoted).seconds > 11) return replygcxlicon('Maximum 10 Seconds!')
let media = await quoted.download()
let encmedia = await XliconBotInc.sendVideoAsSticker(m.chat, media, m, { packname: pcknm, author: atnm })
} else {
replygcxlicon(`Photo/Video?`)
}
}
break
			case 'smeme': case 'stickermeme': case 'stickmeme': {
if (!/webp/.test(mime) && /image/.test(mime)) {
if (!text) return replygcxlicon(`Usage: ${prefix + command} text1|text2`)
let { TelegraPh } = require('./lib/uploader')
atas = text.split('|')[0] ? text.split('|')[0] : '-'
bawah = text.split('|')[1] ? text.split('|')[1] : '-'
mee = await XliconBotInc.downloadAndSaveMediaMessage(quoted)
mem = await TelegraPh(mee)
meme = `https://api.memegen.link/images/custom/${encodeURIComponent(atas)}/${encodeURIComponent(bawah)}.png?background=${mem}`
memek = await XliconBotInc.sendImageAsSticker(m.chat, meme, m, { packname: global.packname, author: global.author })
} else {
replygcxlicon(`Send/reply image with caption ${prefix + command} text1|text2`)
}
}
break
                
			case 'write': {
				replygcxlicon(`*Example*\n${prefix}writeleft text\n${prefix}writeright text\n${prefix}folioleft text\n${prefix}folioright text`)
			}
			break
                
			case 'writeleft': {
				if (!text) return replygcxlicon(`Send command *${prefix + command}* text`)
				XliconStickWait()
				const splitText = text.replace(/(\S+\s*){1,9}/g, '$&\n')
				const fixHeight = splitText.split('\n').slice(0, 31).join('\n')
				spawn('convert', [
					'./src/write/images/book/beforeleft.jpg',
					'-font',
					'./src/write/font/Indie-Flower.ttf',
					'-size',
					'960x1280',
					'-pointsize',
					'23',
					'-interline-spacing',
					'2',
					'-annotate',
					'+140+153',
					fixHeight,
					'./src/write/images/book/afterleft.jpg'
				])
				.on('error', () => replygcxlicon(mess.error))
				.on('exit', () => {
					XliconBotInc.sendMessage(m.chat, { image: fs.readFileSync('./src/write/images/book/afterleft.jpg'), caption: 'Here you go!' }, { quoted: m })
				})
			}
			break
                
			case 'writeright': {
				if (!text) return replygcxlicon(`Send command *${prefix + command}* text`)
				XliconStickWait()
				const splitText = text.replace(/(\S+\s*){1,9}/g, '$&\n')
				const fixHeight = splitText.split('\n').slice(0, 31).join('\n')
				spawn('convert', [
					'./src/write/images/book/beforeright.jpg',
					'-font',
					'./src/write/font/Indie-Flower.ttf',
					'-size',
					'960x1280',
					'-pointsize',
					'23',
					'-interline-spacing',
					'2',
					'-annotate',
					'+128+129',
					fixHeight,
					'./src/write/images/book/afterright.jpg'
				])
				.on('error', () => replygcxlicon(mess.error))
				.on('exit', () => {
					XliconBotInc.sendMessage(m.chat, { image: fs.readFileSync('./src/write/images/book/afterright.jpg'), caption: 'Here you go!' }, { quoted: m })
				})
			}
			break
                
			case 'folioleft': {
				if (!text) return replygcxlicon(`Send command *${prefix + command}* text`)
				XliconStickWait()
				const splitText = text.replace(/(\S+\s*){1,9}/g, '$&\n')
				const fixHeight = splitText.split('\n').slice(0, 38).join('\n')
				spawn('convert', [
					'./src/write/images/folio/beforeleft.jpg',
					'-font',
					'./src/write/font/Indie-Flower.ttf',
					'-size',
					'1720x1280',
					'-pointsize',
					'23',
					'-interline-spacing',
					'4',
					'-annotate',
					'+48+185',
					fixHeight,
					'./src/write/images/folio/afterleft.jpg'
				])
				.on('error', () => replygcxlicon(mess.error))
				.on('exit', () => {
					XliconBotInc.sendMessage(m.chat, { image: fs.readFileSync('./src/write/images/folio/afterleft.jpg'), caption: 'Here you go!' }, { quoted: m })
				})
			}
			break
                
			case 'folioright': {
				if (!text) return replygcxlicon(`Send command *${prefix + command}* text`)
				XliconStickWait()
				const splitText = text.replace(/(\S+\s*){1,9}/g, '$&\n')
				const fixHeight = splitText.split('\n').slice(0, 38).join('\n')
				spawn('convert', [
					'./src/write/images/folio/beforeright.jpg',
					'-font',
					'./src/write/font/Indie-Flower.ttf',
					'-size',
					'1720x1280',
					'-pointsize',
					'23',
					'-interline-spacing',
					'4',
					'-annotate',
					'+89+190',
					fixHeight,
					'./src/write/images/folio/afterright.jpg'
				])
				.on('error', () => replygcxlicon(mess.error))
				.on('exit', () => {
					XliconBotInc.sendMessage(m.chat, { image: fs.readFileSync('./src/write/images/folio/afterright.jpg'), caption: 'Here you go!' }, { quoted: m })
				})
			}
			break
			
			// Ai Menu
			case 'ai2': case 'gpt2': case 'openai2': {
				if (!text) return replygcxlicon(`Example: ${prefix + command} query`)
				const hasil = await chatGpt(text);
				 return replygcxlicon(`â— *Error:*âš ï¸`);
			}
			break


			// Search Menu
case 'play':
case 'song': {
  try {
    if (!text) return replygcxlicon(`Example: ${prefix + command} anime whatsapp status`);

    // Indicate that the bot is processing the request
    await XliconStickWait(); // Show loading indicator

    // Perform a search using yts
    const yts = require("yt-search");
    let search = await yts(text);

    if (!search || search.videos.length === 0) {
      return replygcxlicon('âŒ No video found');
    }

    // Get the first video from the search results
    let video = search.videos[0];

    // Use the new Nyx API to fetch the audio URL
    const apiUrl = `https://api.nyxs.pw/dl/yt-direct?url=${encodeURIComponent(video.url)}`;
    const response = await axios.get(apiUrl);

    if (!response.data || !response.data.status || !response.data.result || !response.data.result.urlAudio) {
      return replygcxlicon('ğŸš« Error fetching audio from the URL.');
    }

    // Extract the audio URL and other details from the response
    const audioUrl = response.data.result.urlAudio;
    const title = response.data.result.title;
    const channelName = response.data.result.channelName;
    const thumbnail = response.data.result.thumbnail;

    // Prepare message with audio details
    const audioDetails = `ğŸ¶ *Title:* _${title}_\n` +
                         `â³ *Duration:* _${response.data.result.length}_\n` +
                         `ğŸ‘¤ *Artist:* _${channelName}_\n` +
                         `ğŸ‘€ *Views:* _${response.data.result.views ? response.data.result.views.toLocaleString() : 'N/A'} views_\n` +
                         `ğŸ”— *Link:* _${video.url}_`;

    // Send audio details
    await replygcxlicon(audioDetails);

    // Notify user that the audio is being downloaded
    await replygcxlicon('ğŸ“¥ Downloading audio...');

    // Send audio message to the chat without doc
    await XliconBotInc.sendMessage(m.chat, {
      audio: { url: audioUrl },
      mimetype: 'audio/mpeg', // Correct MIME type for MP3 audio
      fileName: `${title}.mp3` // Set a file name
    }, { quoted: m });

  } catch (error) {
    console.error("Error in play2/song2 command: ", error);
    replygcxlicon("âš ï¸ An error occurred while processing your request.");
  }
}
break;


                
case 'play2':
case 'song2': {
  try {
    if (!text) return replygcxlicon(`Example: ${prefix + command} anime whatsapp status`);

    // Indicate that the bot is processing the request
    await XliconStickWait(); // Show loading indicator

    // Perform a search using yts
    const yts = require("yt-search");
    let search = await yts(text);

    if (!search || search.videos.length === 0) {
      return replygcxlicon('âŒ No video found');
    }

    // Get the first video from the search results
    let video = search.videos[0];

    
    const apiUrl = `${global.api}downloader/yt-audio?apikey=${global.id}&url=${encodeURIComponent(video.url)}`;
    const response = await axios.get(apiUrl);

    if (!response.data || response.data.status !== 200 || !response.data.result || !response.data.result.audio) {
      return replygcxlicon('ğŸš« Error fetching audio from the URL.');
    }

    // Extract the audio URL from the response
    const audioUrl = response.data.result.audio;
    const title = response.data.result.title;

    // Prepare message with audio details
    const audioDetails = `ğŸ¶ *Title:* _${title}_\n` +
                         `â³ *Duration:* _${response.data.result.duration}_\n` +
                         `ğŸ‘¤ *Artist:* _${response.data.result.channel_name}_\n` +
                         `ğŸ‘€ *Views:* _${response.data.result.views.toLocaleString()} views_\n` +
                         `ğŸ”— *Link:* _${video.url}_`;

    // Send audio details
    await replygcxlicon(audioDetails);

    // Notify user that the audio is being downloaded
    await replygcxlicon('ğŸ“¥ Downloading audio...');

    // Send audio message to the chat without doc
    await XliconBotInc.sendMessage(m.chat, {
      audio: { url: audioUrl },
      mimetype: 'audio/mp3', // Correct MIME type for MP3 audio
      fileName: `${title}.mp3` // Set a file name
    }, { quoted: m });

  } catch (error) {
    console.error("Error in play2/song2 command: ", error);
    replygcxlicon("âš ï¸ An error occurred while processing your request.");
  }
}
break;


               
//--------------------------------------------------------------------------------------------------//

                


case 'ytvideo': {
  try {
    // Check if the user has provided a valid URL
    if (args.length < 1 || !isUrl(text)) 
      return replygcxlicon(`Where is the link??\n\nExample: ${prefix + command} https://youtube.com/watch?v=PtFMh6Tccag`);

    // API URL to fetch video information
    const apiUrl = `https://bk9.fun/download/youtube?url=${encodeURIComponent(text)}`;
    
    // Fetch the response from the API
    let res = await fetch(apiUrl);
    let apiResponse = await res.json();
    
    // Check if the API returned a valid response
    if (!apiResponse.status || !apiResponse.BK9 || !apiResponse.BK9.video) 
      throw new Error("Failed to retrieve video");

    // Extract video data from the API response
    let { title, thumb, channel, published, views, url } = apiResponse.BK9.video;

    // Build the caption with more details
    const ytc = `
      *ğŸ¬ Title:* ${title}
      *ğŸ“… Published:* ${published}
      *ğŸ•’ Duration:*  -- (Duration info not provided by API)
      *ğŸ‘€ Views:* ${views}
      *ğŸ“º Channel:* ${channel}
    `.trim();

    // Notify the user that the download is starting
    replygcxlicon("â³ *Downloading video, please wait...*");

    // Send the video along with the caption
    await XliconBotInc.sendMessage(m.chat, {
      video: { url: url },
      caption: ytc,
      thumbnail: { url: thumb }
    }, { quoted: m });

    // Notify that the download is complete
    replygcxlicon(`âœ… *Download complete!* ğŸ‰\n\n${ytc}`);

  } catch (error) {
    console.error("Error in ytvideo command: ", error);
    replygcxlicon("âŒ *An error occurred while processing your request. Please try again later.*");
  }
}
break;

				
                


case 'searchsoundcloud': {
  if (!text) return replygcxlicon(`*â€¢ Example:* ${prefix + command} metamorphosis`);

  const fetchSoundCloudResults = async (query) => {
    const apiUrl = `https://bk9.fun/search/soundcloud?q=${encodeURIComponent(query)}`;

    try {
      const response = await fetch(apiUrl);
      if (!response.ok) {
        console.error(`API response not OK: ${response.status} ${response.statusText}`);
        throw new Error('API response not OK');
      }
      const json = await response.json();
      return json.status && json.BK9 && json.BK9.length > 0 ? json.BK9 : null;
    } catch (error) {
      console.error(`Error fetching from ${apiUrl}:`, error);
    }
    return null;
  };

  try {
    await XliconStickWait();
    const query = text.trim();
    const results = await fetchSoundCloudResults(query);

    if (!results) {
      return replygcxlicon('âŒ Failed to fetch SoundCloud results. Please try again.');
    }

    let soundCloudText = `ğŸµ *SoundCloud Results for* _"${query}"_:\n\n`;
    results.forEach((track, index) => {
      soundCloudText += `ğŸ”Š *Title:* ${track.title}\nğŸ”— *Link:* ${track.link}\n\n`;
    });

    // Send the formatted text without generateWAMessageFromContent
    return replygcxlicon(soundCloudText);

  } catch (e) {
    return replygcxlicon("`*Error*`");
  }
}
break;

case 'soundcloud': {
  try {
    if (args.length < 1 || !isUrl(text)) {
      return replygcxlicon(`âŒ *Where is the link?* \n\nExample: ${prefix + command} https://soundcloud.com/artist/song-name`);
    }

    await XliconStickWait();

    const apiUrl = `${global.api}downloader/sound-cloud?apikey=${global.id}&url=${encodeURIComponent(text)}`;

    let res = await fetch(apiUrl);

    if (!res.ok) {
      throw new Error("âŒ *Failed to fetch from API.*");
    }

    let apiResponse = await res.json();

    if (!apiResponse.status || !apiResponse.result || !apiResponse.result.dl_url) {
      throw new Error("âŒ *Failed to retrieve audio from API response.*");
    }

    let { title, dl_url } = apiResponse.result;

    const soundcloudMessage = `ğŸµ *Thank you for using Xlicon v4* ğŸ‰`;

    // Send the audio file using the download URL
    await XliconBotInc.sendMessage(m.chat, {
      audio: { url: dl_url },
      mimetype: 'audio/mp3',
      caption: `*ğŸµ Title*: ${title}\nğŸ”— *Download Link*: ${dl_url}\n\n${soundcloudMessage}`,
    }, { quoted: m });

  } catch (error) {
    replygcxlicon("âŒ *An error occurred while processing your request.* Please try again later.");
  }
}
break;

                
  

//--------------------------------------------------------------------------------------------------//




			case 'pixiv': {
				if (!text) return replygcxlicon(`Example: ${prefix + command} hello`)
				try {
					let { pixivdl } = require('./lib/pixiv')
					let res = await pixivdl(text)
					XliconStickWait()
					for (let i = 0; i < res.media.length; i++) {
						let caption = i == 0 ? `${res.caption}\n\n*By:* ${res.artist}\n*Tags:* ${res.tags.join(', ')}` : ''
						let mime = (await FileType.fromBuffer(res.media[i])).mime 
						await XliconBotInc.sendMessage(m.chat, { [mime.split('/')[0]]: res.media[i], caption, mimetype: mime }, { quoted: m })
					}
				} catch (e) {
					replygcxlicon('Search Not found!')
				}
			}
			break
			case 'pinterest': 
case 'pin': {
  if (!text) {
    return replygcxlicon(`â— *Example:* ${prefix + command} pinterest_url`);
  }

  XliconStickWait();

  try {
    const apiUrl = `https://bk9.fun/download/alldownload?url=${encodeURIComponent(text)}`;
    const response = await axios.get(apiUrl);

    if (response.data.status === true && response.data.BK9) {
      const lowQualityUrl = response.data.BK9.low;
      const highQualityUrl = response.data.BK9.high;

      if (highQualityUrl) {
        await XliconBotInc.sendMessage(m.chat, {
          video: { url: highQualityUrl },
          caption: "ğŸ‰ *Thank you for using Xlicon V4*"
        }, { quoted: m });
      } else if (lowQualityUrl) {
        await XliconBotInc.sendMessage(m.chat, {
          video: { url: lowQualityUrl },
          caption: "ğŸ‰ *Thank you for using Xlicon V4*"
        }, { quoted: m });
      } else {
        return replygcxlicon("âš ï¸ *No valid video found. Please check the Pinterest link or ensure it contains a video.*");
      }
    } else {
      return replygcxlicon("âš ï¸ *No valid video found. Please check the Pinterest link or ensure it contains content.*");
    }
  } catch (error) {
    console.error(error);
    return replygcxlicon("âŒ *An error occurred while fetching data from Pinterest.*");
  }
}
break;

case 'wallpaper': {
  if (!text) return replygcxlicon('ğŸŒ *Enter Query Title for Wallpaper Search* ğŸ”');

  await XliconStickWait(); // Indicate that the bot is processing the request

  try {
      // List of API URLs to choose from
      const apiUrls = [
          'https://aemt.uk.to/googleimage?query=',
          'https://meitang.xyz/googleimage?query=',
          'https://btch.us.kg/googleimage?query=',
          'https://api.tioo.eu.org/googleimage?query=',
          'https://api.tioprm.eu.org/googleimage?query='
      ];

      // Randomly select an API URL
      const apiUrl = apiUrls[Math.floor(Math.random() * apiUrls.length)] + encodeURIComponent(text);

      // Fetch the wallpaper directly from the selected API
      let response = await fetch(apiUrl);

      // Check if the response is okay
      if (!response.ok) {
          return replygcxlicon('âŒ *Failed to fetch the wallpaper.* Please try again. ğŸ”„');
      }

      // Get the image URL directly from the response
      let wallpaperUrl = await response.json().then(data => data.result[0].url); // Assuming response structure includes a 'result' array

      // Send the wallpaper with a caption
      await XliconBotInc.sendMessage(m.chat, {
          image: { url: wallpaperUrl },
          caption: `ğŸŒŸ *Wallpaper Search Results* ğŸŒŸ\n\n_*Here is the wallpaper for: ${text}*_ ğŸ–¼ï¸`
      }, { quoted: m });

  } catch (e) {
      console.error(e);
      return replygcxlicon("â— *Error fetching the wallpaper.* Please try again. âš ï¸");
  }
}
break;


     case 'live-wallpaper': {
  try {
    if (!text) return replygcxlicon(`Example: ${prefix + command} cat`);

    // Show loading indicator
    await XliconStickWait();

    // Make API request to fetch live wallpapers
    const axios = require('axios');
    const response = await axios.get(`https://xliconmd-live-wallpapers.vercel.app/api/search?q=${encodeURIComponent(text)}&page=1&limit=10`);

    const { wallpapers } = response.data;

    if (!wallpapers || wallpapers.length === 0) {
      return replygcxlicon('âŒ No live wallpapers found for your search.');
    }

    // Select a random wallpaper from the results
    const wallpaper = wallpapers[Math.floor(Math.random() * wallpapers.length)];

    // Prepare message details
    const wallpaperDetails = `ğŸ–¼ï¸ *Title:* _${wallpaper.title}_\n` +
                             `ğŸ”— *Link:* _${wallpaper.url}_\n`;

    // Send the wallpaper thumbnail and details
    await XliconBotInc.sendMessage(m.chat, {
      image: { url: wallpaper.thumbnail },
      caption: wallpaperDetails
    }, { quoted: m });

    // Send the live wallpaper video
    await XliconBotInc.sendMessage(m.chat, {
      video: { url: wallpaper.video_url },
      caption: 'ğŸ¥ Here is your live wallpaper!'
    }, { quoted: m });

  } catch (error) {
    console.error("Error in live-wallpaper command: ", error);
    replygcxlicon("âš ï¸ An error occurred while processing your request.");
  }
}
break;
           
			case 'ringtone': {
				if (!text) return replygcxlicon(`Example: ${prefix + command} black rover`)
				let anu = await ringtone(text)
				let result = pickRandom(anu)
				await XliconBotInc.sendMessage(m.chat, { audio: { url: result.audio }, fileName: result.title + '.mp3', mimetype: 'audio/mpeg' }, { quoted: m })
			}
			break
			
			// Downloader Menu
case 'ytmp3': case 'ytaudio': case 'ytplayaudio': {
    if (!text) return replygcxlicon(`Example: ${prefix + command} youtube_url`);
    if (!text.includes('youtu')) return replygcxlicon('The URL does not contain results from YouTube!');
    
    XliconStickWait();
    
    // First try using the primary API
    try {
        const hasil = await ytMp3(text); // Your original ytMp3 function
        XliconStickWait();
        
        await replygcxlicon(`*ğŸŸ¢ XLICON MD YT AUDIO DOWNLOADER ğŸŸ¢*\n\n` +
                            `*ğŸ¬ Title:* ${hasil.title}\n` +
                            `*ğŸ’¾ Size:* ${hasil.size}\n` +
                            `*ğŸ‘€ Views:* ${hasil.views ? hasil.views.toLocaleString() : "0"}\n` +
                            `*ğŸ‘ Likes:* ${hasil.likes ? hasil.likes.toLocaleString() : "0"}\n` +
                            `*ğŸ‘ Dislikes:* ${hasil.dislike ? hasil.dislike.toLocaleString() : "0"}\n` +
                            `*ğŸ“º Channel:* ${hasil.channel}\n` +
                            `*ğŸ“… Uploaded On:* ${hasil.uploadDate}\n\n` +
                            `*ğŸ’» SERVER: KALI LINUX*\n\n` +
                            `*ğŸ”» DOWNLOADED BY XLICON-V4 ğŸ”»*`);
        
        await XliconBotInc.sendMessage(m.chat, {
            audio: { url: hasil.result },
            mimetype: 'audio/mpeg',
            contextInfo: {
                externalAdReply: {
                    title: hasil.title,
                    body: hasil.channel,
                    previewType: 'PHOTO',
                    thumbnailUrl: hasil.thumb,
                    mediaType: 1,
                    renderLargerThumbnail: true,
                    sourceUrl: text
                }
            }
        }, { quoted: m });
    } catch (error) {
        console.error('Primary API Error (ytMp3):', error);  // Log the error to the console
        // If the first API fails, fall back to the Widipe API
        try {
            const widipeResponse = await axios.get(`https://widipe.com/download/ytdl?url=${text}`);
            const widipeResult = widipeResponse.data.result;
            
            // Fallback response using Widipe API
            await replygcxlicon(`*ğŸŸ¢ XLICON MD WIDIPE AUDIO DOWNLOADER ğŸŸ¢*\n\n` +
                                `*ğŸ¬ Title:* ${widipeResult.title}\n` +
                                `*ğŸ‘€ Views:* ${widipeResult.views}\n` +
                                `*ğŸ“º Channel:* ${widipeResult.name}\n` +
                                `*ğŸ“… Uploaded:* ${widipeResult.ago}\n\n` +
                                `*ğŸ’» SERVER: KALI LINUX*\n\n` +
                                `*ğŸ”» DOWNLOADED BY XLICON-V4 ğŸ”»*`);
            
            await XliconBotInc.sendMessage(m.chat, {
                audio: { url: widipeResult.mp3 },
                mimetype: 'audio/mpeg'
            }, { quoted: m });
        } catch (err) {
            console.error('Fallback API Error (Widipe MP3):', err);  // Log the Widipe API error to the console
            replygcxlicon('Error: Could not download the audio using either API.');
        }
    }
}
break;



case 'ytmp4': case 'ytvideo': case 'ytplayvideo': {
    if (!text) return replygcxlicon(`Example: ${prefix + command} youtube_url`);
    if (!text.includes('youtu')) return replygcxlicon('The URL does not contain results from YouTube!');
    
    XliconStickWait();
    
    // First try using the primary API
    try {
        const hasil = await ytMp4(text); // Your original ytMp4 function
        XliconStickWait();
        
        const views = hasil.views ? hasil.views.toLocaleString() : "0";
        const likes = hasil.likes ? hasil.likes.toLocaleString() : "0";
        const dislikes = hasil.dislike ? hasil.dislike.toLocaleString() : "0";
        
        await XliconBotInc.sendMessage(m.chat, {
            video: { url: hasil.result },
            caption: `*ğŸŸ¢ XLICON MD YT DOWNLOADER ğŸŸ¢*\n\n` +
                     `*ğŸ¬ Title:* ${hasil.title}\n` +
                     `*ğŸ“¡ Quality:* ${hasil.quality}\n` +
                     `*ğŸ’¾ Size:* ${hasil.size}\n` +
                     `*ğŸ‘€ Views:* ${views}\n` +
                     `*ğŸ‘ Likes:* ${likes}\n` +
                     `*ğŸ‘ Dislikes:* ${dislikes}\n` +
                     `*ğŸ“º Channel:* ${hasil.channel}\n` +
                     `*ğŸ“… Uploaded On:* ${hasil.uploadDate}\n\n` +
                     `*ğŸ’» SERVER: KALI LINUX*\n\n` +
                     `*ğŸ”» DOWNLOADED BY XLICON-V4 ğŸ”»*`
        }, { quoted: m });
    } catch (error) {
        console.error('Primary API Error (ytMp4):', error);  // Log the error to the console
        // If the first API fails, fall back to the Widipe API
        try {
            const widipeResponse = await axios.get(`https://widipe.com/download/ytdl?url=${text}`);
            const widipeResult = widipeResponse.data.result;
            
            const caption = `*_DOWNLOADED BY XLICON V4 MD_*\n\n
    ğŸ¬ *Title*: _${widipeResult.title}_\n
    â±ï¸ *Duration*: _${widipeResult.duration}_\n
    ğŸ“… *Uploaded*: _${widipeResult.ago}_\n
    ğŸ‘ï¸ *Views*: _${widipeResult.views.toLocaleString()}_\n
    ğŸ‘¤ *Uploader*: _${widipeResult.name}_\n
    ğŸ”— *Channel*: _${widipeResult.channel}_\n\n
    *ğŸ’» SERVER: KALI LINUX*\n\n` +  // Added server info
    `*ğŸ”» DOWNLOADED BY XLICON-V4 ğŸ”»*`; // Added download info

            await XliconBotInc.sendMessage(m.chat, {
                video: { url: widipeResult.mp4 },
                caption: caption,
                thumbnail: { url: widipeResult.thumbnail }
            }, { quoted: m });
        } catch (err) {
            console.error('Fallback API Error (Widipe MP4):', err);  // Log the Widipe API error to the console
            replygcxlicon('Error: Could not download the video using either API.');
        }
    }
}
break;


      case 'yta': {
  if (!text) return replygcxlicon(`â— *Example:* ${prefix + command} youtube_url`);
  if (!text.includes('youtu')) return replygcxlicon('âŒ *The URL does not contain results from YouTube!*');
  XliconStickWait();

  try {
    const response = await axios.get(`https://api.nyxs.pw/dl/yt-direct?url=${encodeURIComponent(text)}`);
    const hasil = response.data;

    if (!hasil.status || !hasil.result.urlAudio) {
      return replygcxlicon('âš ï¸ *Error fetching audio from the URL.*');
    }

    await XliconBotInc.sendMessage(m.chat, {
      audio: { url: hasil.result.urlAudio },
      mimetype: 'audio/mpeg'
    }, { quoted: m });

  } catch (error) {
    console.error(error);
    return replygcxlicon('âŒ *There was an error processing the request.*');
  }
}
break;

                    
  case 'ytv': {
  try {
    if (args.length < 1 || !isUrl(text)) {
      return replygcxlicon(`âŒ *Where is the link?* \n\nExample: ${prefix + command} https://youtube.com/watch?v=PtFMh6Tccag`);
    }

    await XliconStickWait();

    const apiUrl = `https://bk9.fun/download/youtube2?url=${encodeURIComponent(text)}`;

    let res = await fetch(apiUrl);

    if (!res.ok) {
      throw new Error("âŒ *Failed to fetch from API.*");
    }

    let apiResponse = await res.json();

    if (!apiResponse.status || !apiResponse.BK9 || !apiResponse.BK9.BK9) {
      throw new Error("âŒ *Failed to retrieve video from API response.*");
    }

    let { BK9: videoUrl } = apiResponse.BK9;

    const ytc = `ğŸ¬ *Thank you for using Xlicon v4* ğŸ‰`;

    await XliconBotInc.sendMessage(m.chat, {
      video: { url: videoUrl },
      caption: ytc,
    }, { quoted: m });

  } catch (error) {
    replygcxlicon("âŒ *An error occurred while processing your request.* Please try again later.");
  }
}
break;
           
    
const https = require('https'); // Import the https module for custom agent
case 'yta2': {
    if (!text) return replygcxlicon(`âŒ *Example:* ${prefix + command} youtube_url`);
    if (!text.includes('youtu')) return replygcxlicon('âš ï¸ *The URL does not contain results from YouTube!*');
    XliconStickWait();

    try {
        const apiUrl = `${global.api}downloader/yt-audio?apikey=${global.id}&url=${encodeURIComponent(text)}`;
        const response = await axios.get(apiUrl);
        const hasil = response.data;

        // Check if audio URL is available
        if (!hasil.result || !hasil.result.audio) {
            throw new Error('âŒ *No audio download link found.*');
        }

        const audioLink = hasil.result.audio;
        const caption = `*_DOWNLOADED BY XLICON V4 MD_*\n\nğŸµ *Title*: _${hasil.result.title}_\nâœ¨ *Enjoy your audio!* ğŸ¶\nğŸ”¥ *Powered by Xlicon Bot* ğŸ’»`;

        // Send caption to the user
        await replygcxlicon(caption);

        // Send the audio using the correct variable `audioLink`
        await XliconBotInc.sendMessage(m.chat, {
            audio: { url: audioLink },
            mimetype: 'audio/mp4' // Adjust mimetype if necessary
        }, { quoted: m });
    } catch (error) {
        console.error('Error in yta2 command:', error);
        replygcxlicon('âš ï¸ *An error occurred while processing the audio.*');
    }
}
break;


case 'ytv2': {
    if (!text) return replygcxlicon(`âŒ *Example:* ${prefix + command} youtube_url`);
    if (!text.includes('youtu')) return replygcxlicon('âš ï¸ *The URL does not contain results from YouTube!*');
    XliconStickWait();

    try {
        const apiUrl1 = `${global.api}downloader/yt-video?apikey=${global.id}&url=${encodeURIComponent(text)}`;
        const apiUrl2 = `${global.api}downloader/yt-video2?apikey=${global.id}&url=${encodeURIComponent(text)}`;

        // First API request
        const response1 = await axios.get(apiUrl1);
        const hasil1 = response1.data;

        // Check if video URL is available from first API
        if (hasil1.result && hasil1.result.video) {
            const videoLink = hasil1.result.video;
            const caption = `*_DOWNLOADED BY XLICON V4 MD_*\n\nğŸ¬ *Title*: _${hasil1.result.title}_\nâœ¨ *Enjoy your video!* ğŸ¥\nğŸ”¥ *Powered by Xlicon Bot* ğŸ’»`;

            await XliconBotInc.sendMessage(m.chat, {
                video: { url: videoLink },
                caption: caption,
                thumbnail: { url: hasil1.result.thumb } // Include thumbnail if available
            }, { quoted: m });
        } else {
            // If no video URL from the first API, try the second API
            const response2 = await axios.get(apiUrl2);
            const hasil2 = response2.data;

            if (hasil2.result && hasil2.result.video) {
                const videoLink2 = hasil2.result.video;
                const caption2 = `*_DOWNLOADED BY XLICON V4 MD_*\n\nğŸ¬ *Title*: _${hasil2.result.title}_\nâœ¨ *Enjoy your video!* ğŸ¥\nğŸ”¥ *Powered by Xlicon Bot* ğŸ’»`;

                await XliconBotInc.sendMessage(m.chat, {
                    video: { url: videoLink2 },
                    caption: caption2,
                    thumbnail: { url: hasil2.result.thumb } // Include thumbnail if available
                }, { quoted: m });
            } else {
                throw new Error('âŒ *No video download link found from both APIs.*');
            }
        }
    } catch (error) {
        console.error('Error in ytv2 command:', error);
        replygcxlicon('âš ï¸ *An error occurred while processing the video.*');
    }
}
break;

//----------------------------------------------------------------------------------------------//

				
case 'apk': {
  if (!text) return replygcxlicon(`*[â—] Please provide the APK Name you want to download.*`);
  await XliconStickWait();

  try {
    // Fetch APK data from the new API
    let apiUrl = `https://bk9.fun/download/apk?id=${encodeURIComponent(text)}`;
    let response = await fetch(apiUrl);
    let data = await response.json();

    if (data.status !== true) {
      return replygcxlicon(`*[â—] No results found for the APK Name you provided.*`);
    }

    let apkData = data.BK9;

    // Ensure size is a valid string before parsing it
    let sizeMB = 0;
    if (apkData.size && typeof apkData.size === 'string') {
      sizeMB = parseFloat(apkData.size.replace(' MB', ''));
    }

    if (sizeMB > 200) {
      return await XliconBotInc.sendMessage(m.chat, { text: '*[â›”] The file is too large.*' }, { quoted: m });
    }

    // Send the APK file
    await XliconBotInc.sendMessage(
      m.chat,
      {
        document: { url: apkData.dllink },
        mimetype: 'application/vnd.android.package-archive',
        fileName: apkData.name + '.apk',
        caption: `*APK Name:* ${apkData.name}\n*Last Updated:* ${apkData.lastup}\n*Package:* ${apkData.package}`,
      },
      { quoted: m }
    );
  } catch (error) {
    console.error(error);
    return replygcxlicon(`*[â—] An error occurred. Please try again later.*`);
  }
}
break;


case 'modwa': {
  if (!isPremium) return replyprem(mess.premium);

  try {
    // Fetch mod data from the API
    let apiUrl = `${global.api}downloader/wamod?apikey=${global.id}`;
    let response = await fetch(apiUrl);
    let data = await response.json();

    if (data.status !== 200) {
      return replygcxlicon('*[â—] No results found for the mod name you provided.*');
    }

    // Define available mods
    let modsList = `
*Available WhatsApp Mods:*
1. GBWhatsApp - Download with *${prefix}modwa gbwa*
2. WhatsApp Plus - Download with *${prefix}modwa waplus*
3. OGWhatsApp - Download with *${prefix}modwa ogwa*
4. ANWhatsApp - Download with *${prefix}modwa anwa*
5. FMWhatsApp - Download with *${prefix}modwa fmwa*
6. YoWhatsApp - Download with *${prefix}modwa yowa*
7. WhatsAero - Download with *${prefix}modwa aerowa*
8. WhatsApp Gold - Download with *${prefix}modwa goldwa*
9. Karina WhatsApp - Download with *${prefix}modwa karinawa*
`;

    // Send the mod list in reply
    replygcxlicon(modsList);
  } catch (error) {
    console.error(error);
    return replygcxlicon('*[â—] An error occurred. Please try again later.*');
  }
}
break;

case 'modwa_select': {
  try {
    const modName = text.split(' ')[0]; // Extract the mod name from the command
    const modData = {
      gbwa: "https://download2444.mediafire.com/bav6mdrs41vg0s3MIHTKMTYlvAaSRpBCCbGHAQ-c-hjQplzKcqBNHV-mcPSk2IY3IZUvjwRQBqkdrNqJmf5fBuVy9H9-9haNKGWqmeDhAbAzXmn5eqH1kX8m3L_4N19o7UvWOoyjkl0vpVzcDPvQK_PnNYpJw6GM7bn_1150zMYyhaeO/hs2h2jcqw393qvd/GBWhatsApp_Pro_v17.76.apk",
      waplus: "https://download2435.mediafire.com/su3jsxy7lmigblThAiSt7XKA1VJLbh07Q80SmNkfbtP9Blt0siFMCv3fUVKMips_HyaeULLIfC2G8BGY6fxL4g8XW8sXJOQMsb-qpPwB9mYWYS_A3DmljSWK6fsNlI6VA2Pt83_F56GY42n_uDqMFFE6jElziSvgwCxZM72-1VWItfVN/lb5m60dlj1gm03t/WhatsApp_Plus_v17.76.apk",
      ogwa: "https://download2448.mediafire.com/fyip44tzdyogy3Ra0iqGKDB0NQMTEMXCsYY8Kb6TjTKo8fAAyxJdBYCfWELO6vlkoVLkdKFmHrj7hD3aOll2jY0Lnez5LLz_4ypZLhqIfhT4Oa_HJ3KIq8QEWZwGAp6ZhMoKlD3jBpgK_Kvb_OuX_n1nnOluhMfiCLwXyG5tJDdiUqi7/v2n2xs6mw831yy2/OGWhatsApp_Pro_v17.76.apk",
      anwa: "https://files.smart5hone.com/Downloads/AN_V37/redirects.php?forward=https://files.smart5hone.com/apk/anwa/ANWhatsApp_V37.apk",
      fmwa: "https://cdn.fouadmod.com/apk/10.06/FMWA10.06@FouadMOD.com.apk",
      yowa: "https://apk-download.co/V1006/WA10.06@FouadMODS.apk",
      aerowa: "https://download.aeromods.app/AeroMods/WhatsAero/BETA/V9.93/H7dhs4/A_AERO_V9.93_BETA__--com_aero--__aeromods.app__.apk",
      goldwa: "https://files.smart5hone.com/Downloads/Gold_V30/redirects.php?forward=https://files.smart5hone.com/apk/plus/WhatsApp_Gold-V30.apk",
      karinawa: "https://eu2.contabostorage.com/ea5c648569af43439f47ab26502d20f5:butterfly/Karina-Official-Whatsapp-v14-(www.nulledandroid.com).apk"
    };

    const downloadLink = modData[modName];

    if (!downloadLink) {
      return replygcxlicon(`*[â—] Invalid mod name provided.*`);
    }

    // Send the mod download link
    await XliconBotInc.sendMessage(
      m.chat,
      {
        text: `*Mod Name:* ${modName}\n*Download Link:* ${downloadLink}`
      },
      { quoted: m }
    );
  } catch (error) {
    console.error(error);
    return replygcxlicon(`*[â—] An error occurred. Please try again later.*`);
  }
}
break;

case 'mega':{
	try {
if (!text) return replygcxlicon(`${prefix + command} https://mega.nz/file/ovJTHaQZ#yAbkrvQgykcH_NDKQ8eIc0zvsN7jonBbHZ_HTQL6lZ8`);
const { File } = require('megajs');
        const file = File.fromURL(text);
        await file.loadAttributes();
        if (file.size >= 300000000) return replygcxlicon('Error: File size is too large (Maximum Size: 300MB)');
        const downloadingMessage = `ğŸŒ©ï¸ Downloading file... Please wait.`;
        replygcxlicon(downloadingMessage);
        const caption = `*_Successfully downloaded..._*\nFile: ${file.name}\nSize: ${formatBytes(file.size)}`;
        const data = await file.downloadBuffer();
        const fileExtension = path.extname(file.name).toLowerCase();
        const mimeTypes = {
            ".mp4": "video/mp4",
            ".pdf": "application/pdf",
            ".zip": "application/zip",
            ".rar": "application/x-rar-compressed",
            ".7z": "application/x-7z-compressed",
            ".jpg": "image/jpeg",
            ".jpeg": "image/jpeg",
            ".png": "image/png",
        };
        let mimetype = mimeTypes[fileExtension] || "application/octet-stream";
        await XliconBotInc.sendMessage(m.chat, {document: data, mimetype: mimetype, fileName: file.name, caption: caption}, {quoted:m});
    } catch (error) {
        return replygcxlicon(`Error: ${error.message}`);
    }
}
break
			
case 'twitter':
case 'twitterdl': {
  if (!args[0]) {
    return replygcxlicon(`ğŸ“Œ Example:\n*${prefix + command}* https://twitter.com/username/status/1234567890123456789`);
  }

  if (!isUrl(args[0]) || !args[0].includes('twitter.com')) {
    return replygcxlicon('âŒ Invalid Twitter link!');
  }

  try {
    // Fetch data from the new Twitter downloader API
    const response = await axios.get(`https://bk9.fun/download/twitter?url=${encodeURIComponent(args[0])}`);
    
    if (!response.data || !response.data.status) {
      return replygcxlicon('âŒ Unable to fetch data from the link. Please try again later.');
    }

    const { HD, username, caption, thumbnail } = response.data.BK9;

    // Prepare a response message
    const message = `
ğŸ¥ *Twitter Video Download* ğŸ¥

ğŸ‘¤ *Username:* ${username}
ğŸ“„ *Caption:* ${caption || "No caption provided"}

ğŸ”— *HD Quality Video Link:* 
[Click to Download](${HD})

ğŸ“¸ *Thumbnail:* ![Thumbnail](${thumbnail})

Click the link above to download your video!`;

    // Send the message with the video
    await replygcxlicon(message);
    
    // Send the video itself in the chat
    await XliconBotInc.sendMessage(m.chat, {
      video: { url: HD },
      mimetype: 'video/mp4',
      caption: message
    }, { quoted: m });

  } catch (error) {
    console.error(error);
    replygcxlicon('âŒ *An error occurred while processing your request.*\nMake sure the link is valid and try again.');
  }
}
break;
                
case 'threads': {
  try {
    // URL of the Threads API endpoint
    const threadsApiUrl = 'https://api.nexoracle.com/downloader/threads?apikey=free_key@maher_apis&url=https://www.threads.net/t/Cujx6ryoYx6/?igshid=NTc4MTIwNjQ2YQ==';
    
    // Fetching the data from the Threads API
    let res = await fetch(threadsApiUrl);
    let apiResponse = await res.json();

    // Check if the response is valid and contains the required data
    if (apiResponse.status === 200 && apiResponse.result) {
      const { username, profile, downloadLink } = apiResponse.result;

      // Ensure both profile and download link are available
      if (profile && downloadLink) {
        // Check the file type of the downloadLink (image or video)
        const fileExtension = downloadLink.split('.').pop().toLowerCase();
        
        // If the download link is a video or image, send the corresponding type
        if (fileExtension === 'mp4' || fileExtension === 'mov') {
          // If it's a video, send the video file
          await XliconBotInc.sendMessage(m.chat, {
            video: { url: downloadLink },
            caption: `ğŸ¥ *Username:* ${username}\nğŸ“¸ *Profile Image:* ${profile}`,
          }, { quoted: m });
        } else if (['jpg', 'jpeg', 'png', 'gif'].includes(fileExtension)) {
          // If it's an image, send the image
          await XliconBotInc.sendMessage(m.chat, {
            image: { url: downloadLink },
            caption: `ğŸ“¸ *Username:* ${username}\nğŸ“¸ *Profile Image:* ${profile}`,
          }, { quoted: m });
        } else {
          // Handle if the file format is unrecognized
          return replygcxlicon('âŒ *Unrecognized file format for the download link.*');
        }

      } else {
        return replygcxlicon('âŒ *Missing profile or download link.*');
      }
      
    } else {
      return replygcxlicon('âŒ *Failed to fetch thread content.*');
    }

  } catch (error) {
    console.error('Error fetching thread data:', error.message);
    return replygcxlicon('âŒ *An error occurred while fetching thread content.*');
  }
}
break;
			    
    
  case 'fb':
    case 'facebook':
    case 'facebookvid': {
      if (!text) {
        return replygcxlicon(`ğŸ“Œ Please provide a Facebook video link.\n\nExample:\n*${prefix + command}* https://www.facebook.com/share/v/HVm2yjse1usgfF4T`);
      }
    
      try {
        // Fetch video data from the API
        const response = await fetch(`https://bk9.fun/download/videodownloader?input=${encodeURIComponent(text)}`);
        const data = await response.json();
    
        if (!data || !data.status || !data.video || !data.video.videoInfo || data.video.videoInfo.length === 0) {
          return replygcxlicon('âŒ No video found or invalid response from API.');
        }
    
        // Prefer HD video, fallback to SD
        const video = data.video.videoInfo.find(v => v.quality.toLowerCase().includes('hd')) ||
                      data.video.videoInfo.find(v => v.quality.toLowerCase().includes('sd'));
    
        if (!video) {
          return replygcxlicon('âŒ No HD or SD video found.');
        }
    
        const caption = `
 ğŸ¥ *Facebook Video Download* ğŸ¥
    
ğŸ“º *Info*: ${data.video.info || "Not provided"}
â³ *Duration*: ${data.video.duration || "Unknown"}
ğŸ“¹ *Quality*: ${video.quality}
ğŸ’¾ *Format*: ${video.format}
    
ğŸ‘‡ *Download your video below!* ğŸ‘‡
    `.trim();
    
        // Send the video with the caption
        await XliconBotInc.sendMessage(m.chat, {
          video: { url: video.downloadLink },
          caption,
        }, { quoted: m });
    
      } catch (error) {
        console.error(error);
        return replygcxlicon('âŒ An error occurred while processing your request. Please try again later.');
      }
    }
    break;
                    
                             
case 'instagram': case 'insta': case 'ig': case 'igvideo': case 'igvid': {
  if (!text) {
    return replygcxlicon('â— *You need to provide the URL of an Instagram video.*');
  }

  try {
    XliconStickWait();

    // New API URL for Instagram video download
    const apiUrl = `${global.api}downloader/insta?apikey=${global.id}&url=${encodeURIComponent(text)}`;
    const res = await fetch(apiUrl);
    const api_response = await res.json();

    // Validate API response
    if (!api_response || api_response.status !== 200 || !api_response.result || !api_response.result.video) {
      return replygcxlicon('âŒ *No media found or invalid response from the API.*');
    }

    // Extract the video URL from the response
    const videoUrl = api_response.result.video;
    const cap = '*ğŸ‰ Thank you for using xlicon v4!*';

    // Send the video message
    await XliconBotInc.sendMessage(m.chat, {
      video: { url: videoUrl },
      caption: cap
    }, { quoted: m });

  } catch (error) {
    // Handle fetch or processing errors
    return replygcxlicon(`âš ï¸ *An error occurred:* ${error.message}`);
  }
}
break;
        
case 'instagramimg': case 'instaimg': case 'igimage': case 'igimg': {
  if (!text) {
    return replygcxlicon('â— *You need to provide the URL of an Instagram post.*');
  }

  try {
    XliconStickWait();

    // New API URL for Instagram image download
    const apiUrl = `https://bk9.fun/download/instagram2?url=${encodeURIComponent(text)}`;
    const res = await fetch(apiUrl);
    const api_response = await res.json();

    // Validate API response
    if (!api_response || !api_response.status || !api_response.BK9 || api_response.BK9.length === 0) {
      return replygcxlicon('âŒ *No media found or invalid response from the API.*');
    }

    // Extract image URLs from the response
    const imageLinks = api_response.BK9.map(item => item.url);
    const cap = '*ğŸ‰ Thank you for using xlicon v4!*'; // Optional caption for the images

    // Loop through each image and send them
    for (const imageUrl of imageLinks) {
      await XliconBotInc.sendMessage(m.chat, {
        image: { url: imageUrl },
        caption: cap
      }, { quoted: m });
    }

  } catch (error) {
    // Handle fetch or processing errors
    return replygcxlicon(`âš ï¸ *An error occurred:* ${error.message}`);
  }
}
break;
       
           
                
			case 'tiktok': case 'tiktokdown': case 'ttdown': case 'ttdl': case 'tt': case 'ttmp4': case 'ttvideo': case 'tiktokmp4': case 'tiktokvideo': {
				if (!text) return replygcxlicon(`Example: ${prefix + command} url_tiktok`)
				if (!text.includes('tiktok.com')) return replygcxlicon('Url Tidak Mengandung Result Dari Tiktok!')
				const hasil = await tiktokDl(text);
				XliconStickWait()
				if (hasil.size_nowm) {
					await XliconBotInc.sendFileUrl(m.chat, hasil.data[1].url, `*ğŸ“Title:* ${hasil.title}\n*â³Duration:* ${hasil.duration}\n*ğŸƒAuthor:* ${hasil.author.nickname} (@${hasil.author.fullname})`, m)
				} else {
					for (let i = 0; i < hasil.data.length; i++) {
						await XliconBotInc.sendFileUrl(m.chat, hasil.data[i].url, `*ğŸš€Image:* ${i+1}`, m)
					}
				}
			}
			break
			case 'ttmp3': case 'tiktokmp3': case 'ttaudio': case 'tiktokaudio': {
				if (!text) return replygcxlicon(`Example: ${prefix + command} url_tiktok`)
				if (!text.includes('tiktok.com')) return replygcxlicon('Url Tidak Mengandung Result Dari Tiktok!')
				const hasil = await tiktokDl(text);
				XliconStickWait()
				await XliconBotInc.sendMessage(m.chat, {
					audio: { url: hasil.music_info.url },
					mimetype: 'audio/mpeg',
					contextInfo: {
						externalAdReply: {
							title: 'TikTok â€¢ ' + hasil.author.nickname,
							body: hasil.stats.likes + ' suka, ' + hasil.stats.comment + ' komentar. ' + hasil.title,
							previewType: 'PHOTO',
							thumbnailUrl: hasil.cover,
							mediaType: 1,
							renderLargerThumbnail: true,
							sourceUrl: text
						}
					}
				}, { quoted: m });
			}
			break
			
			// Fun Menu
			case 'dice': {
				let ddsa = [{ url: 'https://telegra.ph/file/9f60e4cdbeb79fc6aff7a.png', no: 1 },{ url: 'https://telegra.ph/file/797f86e444755282374ef.png', no: 2 },{ url: 'https://telegra.ph/file/970d2a7656ada7c579b69.png', no: 3 },{ url: 'https://telegra.ph/file/0470d295e00ebe789fb4d.png', no: 4 },{ url: 'https://telegra.ph/file/a9d7332e7ba1d1d26a2be.png', no: 5 },{ url: 'https://telegra.ph/file/99dcd999991a79f9ba0c0.png', no: 6 }]
				let media = pickRandom(ddsa)
				await XliconBotInc.sendImageAsSticker(m.chat, media.url, m, { packname: global.packname, author: global.author, isAvatar: 1 })
			}
			break
			
			// Game Menu
			case 'slot': {
				await gameSlot(XliconBotInc, m, global.db.users)
			}
			break
			case 'casino': {
				await gameCasinoSolo(XliconBotInc, m, prefix, global.db.users)
			}
			break
			case 'robber': case 'rob': {
				await gameMerampok(m, global.db.users)
			}
			break
			case 'suitpvp': case 'suit': {
				let poin = 10
				let poin_lose = 10
				let timeout = 60000
				if (Object.values(game.suit).find(roof => roof.id.startsWith('suit') && [roof.p, roof.p2].includes(m.sender))) replygcxlicon(`Finish your previous suit`)
				if (m.mentionedJid[0] === m.sender) return replygcxlicon(`Can't play with myself !`)
				if (!m.mentionedJid[0]) return replygcxlicon(`_Who do you want to challenge?_\nTag the person..\n\nExample : ${prefix}suit @${owner[0]}`, m.chat, { mentions: [owner[1] + '@s.whatsapp.net'] })
				if (Object.values(game.suit).find(roof => roof.id.startsWith('suit') && [roof.p, roof.p2].includes(m.mentionedJid[0]))) return replygcxlicon(`The person you are challenging is playing suit with someone else :(`)
				let id = 'suit_' + new Date() * 1
				let caption = `_*SUIT PvP*_\n\n@${m.sender.split`@`[0]} challenge @${m.mentionedJid[0].split`@`[0]} to play suits\n\nPlease @${m.mentionedJid[0].split`@`[0]} to type accept/reject`
				game.suit[id] = {
					chat: replygcxlicon(caption),
					id: id,
					p: m.sender,
					p2: m.mentionedJid[0],
					status: 'wait',
					waktu: setTimeout(() => {
						if (game.suit[id]) replygcxlicon(`_Suit time is up_`)
						delete game.suit[id]
					}, 60000), poin, poin_lose, timeout
				}
			}
			break
			case 'ttc': case 'ttt': case 'tictactoe': {
				let TicTacToe = require('./lib/tictactoe');
				if (Object.values(game.tictactoe).find(room => room.id.startsWith('tictactoe') && [room.game.playerX, room.game.playerO].includes(m.sender))) return replygcxlicon(`You are still in the game!\nType *${prefix}del${command}* If you want to end the session`);
				let room = Object.values(game.tictactoe).find(room => room.state === 'WAITING' && (text ? room.name === text : true))
				if (room) {
					replygcxlicon('Partner found!')
					room.o = m.chat
					room.game.playerO = m.sender
					room.state = 'PLAYING'
					let arr = room.game.render().map(v => {
						return {X: 'âŒ',O: 'â­•',1: '1ï¸âƒ£',2: '2ï¸âƒ£',3: '3ï¸âƒ£',4: '4ï¸âƒ£',5: '5ï¸âƒ£',6: '6ï¸âƒ£',7: '7ï¸âƒ£',8: '8ï¸âƒ£',9: '9ï¸âƒ£'}[v]
					})
					let str = `Room ID: ${room.id}\n\n${arr.slice(0, 3).join('')}\n${arr.slice(3, 6).join('')}\n${arr.slice(6).join('')}\n\nWaiting @${room.game.currentTurn.split('@')[0]}\n\nType *surrender* to give up and admit defeat`
					if (room.x !== room.o) await XliconBotInc.sendMessage(room.x, { texr: str, mentions: parseMention(str) }, { quoted: m })
					await XliconBotInc.sendMessage(room.o, { text: str, mentions: parseMention(str) }, { quoted: m })
				} else {
					room = {
						id: 'tictactoe-' + (+new Date),
						x: m.chat,
						o: '',
						game: new TicTacToe(m.sender, 'o'),
						state: 'WAITING',
						waktu: setTimeout(() => {
							if (game.tictactoe[roomnya.id]) replygcxlicon(`_Time ${command} finished_`)
							delete game.tictactoe[roomnya.id]
						}, 300000)
					}
					if (text) room.name = text
					XliconBotInc.sendMessage(m.chat, { text: 'Waiting for partner' + (text ? ` type the command below ${prefix}${command} ${text}` : ''), mentions: m.mentionedJid }, { quoted: m })
					game.tictactoe[room.id] = room
				}
			}
			break
			case 'playbomb': case 'bomb': {
				if (game.tebakbom[m.sender]) return replygcxlicon('There Are Still Unfinished Sessions!')
				function shuffle(array) {
					return array.sort(() => Math.random() - 0.5);
				}
				game.tebakbom[m.sender] = {
					petak: shuffle([0, 0, 0, 2, 0, 2, 0, 2, 0, 0]),
					board: ['1ï¸âƒ£', '2ï¸âƒ£', '3ï¸âƒ£', '4ï¸âƒ£', '5ï¸âƒ£', '6ï¸âƒ£', '7ï¸âƒ£', '8ï¸âƒ£', '9ï¸âƒ£', 'ğŸ”Ÿ'],
					bomb: 3,
					lolos: 7,
					pick: 0,
					nyawa: ['â¤ï¸', 'â¤ï¸', 'â¤ï¸'],
					waktu: setTimeout(() => {
						if (game.tebakbom[m.sender]) replygcxlicon(`_Time ${command} finished_`)
						delete game.tebakbom[m.sender];
					}, 120000)
				}
				replygcxlicon(`*GUESS THE BOMB*\n\n${game.tebakbom[m.sender].board.join("")}\n\nChoose that number! and don't get hit by a bomb!\nBomb : ${game.tebakbom[m.sender].bomb}\nLife : ${game.tebakbom[m.sender].nyawa.join("")}`);
			}
			break

			case 'mathquiz': case 'math': {
				const { genMath, modes } = require('./lib/math');
const axios = require('axios');
				const inputMode = ['noob', 'easy', 'medium', 'hard','extreme','impossible','impossible2'];
				if (!text) return replygcxlicon(`Mode: ${Object.keys(modes).join(' | ')}\nContoh penggunaan: ${prefix}math medium`)
				if (!inputMode.includes(text.toLowerCase())) return replygcxlicon('Mode not found!')
				if (game.kuismath.hasOwnProperty(m.sender.split('@')[0])) return replygcxlicon('There Are Still Unfinished Sessions!')
				let result = await genMath(text.toLowerCase())
				replygcxlicon(`*Berapa hasil dari: ${result.soal.toLowerCase()}*?\n\nTime: ${(result.waktu / 1000).toFixed(2)} detik`).then(() => {
					game.kuismath[m.sender.split('@')[0]] = {
						jawaban: result.jawaban,
						mode: text.toLowerCase()
					}
				})
				await sleep(result.waktu)
				if (game.kuismath.hasOwnProperty(m.sender.split('@')[0])) {
					replygcxlicon('Time has run out\nAnswer: ' + game.kuismath[m.sender.split('@')[0]].jawaban)
					delete game.kuismath[m.sender.split('@')[0]]
				}
			}
			break


//ALL MENUS CODES START FROM HERE      
			
			// Menu
		    case 'menu': case 'help': case 'alive': {
            const timestampe = speed()
            const latensie = speed() - timestampe
            const a = db.users[sender]
            const me = m.sender
			const xmenu_oh = `
â•­â”€â”€âã€Œ *GREETING* ã€â
â”œ *Hi ğŸ‘‹*
â”œ *${m.pushName}* 
â”œ *${xliconytimewisher} ğŸ˜„* 
â•°â”€â”¬â”€â”€â”€â”€â ${readmore}
â•­â”€â”´âã€Œ *USER INFO* ã€â
â”œ *Name* : ${m.pushName ? m.pushName : 'No name'}
â”œ *Number* : +${me.split('@')[0]}
â”œ *Id* : @${m.sender.split('@')[0]}
â”œ *User* : ${isVip ? 'VIP' : isPremium ? 'PREMIUM' : 'FREE'}
â”œ *Limit* : ${isVip ? 'VIP' : global.db.users[m.sender].limit }
â”œ *Money* : ${global.db.users[m.sender] ? global.db.users[m.sender].uang.toLocaleString('en-IN') : '0'}
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´â”€âã€Œ *BOT INFO* ã€â
â”œ *Speed* : ${latensie.toFixed(4)} miliseconds
â”œ *Runtime* : ${runtime(process.uptime())}
â”œ *Host* : ${os.hostname()}
â”œ *Platform* : ${os.platform()}
â”œ *Bot Name* : ${global.botname}
â”œ *Owner* : @${ownernumber[0].split('@')[0]}
â”œ *Mode* : ${XliconBotInc.public ? 'Public' : 'Self'}
â”œ *Total User* : ${Object.keys(global.db.users).length} User
â”œ *Total Hit* : ${global.db.settings[botNumber].totalhit} Hit
â”œ *Total Chat* : ${Object.keys(global.db.groups).length} Chat/Gc
â”œ *Prefix* :ã€Œ ${xprefix} ã€
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´â”€âã€Œ *TIME* ã€â
â”œ *Date* : ${xdate}
â”œ *Day* : ${xday}
â”œ *Time* : ${xtime}
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *MENU* ã€â
â”‚${setv} ${prefix}allmenu
â”‚${setv} ${prefix}searchmenu
â”‚${setv} ${prefix}downloadmenu
â”‚${setv} ${prefix}gamemenu
â”‚${setv} ${prefix}funmenu
â”‚${setv} ${prefix}aimenu
â”‚${setv} ${prefix}groupmenu
â”‚${setv} ${prefix}ownermenu
â”‚${setv} ${prefix}convertmenu
â”‚${setv} ${prefix}listmenu
â”‚${setv} ${prefix}religionmenu
â”‚${setv} ${prefix}animemenu
â”‚${setv} ${prefix}randomphotomenu
â”‚${setv} ${prefix}randomvideomenu
â”‚${setv} ${prefix}stickermenu
â”‚${setv} ${prefix}databasemenu
â”‚${setv} ${prefix}storemenu
â”‚${setv} ${prefix}stalkermenu
â”‚${setv} ${prefix}othermenu
â•°â”€â”€â”€â”€â”€â”€â`
if (typemenu === 'v1') {
  XliconBotInc.sendMessage(m.chat, {
      image: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v2') {
  XliconBotInc.sendMessage(m.chat, {
      text: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              showAdAttribution: true,
              title: botname,
              body: ownername,
              thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
              sourceUrl: wagc,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v3') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v4') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true
  }, {
      quoted: m
  })
} else if (typemenu === 'v6') {
  XliconBotInc.relayMessage(m.chat, {
      requestPaymentMessage: {
          currencyCodeIso4217: 'USD',
          amount1000: '9999999900',
          requestFrom: m.sender,
          noteMessage: {
              extendedTextMessage: {
                  text: xmenu_oh,
                  contextInfo: {
                      externalAdReply: {
                          showAdAttribution: true
                      }
                  }
              }
          }
      }
  }, { quoted: m })
} else if (typemenu === 'v8') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      gifPlayback: true,
      caption: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              title: botname,
              body: ownername,
              thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v9') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true,
      contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          mentionedJid: [sender],
          forwardedNewsletterMessageInfo: {
              newsletterName: ownername,
              newsletterJid: "120363232303807350@newsletter",
          },
          externalAdReply: {
              showAdAttribution: true,
              title: ownername,
              body: botname,
              thumbnailUrl: "https://i.ibb.co/y0nLDSB/XLICON-IMG.jpg",
              sourceUrl: websitex,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
}
}


break
case 'allmenu': {
let xmenu_oh = `
â•­â”€â”€âã€Œ *GREETING* ã€â
â”œ *Hi ğŸ‘‹*
â”œ *${m.pushName}* 
â”œ *${xliconytimewisher} ğŸ˜„* 
â•°â”€â”¬â”€â”€â”€â”€â ${readmore}
â•­â”€â”´âã€Œ *GUIDE* ã€â
â”œ *ğŸ… = For Owner* 
â”œ *ğŸ…• = For Free User*
â”œ *ğŸ…Ÿ = For Premium User*
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Owner* ã€â
â”‚${setv} ${prefix}addbadword ğŸ…
â”‚${setv} ${prefix}delbadword ğŸ…
â”‚${setv} ${prefix}autoread ğŸ…
â”‚${setv} ${prefix}autobio ğŸ…
â”‚${setv} ${prefix}autotype ğŸ…
â”‚${setv} ${prefix}unavailable ğŸ…
â”‚${setv} ${prefix}autorecord ğŸ…
â”‚${setv} ${prefix}autorecordtype ğŸ…
â”‚${setv} ${prefix}autoswview ğŸ…
â”‚${setv} ${prefix}setautoblock ğŸ…
â”‚${setv} ${prefix}setantiforeign ğŸ…
â”‚${setv} ${prefix}autoblock ğŸ…
â”‚${setv} ${prefix}onlygc ğŸ…
â”‚${setv} ${prefix}onlypc ğŸ…
â”‚${setv} ${prefix}onlyindia ğŸ…
â”‚${setv} ${prefix}onlyindo ğŸ…
â”‚${setv} ${prefix}anticall ğŸ…
â”‚${setv} ${prefix}self ğŸ…
â”‚${setv} ${prefix}public ğŸ…
â”‚${setv} ${prefix}join ğŸ…
â”‚${setv} ${prefix}poll ğŸ…
â”‚${setv} ${prefix}spam ğŸ…
â”‚${setv} ${prefix}bc ğŸ…
â”‚${setv} ${prefix}bcgroup ğŸ…
â”‚${setv} ${prefix}setmenu ğŸ…
â”‚${setv} ${prefix}setimgmenu ğŸ…
â”‚${setv} ${prefix}setvidmenu ğŸ…
â”‚${setv} ${prefix}setgifmenu ğŸ…
â”‚${setv} ${prefix}setreply ğŸ…
â”‚${setv} ${prefix}resethit ğŸ…
â”‚${setv} ${prefix}resetuser ğŸ…
â”‚${setv} ${prefix}creategc ğŸ…
â”‚${setv} ${prefix}setexif ğŸ…
â”‚${setv} ${prefix}getexif ğŸ…
â”‚${setv} ${prefix}getautoblocknumber ğŸ…
â”‚${setv} ${prefix}getantiforeignnumber ğŸ…
â”‚${setv} ${prefix}userjid ğŸ…
â”‚${setv} ${prefix}setbotbio ğŸ…
â”‚${setv} ${prefix}delppbot ğŸ…
â”‚${setv} ${prefix}shutdown ğŸ…
â”‚${setv} ${prefix}setppbot ğŸ…
â”‚${setv} ${prefix}addprem ğŸ…
â”‚${setv} ${prefix}delprem ğŸ…
â”‚${setv} ${prefix}addowner ğŸ…
â”‚${setv} ${prefix}delowner ğŸ…
â”‚${setv} ${prefix}addvn ğŸ…
â”‚${setv} ${prefix}addapk ğŸ…
â”‚${setv} ${prefix}addzip ğŸ…
â”‚${setv} ${prefix}addpdf ğŸ…
â”‚${setv} ${prefix}delapk ğŸ…
â”‚${setv} ${prefix}delzip ğŸ…
â”‚${setv} ${prefix}delpdf ğŸ…
â”‚${setv} ${prefix}delvn ğŸ…
â”‚${setv} ${prefix}addsticker ğŸ…
â”‚${setv} ${prefix}delsticker ğŸ…
â”‚${setv} ${prefix}addimage ğŸ…
â”‚${setv} ${prefix}delimage ğŸ…
â”‚${setv} ${prefix}addvideo ğŸ…
â”‚${setv} ${prefix}delvideo ğŸ…
â”‚${setv} ${prefix}upswtext ğŸ…
â”‚${setv} ${prefix}upswvideo ğŸ…
â”‚${setv} ${prefix}upswimage ğŸ…
â”‚${setv} ${prefix}upswaudio ğŸ…
â”‚${setv} ${prefix}autosticker ğŸ…
â”‚${setv} ${prefix}block ğŸ…
â”‚${setv} ${prefix}unblock ğŸ…
â”‚${setv} ${prefix}leavegc ğŸ…
â”‚${setv} ${prefix}pushcontact ğŸ…
â”‚${setv} ${prefix}pushcontactv2 ğŸ…
â”‚${setv} ${prefix}pushcontactv3 ğŸ…
â”‚${setv} ${prefix}jpm ğŸ…
â”‚${setv} ${prefix}checkmember ğŸ…
â”‚${setv} ${prefix}post ğŸ…
â”‚${setv} ${prefix}clearchat ğŸ…
â”‚${setv} ${prefix}setprefix ğŸ…
â”‚${setv} $ ğŸ…
â”‚${setv} > ğŸ…
â”‚${setv} < ğŸ…
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Group* ã€â
â”‚${setv} ${prefix}antibot ğŸ…–
â”‚${setv} ${prefix}antiviewonce ğŸ…–
â”‚${setv} ${prefix}readviewonce ğŸ…–
â”‚${setv} ${prefix}welcome ğŸ…–
â”‚${setv} ${prefix}adminevent ğŸ…–
â”‚${setv} ${prefix}groupevent ğŸ…–
â”‚${setv} ${prefix}antiforeign ğŸ…–
â”‚${setv} ${prefix}antimedia ğŸ…–
â”‚${setv} ${prefix}antiaudio ğŸ…–
â”‚${setv} ${prefix}antivideo ğŸ…–
â”‚${setv} ${prefix}antiimage ğŸ…–
â”‚${setv} ${prefix}antidocument ğŸ…–
â”‚${setv} ${prefix}antilocation ğŸ…–
â”‚${setv} ${prefix}anticontact ğŸ…–
â”‚${setv} ${prefix}antisticker ğŸ…–
â”‚${setv} ${prefix}antipoll ğŸ…–
â”‚${setv} ${prefix}antilink ğŸ…–
â”‚${setv} ${prefix}antiemoji ğŸ…–
â”‚${setv} ${prefix}antipromotion ğŸ…–
â”‚${setv} ${prefix}antivirtex ğŸ…–
â”‚${setv} ${prefix}grouplink ğŸ…–
â”‚${setv} ${prefix}listadmin ğŸ…–
â”‚${setv} ${prefix}invite ğŸ…–
â”‚${setv} ${prefix}ephemeral ğŸ…–
â”‚${setv} ${prefix}delete ğŸ…–
â”‚${setv} ${prefix}setppgroup ğŸ…–
â”‚${setv} ${prefix}delppgroup ğŸ…–
â”‚${setv} ${prefix}setnamegc ğŸ…–
â”‚${setv} ${prefix}setdesc ğŸ…–
â”‚${setv} ${prefix}add ğŸ…–
â”‚${setv} ${prefix}kick ğŸ…–
â”‚${setv} ${prefix}promote ğŸ…–
â”‚${setv} ${prefix}demote ğŸ…–
â”‚${setv} ${prefix}kickall ğŸ…–
â”‚${setv} ${prefix}promoteall ğŸ…–
â”‚${setv} ${prefix}demoteall ğŸ…–
â”‚${setv} ${prefix}getcontact ğŸ…
â”‚${setv} ${prefix}savecontact ğŸ…
â”‚${setv} ${prefix}sendcontact ğŸ…
â”‚${setv} ${prefix}contactag ğŸ…
â”‚${setv} ${prefix}hidetag ğŸ…–
â”‚${setv} ${prefix}totag ğŸ…–
â”‚${setv} ${prefix}tagall ğŸ…–
â”‚${setv} ${prefix}editinfo ğŸ…–
â”‚${setv} ${prefix}opentime ğŸ…–
â”‚${setv} ${prefix}closetime ğŸ…–
â”‚${setv} ${prefix}resetlink ğŸ…–
â”‚${setv} ${prefix}getbio ğŸ…–
â”‚${setv} ${prefix}vote ğŸ…–
â”‚${setv} ${prefix}upvote ğŸ…–
â”‚${setv} ${prefix}downvote ğŸ…–
â”‚${setv} ${prefix}checkvote ğŸ…–
â”‚${setv} ${prefix}delvote ğŸ…–
â”‚${setv} ${prefix}antivirus ğŸ…–
â”‚${setv} ${prefix}antibadword ğŸ…–
â”‚${setv} ${prefix}nsfw ğŸ…–
â”‚${setv} ${prefix}react ğŸ…–
â”‚${setv} ${prefix}getjoinrequest ğŸ…–
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Search* ã€â
â”‚${setv} ${prefix}google ğŸ…•
â”‚${setv} ${prefix}wikipedia ğŸ…•
â”‚${setv} ${prefix}ytsearch ğŸ…•
â”‚${setv} ${prefix}apksearch ğŸ…•
â”‚${setv} ${prefix}stickersearch ğŸ…•
â”‚${setv} ${prefix}imdb ğŸ…•
â”‚${setv} ${prefix}wanumber ğŸ…•
â”‚${setv} ${prefix}friend ğŸ…•
â”‚${setv} ${prefix}lyrics ğŸ…•
â”‚${setv} ${prefix}pixiv ğŸ…•
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Download* ã€â
â”‚${setv} ${prefix}itunes ğŸ…•
â”‚${setv} ${prefix}play ğŸ…•
â”‚${setv} ${prefix}ytmp3 ğŸ…•
â”‚${setv} ${prefix}ytmp4 ğŸ…•
â”‚${setv} ${prefix}yta ğŸ…•
â”‚${setv} ${prefix}ytv ğŸ…•
â”‚${setv} ${prefix}yta2 ğŸ…•
â”‚${setv} ${prefix}ytv2 ğŸ…•
â”‚${setv} ${prefix}image ğŸ…•
â”‚${setv} ${prefix}gimage ğŸ…•
â”‚${setv} ${prefix}live-wallpaper ğŸ…•
â”‚${setv} ${prefix}tiktok ğŸ…•
â”‚${setv} ${prefix}tiktokaudio ğŸ…•
â”‚${setv} ${prefix}tiktokvideo ğŸ…•
â”‚${setv} ${prefix}instagram ğŸ…•
â”‚${setv} ${prefix}igimg ğŸ…•
â”‚${setv} ${prefix}facebook ğŸ…•
â”‚${setv} ${prefix}twitter ğŸ…•
â”‚${setv} ${prefix}apk ğŸ…•
â”‚${setv} ${prefix}modwa ğŸ…•
â”‚${setv} ${prefix}bilibili ğŸ…•
â”‚${setv} ${prefix}dailymotion ğŸ…•
â”‚${setv} ${prefix}mega ğŸ…•
â”‚${setv} ${prefix}mediafire ğŸ…•
â”‚${setv} ${prefix}searchsoundcloud ğŸ…•
â”‚${setv} ${prefix}soundcloud ğŸ…•
â”‚${setv} ${prefix}google ğŸ…•
â”‚${setv} ${prefix}gimage ğŸ…•
â”‚${setv} ${prefix}weather ğŸ…•
â”‚${setv} ${prefix} ğŸ…Ÿ
â”‚${setv} ${prefix}gitclone ğŸ…•
â”‚${setv} ${prefix}happymod ğŸ…•
â”‚${setv} ${prefix}gdrive ğŸ…•
â”‚${setv} ${prefix}pinterest ğŸ…•
â”‚${setv} ${prefix}ringtone ğŸ…•
â”‚${setv} ${prefix}autodownload ğŸ…
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Tool Menu* ã€â
â”‚${setv} ${prefix}obfuscate ğŸ…•
â”‚${setv} ${prefix}styletext ğŸ…•
â”‚${setv} ${prefix}fliptext ğŸ…•
â”‚${setv} ${prefix}tts ğŸ…•
â”‚${setv} ${prefix}say ğŸ…•
â”‚${setv} ${prefix}togif ğŸ…•
â”‚${setv} ${prefix}toqr ğŸ…•
â”‚${setv} ${prefix}bass ğŸ…•
â”‚${setv} ${prefix}blown ğŸ…•
â”‚${setv} ${prefix}deep ğŸ…•
â”‚${setv} ${prefix}earrape ğŸ…•
â”‚${setv} ${prefix}fast ğŸ…•
â”‚${setv} ${prefix}fat ğŸ…•
â”‚${setv} ${prefix}nightcore ğŸ…•
â”‚${setv} ${prefix}reverse ğŸ…•
â”‚${setv} ${prefix}robot ğŸ…•
â”‚${setv} ${prefix}slow ğŸ…•
â”‚${setv} ${prefix}smooth ğŸ…•
â”‚${setv} ${prefix}squirrel ğŸ…•
â”‚${setv} ${prefix}tinyurl ğŸ…•
â”‚${setv} ${prefix}tovn ğŸ…•
â”‚${setv} ${prefix}t ğŸ…•
â”‚${setv} ${prefix}toaudio ğŸ…•
â”‚${setv} ${prefix}tomp3 ğŸ…•
â”‚${setv} ${prefix}tomp4ğŸ…•
â”‚${setv} ${prefix}toimg ğŸ…•
â”‚${setv} ${prefix}toonce ğŸ…•
â”‚${setv} ${prefix}toptv ğŸ…•
â”‚${setv} ${prefix}sticker ğŸ…•
â”‚${setv} ${prefix}smeme ğŸ…•
â”‚${setv} ${prefix}smeta ğŸ…•
â”‚${setv} ${prefix}take ğŸ…Ÿ
â”‚${setv} ${prefix}emojimix ğŸ…•
â”‚${setv} ${prefix}volaudio ğŸ…•
â”‚${setv} ${prefix}volvideo ğŸ…•
â”‚${setv} ${prefix}ebinary ğŸ…•
â”‚${setv} ${prefix}dbinary ğŸ…•
â”‚${setv} ${prefix}ssweb ğŸ…•
â”‚${setv} ${prefix}quoted ğŸ…•
â”‚${setv} ${prefix}translate ğŸ…•
â”‚${setv} ${prefix}get ğŸ…•
â”‚${setv} ${prefix}tourl ğŸ…•
â”‚${setv} ${prefix}write ğŸ…•
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *List Menu* ã€â
â”‚${setv} ${prefix}listprem ğŸ…•
â”‚${setv} ${prefix}listowner ğŸ…•
â”‚${setv} ${prefix}liststicker ğŸ…•
â”‚${setv} ${prefix}listimage ğŸ…•
â”‚${setv} ${prefix}listvideo ğŸ…•
â”‚${setv} ${prefix}listvn ğŸ…•
â”‚${setv} ${prefix}listapk ğŸ…•
â”‚${setv} ${prefix}listzip ğŸ…•
â”‚${setv} ${prefix}listpdf ğŸ…•
â”‚${setv} ${prefix}listbadword ğŸ…•
â”‚${setv} ${prefix}listpc ğŸ…•
â”‚${setv} ${prefix}listgc ğŸ…•
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Random Photo* ã€â
â”‚${setv} ${prefix}aesthetic ğŸ…•
â”‚${setv} ${prefix}coffee ğŸ…•
â”‚${setv} ${prefix}wikimedia ğŸ…•
â”‚${setv} ${prefix}wallpaper ğŸ…•
â”‚${setv} ${prefix}art ğŸ…•
â”‚${setv} ${prefix}bts ğŸ…•
â”‚${setv} ${prefix}dogwoof ğŸ…•
â”‚${setv} ${prefix}catmeow ğŸ…•
â”‚${setv} ${prefix}lizardpic ğŸ…•
â”‚${setv} ${prefix}goosebird ğŸ…•
â”‚${setv} ${prefix}8ballpool ğŸ…•
â”‚${setv} ${prefix}cosplay ğŸ…•
â”‚${setv} ${prefix}hacker ğŸ…•
â”‚${setv} ${prefix}cyber ğŸ…•
â”‚${setv} ${prefix}gamewallpaper ğŸ…•
â”‚${setv} ${prefix}islamic ğŸ…•
â”‚${setv} ${prefix}jennie ğŸ…•
â”‚${setv} ${prefix}jiso ğŸ…•
â”‚${setv} ${prefix}satanic ğŸ…•
â”‚${setv} ${prefix}justina ğŸ…•
â”‚${setv} ${prefix}cartoon ğŸ…•
â”‚${setv} ${prefix}pentol ğŸ…•
â”‚${setv} ${prefix}cat ğŸ…•
â”‚${setv} ${prefix}kpop ğŸ…•
â”‚${setv} ${prefix}exo ğŸ…•
â”‚${setv} ${prefix}lisa ğŸ…•
â”‚${setv} ${prefix}space ğŸ…•
â”‚${setv} ${prefix}car ğŸ…•
â”‚${setv} ${prefix}technology ğŸ…•
â”‚${setv} ${prefix}bike ğŸ…•
â”‚${setv} ${prefix}shortquote ğŸ…•
â”‚${setv} ${prefix}antiwork ğŸ…•
â”‚${setv} ${prefix}hacking ğŸ…•
â”‚${setv} ${prefix}boneka ğŸ…•
â”‚${setv} ${prefix}rose ğŸ…•
â”‚${setv} ${prefix}ryujin ğŸ…•
â”‚${setv} ${prefix}ulzzangboy ğŸ…•
â”‚${setv} ${prefix}ulzzanggirl ğŸ…•
â”‚${setv} ${prefix}wallml ğŸ…•
â”‚${setv} ${prefix}wallphone ğŸ…•
â”‚${setv} ${prefix}mountain ğŸ…•
â”‚${setv} ${prefix}goose ğŸ…•
â”‚${setv} ${prefix}profilepic ğŸ…•
â”‚${setv} ${prefix}couplepp ğŸ…•
â”‚${setv} ${prefix}programming ğŸ…•
â”‚${setv} ${prefix}pubg ğŸ…•
â”‚${setv} ${prefix}blackpink ğŸ…•
â”‚${setv} ${prefix}randomboy ğŸ…•  
â”‚${setv} ${prefix}randomgirl ğŸ…•
â”‚${setv} ${prefix}hijab ğŸ…•  
â”‚${setv} ${prefix}chinese ğŸ…•
â”‚${setv} ${prefix}indo ğŸ…•
â”‚${setv} ${prefix}japanese ğŸ…•
â”‚${setv} ${prefix}korean ğŸ…•
â”‚${setv} ${prefix}malay ğŸ…•
â”‚${setv} ${prefix}thai ğŸ…•
â”‚${setv} ${prefix}vietnamese ğŸ…•
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Random Video* ã€â
â”‚${setv} ${prefix}tiktokgirl ğŸ…•
â”‚${setv} ${prefix}tiktoknukthy ğŸ…•
â”‚${setv} ${prefix}tiktokkayes ğŸ…•
â”‚${setv} ${prefix}tiktokpanrika ğŸ…•
â”‚${setv} ${prefix}tiktoknotnot ğŸ…•
â”‚${setv} ${prefix}tiktokghea ğŸ…•
â”‚${setv} ${prefix}tiktoksantuy ğŸ…•
â”‚${setv} ${prefix}tiktokbocil ğŸ…•
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Stalker* ã€â
â”‚${setv} ${prefix}tiktokstalk ğŸ…•
â”‚${setv} ${prefix}mlstalk ğŸ…•
â”‚${setv} ${prefix}npmstalk ğŸ…•
â”‚${setv} ${prefix}ghstalk ğŸ…•
â”‚${setv} ${prefix}telestalk ğŸ…•
â”‚${setv} ${prefix}wachannelstalk ğŸ…•
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *OpenAI* ã€â
â”‚${setv} ${prefix}
ğŸ…•
â”‚${setv} ${prefix}travel-assistant ğŸ…•
â”‚${setv} ${prefix}realistic ğŸ…•
â”‚${setv} ${prefix}mangaimg ğŸ…•
â”‚${setv} ${prefix}animeimg ğŸ…•
â”‚${setv} ${prefix}lexica ğŸ…•
â”‚${setv} ${prefix}chechkgpt ğŸ…•
â”‚${setv} ${prefix}3dmodel ğŸ…•
â”‚${setv} ${prefix}photoleap ğŸ…•
â”‚${setv} ${prefix}chatgpt ğŸ…•
â”‚${setv} ${prefix}darky ğŸ…•
â”‚${setv} ${prefix}bing ğŸ…•
â”‚${setv} ${prefix}mathsai ğŸ…•
â”‚${setv} ${prefix}openai ğŸ…•
â”‚${setv} ${prefix}dalle ğŸ…•
â”‚${setv} ${prefix}stablediffusion ğŸ…•
â”‚${setv} ${prefix}ai ğŸ…•
â”‚${setv} ${prefix}remini ğŸ…•
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Game* ã€â
â”‚${setv} ${prefix}truth ğŸ…•
â”‚${setv} ${prefix}dare ğŸ…•
â”‚${setv} ${prefix}suit ğŸ…•
â”‚${setv} ${prefix}tictactoe ğŸ…•
â”‚${setv} ${prefix}math ğŸ…•
â”‚${setv} ${prefix}playbomb ğŸ…•
â”‚${setv} ${prefix}casino ğŸ…•
â”‚${setv} ${prefix}rob ğŸ…•
â”‚${setv} ${prefix}slot ğŸ…•
â”‚${setv} ${prefix}dice ğŸ…• 
â”‚${setv} ${prefix}profile ğŸ…•
â”‚${setv} ${prefix}claim ğŸ…•
â”‚${setv} ${prefix}tmoney ğŸ…•
â”‚${setv} ${prefix}tflimit ğŸ…•
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Fun* ã€â
â”‚${setv} ${prefix}define ğŸ…•
â”‚${setv} ${prefix}readmore ğŸ…•
â”‚${setv} ${prefix}yomamajoke ğŸ…•
â”‚${setv} ${prefix}fact ğŸ…•
â”‚${setv} ${prefix}couple ğŸ…•
â”‚${setv} ${prefix}soulmate ğŸ…•
â”‚${setv} ${prefix}stupidcheck ğŸ…•
â”‚${setv} ${prefix}handsomecheck ğŸ…•
â”‚${setv} ${prefix}uncleancheck ğŸ…•
â”‚${setv} ${prefix}hotcheck ğŸ…•
â”‚${setv} ${prefix}smartcheck ğŸ…•
â”‚${setv} ${prefix}greatcheck ğŸ…•
â”‚${setv} ${prefix}evilcheck ğŸ…•
â”‚${setv} ${prefix}dogcheck ğŸ…•
â”‚${setv} ${prefix}coolcheck ğŸ…•
â”‚${setv} ${prefix}waifucheck ğŸ…•
â”‚${setv} ${prefix}awesomecheck ğŸ…•
â”‚${setv} ${prefix}gaycheck ğŸ…•
â”‚${setv} ${prefix}cutecheck ğŸ…•
â”‚${setv} ${prefix}lesbiancheck ğŸ…•
â”‚${setv} ${prefix}hornycheck ğŸ…•
â”‚${setv} ${prefix}prettycheck ğŸ…•
â”‚${setv} ${prefix}lovelycheck ğŸ…•
â”‚${setv} ${prefix}uglycheck ğŸ…•
â”‚${setv} ${prefix}pick ğŸ…•
â”‚${setv} ${prefix}pickupline ğŸ…•
â”‚${setv} ${prefix}quotes ğŸ…•
â”‚${setv} ${prefix}can ğŸ…•
â”‚${setv} ${prefix}is ğŸ…•
â”‚${setv} ${prefix}when ğŸ…•
â”‚${setv} ${prefix}where ğŸ…•
â”‚${setv} ${prefix}what ğŸ…•
â”‚${setv} ${prefix}how ğŸ…•
â”‚${setv} ${prefix}rate ğŸ…•
â”‚${setv} ${prefix}cry ğŸ…•
â”‚${setv} ${prefix}kill ğŸ…•
â”‚${setv} ${prefix}hug ğŸ…•
â”‚${setv} ${prefix}pat ğŸ…•
â”‚${setv} ${prefix}lick ğŸ…• 
â”‚${setv} ${prefix}kiss ğŸ…•
â”‚${setv} ${prefix}bite ğŸ…•
â”‚${setv} ${prefix}yeet ğŸ…•
â”‚${setv} ${prefix}bully ğŸ…•
â”‚${setv} ${prefix}bonk ğŸ…•
â”‚${setv} ${prefix}wink ğŸ…•
â”‚${setv} ${prefix}poke ğŸ…•
â”‚${setv} ${prefix}nom ğŸ…•
â”‚${setv} ${prefix}slap ğŸ…•
â”‚${setv} ${prefix}smile ğŸ…• 
â”‚${setv} ${prefix}wave ğŸ…•
â”‚${setv} ${prefix}awoo ğŸ…•
â”‚${setv} ${prefix}blush ğŸ…•
â”‚${setv} ${prefix}smug ğŸ…•
â”‚${setv} ${prefix}glomp ğŸ…• 
â”‚${setv} ${prefix}happy ğŸ…•
â”‚${setv} ${prefix}dance ğŸ…•
â”‚${setv} ${prefix}cringe ğŸ…•
â”‚${setv} ${prefix}cuddle ğŸ…•
â”‚${setv} ${prefix}highfive ğŸ…• 
â”‚${setv} ${prefix}handhold ğŸ…•
â”‚${setv} ${prefix}spank ğŸ…•
â”‚${setv} ${prefix}tickle ğŸ…•
â”‚${setv} ${prefix}feed ğŸ…•
â”‚${setv} ${prefix}checkme ğŸ…•
â”‚${setv} ${prefix}sound1 - sound161 ğŸ…•
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Sticker* ã€â
â”‚${setv} ${prefix}goose ğŸ…•
â”‚${setv} ${prefix}woof ğŸ…•
â”‚${setv} ${prefix}8ball ğŸ…•
â”‚${setv} ${prefix}lizard ğŸ…•
â”‚${setv} ${prefix}meow ğŸ…•
â”‚${setv} ${prefix}gura ğŸ…•
â”‚${setv} ${prefix}telestick ğŸ…•
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Anime* ã€â
â”‚${setv} ${prefix}searchanime ğŸ…•
â”‚${setv} ${prefix}animeinfo  ğŸ…•
â”‚${setv} ${prefix}animeid ğŸ…•
â”‚${setv} ${prefix}animedl ğŸ…•
â”‚${setv} ${prefix}searchmanga ğŸ…•
â”‚${setv} ${prefix}amv ğŸ…•
â”‚${setv} ${prefix}mangainfo ğŸ…•
â”‚${setv} ${prefix}searchchapter ğŸ…•
â”‚â”‚${setv} ${prefix}mangachapter ğŸ…•
â”‚â”‚${setv} ${prefix}randommanga ğŸ…•
â”‚${setv} ${prefix}stickhandhold ğŸ…•
â”‚${setv} ${prefix}stickshinobu ğŸ…•
â”‚${setv} ${prefix}stickcuddle ğŸ…•
â”‚${setv} ${prefix}stickhighfive ğŸ…•
â”‚${setv} ${prefix}stickdance ğŸ…•
â”‚${setv} ${prefix}stickcringe ğŸ…•
â”‚${setv} ${prefix}stickhappy ğŸ…•
â”‚${setv} ${prefix}stickglomp ğŸ…•
â”‚${setv} ${prefix}sticksmug ğŸ…•
â”‚${setv} ${prefix}stickblush ğŸ…•
â”‚${setv} ${prefix}stickawoo ğŸ…•
â”‚${setv} ${prefix}stickwave ğŸ…•
â”‚${setv} ${prefix}sticksmile ğŸ…•
â”‚${setv} ${prefix}stickslap ğŸ…•
â”‚${setv} ${prefix}stickpoke ğŸ…•
â”‚${setv} ${prefix}stickwink ğŸ…•
â”‚${setv} ${prefix}stickbonk ğŸ…•
â”‚${setv} ${prefix}stickbully ğŸ…•
â”‚${setv} ${prefix}stickyeet ğŸ…•
â”‚${setv} ${prefix}stickbike ğŸ…•
â”‚${setv} ${prefix}stickkiss ğŸ…•
â”‚${setv} ${prefix}sticklick ğŸ…•
â”‚${setv} ${prefix}stickpat ğŸ…•
â”‚${setv} ${prefix}stickhug ğŸ…•
â”‚${setv} ${prefix}stickkill ğŸ…•
â”‚${setv} ${prefix}stickcry ğŸ…•
â”‚${setv} ${prefix}stickspank ğŸ…•
â”‚${setv} ${prefix}sticktickle ğŸ…•
â”‚${setv} ${prefix}traceanime ğŸ…•
â”‚${setv} ${prefix}akira ğŸ…•
â”‚${setv} ${prefix}akiyama ğŸ…•
â”‚${setv} ${prefix}ana ğŸ…•
â”‚${setv} ${prefix}asuna ğŸ…•
â”‚${setv} ${prefix}ayuzawa ğŸ…•
â”‚${setv} ${prefix}boruto ğŸ…•
â”‚${setv} ${prefix}chiho ğŸ…•
â”‚${setv} ${prefix}chitoge ğŸ…•
â”‚${setv} ${prefix}cosplayloli ğŸ…•
â”‚${setv} ${prefix}cosplaysagiri ğŸ…•
â”‚${setv} ${prefix}deidara ğŸ…•
â”‚${setv} ${prefix}doraemon ğŸ…•
â”‚${setv} ${prefix}elaina ğŸ…•
â”‚${setv} ${prefix}emilia ğŸ…•
â”‚${setv} ${prefix}erza ğŸ…•
â”‚${setv} ${prefix}gremory ğŸ…•
â”‚${setv} ${prefix}hestia ğŸ…•
â”‚${setv} ${prefix}husbu ğŸ…•
â”‚${setv} ${prefix}inori ğŸ…•
â”‚${setv} ${prefix}isuzu ğŸ…•
â”‚${setv} ${prefix}itachi ğŸ…•
â”‚${setv} ${prefix}itori ğŸ…•
â”‚${setv} ${prefix}kaga ğŸ…•
â”‚${setv} ${prefix}kagura ğŸ…•
â”‚${setv} ${prefix}kakasih ğŸ…•
â”‚${setv} ${prefix}kaori ğŸ…•
â”‚${setv} ${prefix}keneki ğŸ…•
â”‚${setv} ${prefix}kotori ğŸ…•
â”‚${setv} ${prefix}kurumi ğŸ…•
â”‚${setv} ${prefix}loli ğŸ…•
â”‚${setv} ${prefix}loli2 ğŸ…•
â”‚${setv} ${prefix}madara ğŸ…•
â”‚${setv} ${prefix}megumin ğŸ…•
â”‚${setv} ${prefix}mikasa ğŸ…•
â”‚${setv} ${prefix}mikey ğŸ…•
â”‚${setv} ${prefix}miku ğŸ…•
â”‚${setv} ${prefix}minato ğŸ…•
â”‚${setv} ${prefix}naruto ğŸ…•
â”‚${setv} ${prefix}neko ğŸ…•
â”‚${setv} ${prefix}nekonime ğŸ…•
â”‚${setv} ${prefix}nezuko ğŸ…•
â”‚${setv} ${prefix}onepiece ğŸ…•
â”‚${setv} ${prefix}pokemon ğŸ…•
â”‚${setv} ${prefix}randomnime ğŸ…•
â”‚${setv} ${prefix}randomnime2 ğŸ…•
â”‚${setv} ${prefix}rize ğŸ…•
â”‚${setv} ${prefix}sagiri ğŸ…•
â”‚${setv} ${prefix}sakura ğŸ…•
â”‚${setv} ${prefix}sasuke ğŸ…•
â”‚${setv} ${prefix}shina ğŸ…•
â”‚${setv} ${prefix}shinka ğŸ…•
â”‚${setv} ${prefix}shinomiya ğŸ…•
â”‚${setv} ${prefix}shizuka ğŸ…•
â”‚${setv} ${prefix}shota ğŸ…•
â”‚${setv} ${prefix}tejina ğŸ…•
â”‚${setv} ${prefix}toukachan ğŸ…•
â”‚${setv} ${prefix}tsunade ğŸ…•
â”‚${setv} ${prefix}waifu ğŸ…•
â”‚${setv} ${prefix}waifu2 ğŸ…•
â”‚${setv} ${prefix}animewall ğŸ…•
â”‚${setv} ${prefix}yotsuba ğŸ…•
â”‚${setv} ${prefix}yuki ğŸ…•
â”‚${setv} ${prefix}yulibocil ğŸ…•
â”‚${setv} ${prefix}yumeko ğŸ…•
â”‚${setv} ${prefix}8ball ğŸ…•
â”‚${setv} ${prefix}animeawoo ğŸ…•
â”‚${setv} ${prefix}animemegumin ğŸ…•
â”‚${setv} ${prefix}animeshinobu ğŸ…•
â”‚${setv} ${prefix}animehandhold ğŸ…•
â”‚${setv} ${prefix}animehighfive ğŸ…•
â”‚${setv} ${prefix}animecringe ğŸ…•
â”‚${setv} ${prefix}animedance ğŸ…•
â”‚${setv} ${prefix}animehappy ğŸ…•
â”‚${setv} ${prefix}animeglomp ğŸ…•
â”‚${setv} ${prefix}animeblush ğŸ…•
â”‚${setv} ${prefix}animesmug ğŸ…•
â”‚${setv} ${prefix}animewave ğŸ…•
â”‚${setv} ${prefix}animesmille ğŸ…•
â”‚${setv} ${prefix}animepoke ğŸ…•
â”‚${setv} ${prefix}animewink ğŸ…•
â”‚${setv} ${prefix}animebonk ğŸ…•
â”‚${setv} ${prefix}animebully ğŸ…•
â”‚${setv} ${prefix}animeyeet ğŸ…•
â”‚${setv} ${prefix}animebite ğŸ…•
â”‚${setv} ${prefix}animelick ğŸ…•
â”‚${setv} ${prefix}animekill ğŸ…•
â”‚${setv} ${prefix}animecry ğŸ…•
â”‚${setv} ${prefix}animewlp ğŸ…•
â”‚${setv} ${prefix}animekiss ğŸ…•
â”‚${setv} ${prefix}animehug ğŸ…•
â”‚${setv} ${prefix}animeneko ğŸ…•
â”‚${setv} ${prefix}animepat ğŸ…•
â”‚${setv} ${prefix}animeslap ğŸ…•
â”‚${setv} ${prefix}animecuddle ğŸ…•
â”‚${setv} ${prefix}animewaifu ğŸ…•
â”‚${setv} ${prefix}animenom ğŸ…•
â”‚${setv} ${prefix}animefoxgirl ğŸ…•
â”‚${setv} ${prefix}animegecg ğŸ…•
â”‚${setv} ${prefix}animetickle ğŸ…•
â”‚${setv} ${prefix}animefeed ğŸ…•
â”‚${setv} ${prefix}animeavatar ğŸ…•
â”‚${setv} ${prefix}anime ğŸ…•
â”‚${setv} ${prefix}avatar ğŸ…•
â”‚${setv} ${prefix}shinobu ğŸ…•
â”‚${setv} ${prefix}fox_girl ğŸ…•
â”‚${setv} ${prefix}gecg ğŸ…• 
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Anime NSFW* ã€â
â”‚ _Sorry USERS_
â”‚ NO NSFW MENU AVAILABLE
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Database* ã€â
â”‚${setv} ${prefix}setcmd ğŸ…
â”‚${setv} ${prefix}delcmd ğŸ…
â”‚${setv} ${prefix}listcmd ğŸ…•
â”‚${setv} ${prefix}lockcmd ğŸ…
â”‚${setv} ${prefix}addmsg ğŸ…
â”‚${setv} ${prefix}delmsg ğŸ…
â”‚${setv} ${prefix}getmsg ğŸ…•
â”‚${setv} ${prefix}listmsg ğŸ…•
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Store* ã€â
â”‚${setv} ${prefix}list ğŸ…•
â”‚${setv} ${prefix}store ğŸ…•
â”‚${setv} ${prefix}shop ğŸ…•
â”‚${setv} ${prefix}addlist ğŸ…
â”‚${setv} ${prefix}dellist ğŸ…
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Religon* ã€â
â”‚${setv} ${prefix}bible ğŸ…•
â”‚${setv} ${prefix}quran ğŸ…•
â”‚${setv} ${prefix}gita ğŸ…•
â”‚${setv} ${prefix}namazchk ğŸ…•
â”‚${setv} ${prefix}prophetname ğŸ…•
â”‚${setv} ${prefix}prayertime ğŸ…•
â”‚${setv} ${prefix}sahihbukhari ğŸ…•
â”‚${setv} ${prefix}jamiattirmidhi ğŸ…•
â”‚${setv} ${prefix}sunanannasai ğŸ…•
â”‚${setv} ${prefix}sunanibnmajah ğŸ…•
â”‚${setv} ${prefix}sunanabudawud ğŸ…•
â”‚${setv} ${prefix}kisahnabi ğŸ…•
â”‚${setv} ${prefix}asmaulhusna ğŸ…•
â”‚${setv} ${prefix}duas ğŸ…•
â”‚${setv} ${prefix}namaz ğŸ…•
â”‚${setv} ${prefix}masnoonduas ğŸ…•
â”‚${setv} ${prefix}ayatalkursi ğŸ…•
â”‚${setv} ${prefix}niyatnamaz ğŸ…•
â”‚${setv} ${prefix}quotesislami ğŸ…•
â”‚${setv} ${prefix}assalamualaikum ğŸ…•
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Other* ã€â
â”‚${setv} ${prefix}update ğŸ…•
â”‚${setv} ${prefix}cricket ğŸ…•
â”‚${setv} ${prefix}score ğŸ…•
â”‚${setv} ${prefix}ping ğŸ…•
â”‚${setv} ${prefix}menu ğŸ…•
â”‚${setv} ${prefix}myip ğŸ…•
â”‚${setv} ${prefix}repo ğŸ…•
â”‚${setv} ${prefix}reportbug ğŸ…•
â”‚${setv} ${prefix}idgroup ğŸ…•
â”‚${setv} ${prefix}owner ğŸ…•
â”‚${setv} ${prefix}rentbot ğŸ…•
â”‚${setv} ${prefix}donate ğŸ…•
â”‚${setv} ${prefix}runtime ğŸ…•
â”‚${setv} ${prefix}confess ğŸ…•
â”‚${setv} ${prefix}react ğŸ…•
â”‚${setv} ${prefix}q ğŸ…•
â”‚${setv} ${prefix}inspect ğŸ…•
â”‚${setv} ${prefix}tagme ğŸ…•
â”‚${setv} ${prefix}nowa ğŸ…•
â”‚${setv} ${prefix}truecaller ğŸ…•
â•°â”€â”€â”€â”€â”€â”€â`
if (typemenu === 'v1') {
  XliconBotInc.sendMessage(m.chat, {
      image: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v2') {
  XliconBotInc.sendMessage(m.chat, {
      text: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              showAdAttribution: true,
              title: botname,
              body: ownername,
              thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
              sourceUrl: wagc,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v3') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v4') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true
  }, {
      quoted: m
  })
} else if (typemenu === 'v6') {
  XliconBotInc.relayMessage(m.chat, {
      requestPaymentMessage: {
          currencyCodeIso4217: 'USD',
          amount1000: '9999999900',
          requestFrom: m.sender,
          noteMessage: {
              extendedTextMessage: {
                  text: xmenu_oh,
                  contextInfo: {
                      externalAdReply: {
                          showAdAttribution: true
                      }
                  }
              }
          }
      }
  }, { quoted: m })
} else if (typemenu === 'v8') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      gifPlayback: true,
      caption: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              title: botname,
              body: ownername,
              thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v9') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true,
      contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          mentionedJid: [sender],
          forwardedNewsletterMessageInfo: {
              newsletterName: ownername,
              newsletterJid: "120363232303807350@newsletter",
          },
          externalAdReply: {
              showAdAttribution: true,
              title: ownername,
              body: botname,
              thumbnailUrl: "https://i.ibb.co/y0nLDSB/XLICON-IMG.jpg",
              sourceUrl: websitex,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
}
}
break

case 'ownermenu': {
let xmenu_oh = `
â•­â”€â”€âã€Œ *GREETING* ã€â
â”œ *Hi ğŸ‘‹*
â”œ *${m.pushName}* 
â”œ *${xliconytimewisher} ğŸ˜„* 
â•°â”€â”¬â”€â”€â”€â”€â ${readmore}
â•­â”€â”´âã€Œ *GUIDE* ã€â
â”œ *ğŸ… = For Owner* 
â”œ *ğŸ…• = For Free User*
â”œ *ğŸ…Ÿ = For Premium User*
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Owner* ã€â
â”‚${setv} ${prefix}addbadword ğŸ…
â”‚${setv} ${prefix}delbadword ğŸ…
â”‚${setv} ${prefix}autoread ğŸ…
â”‚${setv} ${prefix}autobio ğŸ…
â”‚${setv} ${prefix}autotype ğŸ…
â”‚${setv} ${prefix}unavailable ğŸ…
â”‚${setv} ${prefix}autorecord ğŸ…
â”‚${setv} ${prefix}autorecordtype ğŸ…
â”‚${setv} ${prefix}autoswview ğŸ…
â”‚${setv} ${prefix}setautoblock ğŸ…
â”‚${setv} ${prefix}setantiforeign ğŸ…
â”‚${setv} ${prefix}autoblock ğŸ…
â”‚${setv} ${prefix}onlygc ğŸ…
â”‚${setv} ${prefix}onlypc ğŸ…
â”‚${setv} ${prefix}onlyindia ğŸ…
â”‚${setv} ${prefix}onlyindo ğŸ…
â”‚${setv} ${prefix}anticall ğŸ…
â”‚${setv} ${prefix}self ğŸ…
â”‚${setv} ${prefix}public ğŸ…
â”‚${setv} ${prefix}join ğŸ…
â”‚${setv} ${prefix}poll ğŸ…
â”‚${setv} ${prefix}spam ğŸ…
â”‚${setv} ${prefix}bc ğŸ…
â”‚${setv} ${prefix}bcgroup ğŸ…
â”‚${setv} ${prefix}setmenu ğŸ…
â”‚${setv} ${prefix}setimgmenu ğŸ…
â”‚${setv} ${prefix}setvidmenu ğŸ…
â”‚${setv} ${prefix}setgifmenu ğŸ…
â”‚${setv} ${prefix}setreply ğŸ…
â”‚${setv} ${prefix}resethit ğŸ…
â”‚${setv} ${prefix}resetuser ğŸ…
â”‚${setv} ${prefix}creategc ğŸ…
â”‚${setv} ${prefix}setexif ğŸ…
â”‚${setv} ${prefix}getexif ğŸ…
â”‚${setv} ${prefix}getautoblocknumber ğŸ…
â”‚${setv} ${prefix}getantiforeignnumber ğŸ…
â”‚${setv} ${prefix}userjid ğŸ…
â”‚${setv} ${prefix}setbotbio ğŸ…
â”‚${setv} ${prefix}delppbot ğŸ…
â”‚${setv} ${prefix}shutdown ğŸ…
â”‚${setv} ${prefix}setppbot ğŸ…
â”‚${setv} ${prefix}addprem ğŸ…
â”‚${setv} ${prefix}delprem ğŸ…
â”‚${setv} ${prefix}addowner ğŸ…
â”‚${setv} ${prefix}delowner ğŸ…
â”‚${setv} ${prefix}addvn ğŸ…
â”‚${setv} ${prefix}addapk ğŸ…
â”‚${setv} ${prefix}addzip ğŸ…
â”‚${setv} ${prefix}addpdf ğŸ…
â”‚${setv} ${prefix}delapk ğŸ…
â”‚${setv} ${prefix}delzip ğŸ…
â”‚${setv} ${prefix}delpdf ğŸ…
â”‚${setv} ${prefix}delvn ğŸ…
â”‚${setv} ${prefix}addsticker ğŸ…
â”‚${setv} ${prefix}delsticker ğŸ…
â”‚${setv} ${prefix}addimage ğŸ…
â”‚${setv} ${prefix}delimage ğŸ…
â”‚${setv} ${prefix}addvideo ğŸ…
â”‚${setv} ${prefix}delvideo ğŸ…
â”‚${setv} ${prefix}upswtext ğŸ…
â”‚${setv} ${prefix}upswvideo ğŸ…
â”‚${setv} ${prefix}upswimage ğŸ…
â”‚${setv} ${prefix}upswaudio ğŸ…
â”‚${setv} ${prefix}autosticker ğŸ…
â”‚${setv} ${prefix}block ğŸ…
â”‚${setv} ${prefix}unblock ğŸ…
â”‚${setv} ${prefix}leavegc ğŸ…
â”‚${setv} ${prefix}pushcontact ğŸ…
â”‚${setv} ${prefix}pushcontactv2 ğŸ…
â”‚${setv} ${prefix}pushcontactv3 ğŸ…
â”‚${setv} ${prefix}jpm ğŸ…
â”‚${setv} ${prefix}checkmember ğŸ…
â”‚${setv} ${prefix}post ğŸ…
â”‚${setv} ${prefix}clearchat ğŸ…
â”‚${setv} ${prefix}setprefix ğŸ…
â”‚${setv} $ ğŸ…
â”‚${setv} > ğŸ…
â”‚${setv} < ğŸ…
â•°â”€â”€â”€â”€â”€â”€â`
if (typemenu === 'v1') {
  XliconBotInc.sendMessage(m.chat, {
      image: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v2') {
  XliconBotInc.sendMessage(m.chat, {
      text: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              showAdAttribution: true,
              title: botname,
              body: ownername,
              thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
              sourceUrl: wagc,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v3') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v4') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true
  }, {
      quoted: m
  })
} else if (typemenu === 'v6') {
  XliconBotInc.relayMessage(m.chat, {
      requestPaymentMessage: {
          currencyCodeIso4217: 'USD',
          amount1000: '9999999900',
          requestFrom: m.sender,
          noteMessage: {
              extendedTextMessage: {
                  text: xmenu_oh,
                  contextInfo: {
                      externalAdReply: {
                          showAdAttribution: true
                      }
                  }
              }
          }
      }
  }, { quoted: m })
} else if (typemenu === 'v8') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      gifPlayback: true,
      caption: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              title: botname,
              body: ownername,
              thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v9') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true,
      contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          mentionedJid: [sender],
          forwardedNewsletterMessageInfo: {
              newsletterName: ownername,
              newsletterJid: "120363232303807350@newsletter",
          },
          externalAdReply: {
              showAdAttribution: true,
              title: ownername,
              body: botname,
              thumbnailUrl: "https://i.ibb.co/y0nLDSB/XLICON-IMG.jpg",
              sourceUrl: websitex,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
}
}
break

case 'groupmenu': {
let xmenu_oh = `
â•­â”€â”€âã€Œ *GREETING* ã€â
â”œ *Hi ğŸ‘‹*
â”œ *${m.pushName}* 
â”œ *${xliconytimewisher} ğŸ˜„* 
â•°â”€â”¬â”€â”€â”€â”€â ${readmore}
â•­â”€â”´âã€Œ *GUIDE* ã€â
â”œ *ğŸ… = For Owner* 
â”œ *ğŸ…• = For Free User*
â”œ *ğŸ…Ÿ = For Premium User*
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Group* ã€â
â”‚${setv} ${prefix}antibot ğŸ…–
â”‚${setv} ${prefix}antiviewonce ğŸ…–
â”‚${setv} ${prefix}readviewonce ğŸ…–
â”‚${setv} ${prefix}welcome ğŸ…–
â”‚${setv} ${prefix}adminevent ğŸ…–
â”‚${setv} ${prefix}groupevent ğŸ…–
â”‚${setv} ${prefix}antiforeign ğŸ…–
â”‚${setv} ${prefix}antimedia ğŸ…–
â”‚${setv} ${prefix}antiaudio ğŸ…–
â”‚${setv} ${prefix}antivideo ğŸ…–
â”‚${setv} ${prefix}antiimage ğŸ…–
â”‚${setv} ${prefix}antidocument ğŸ…–
â”‚${setv} ${prefix}antilocation ğŸ…–
â”‚${setv} ${prefix}anticontact ğŸ…–
â”‚${setv} ${prefix}antisticker ğŸ…–
â”‚${setv} ${prefix}antipoll ğŸ…–
â”‚${setv} ${prefix}antilink ğŸ…–
â”‚${setv} ${prefix}antipromotion ğŸ…–
â”‚${setv} ${prefix}antivirtex ğŸ…–
â”‚${setv} ${prefix}grouplink ğŸ…–
â”‚${setv} ${prefix}listadmin ğŸ…–
â”‚${setv} ${prefix}invite ğŸ…–
â”‚${setv} ${prefix}ephemeral ğŸ…–
â”‚${setv} ${prefix}delete ğŸ…–
â”‚${setv} ${prefix}setppgroup ğŸ…–
â”‚${setv} ${prefix}delppgroup ğŸ…–
â”‚${setv} ${prefix}setnamegc ğŸ…–
â”‚${setv} ${prefix}setdesc ğŸ…–
â”‚${setv} ${prefix}add ğŸ…–
â”‚${setv} ${prefix}kick ğŸ…–
â”‚${setv} ${prefix}promote ğŸ…–
â”‚${setv} ${prefix}demote ğŸ…–
â”‚${setv} ${prefix}kickall ğŸ…–
â”‚${setv} ${prefix}promoteall ğŸ…–
â”‚${setv} ${prefix}demoteall ğŸ…–
â”‚${setv} ${prefix}getcontact ğŸ…
â”‚${setv} ${prefix}savecontact ğŸ…
â”‚${setv} ${prefix}sendcontact ğŸ…
â”‚${setv} ${prefix}contactag ğŸ…
â”‚${setv} ${prefix}hidetag ğŸ…–
â”‚${setv} ${prefix}totag ğŸ…–
â”‚${setv} ${prefix}tagall ğŸ…–
â”‚${setv} ${prefix}editinfo ğŸ…–
â”‚${setv} ${prefix}opentime ğŸ…–
â”‚${setv} ${prefix}closetime ğŸ…–
â”‚${setv} ${prefix}resetlink ğŸ…–
â”‚${setv} ${prefix}getbio ğŸ…–
â”‚${setv} ${prefix}vote ğŸ…–
â”‚${setv} ${prefix}upvote ğŸ…–
â”‚${setv} ${prefix}downvote ğŸ…–
â”‚${setv} ${prefix}checkvote ğŸ…–
â”‚${setv} ${prefix}delvote ğŸ…–
â”‚${setv} ${prefix}antivirus ğŸ…–
â”‚${setv} ${prefix}antibadword ğŸ…–
â”‚${setv} ${prefix}nsfw ğŸ…–
â”‚${setv} ${prefix}react ğŸ…–
â”‚${setv} ${prefix}getjoinrequest ğŸ…–
â•°â”€â”€â”€â”€â”€â”€â`
if (typemenu === 'v1') {
  XliconBotInc.sendMessage(m.chat, {
      image: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v2') {
  XliconBotInc.sendMessage(m.chat, {
      text: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              showAdAttribution: true,
              title: botname,
              body: ownername,
              thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
              sourceUrl: wagc,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v3') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v4') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true
  }, {
      quoted: m
  })
} else if (typemenu === 'v6') {
  XliconBotInc.relayMessage(m.chat, {
      requestPaymentMessage: {
          currencyCodeIso4217: 'USD',
          amount1000: '9999999900',
          requestFrom: m.sender,
          noteMessage: {
              extendedTextMessage: {
                  text: xmenu_oh,
                  contextInfo: {
                      externalAdReply: {
                          showAdAttribution: true
                      }
                  }
              }
          }
      }
  }, { quoted: m })
} else if (typemenu === 'v8') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      gifPlayback: true,
      caption: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              title: botname,
              body: ownername,
              thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v9') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true,
      contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          mentionedJid: [sender],
          forwardedNewsletterMessageInfo: {
              newsletterName: ownername,
              newsletterJid: "120363232303807350@newsletter",
          },
          externalAdReply: {
              showAdAttribution: true,
              title: ownername,
              body: botname,
              thumbnailUrl: "https://i.ibb.co/y0nLDSB/XLICON-IMG.jpg",
              sourceUrl: websitex,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
}
}
break

case 'searchmenu': {
let xmenu_oh = `
â•­â”€â”€âã€Œ *GREETING* ã€â
â”œ *Hi ğŸ‘‹*
â”œ *${m.pushName}* 
â”œ *${xliconytimewisher} ğŸ˜„* 
â•°â”€â”¬â”€â”€â”€â”€â ${readmore}
â•­â”€â”´âã€Œ *GUIDE* ã€â
â”œ *ğŸ… = For Owner* 
â”œ *ğŸ…• = For Free User*
â”œ *ğŸ…Ÿ = For Premium User*
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Search* ã€â
â”‚${setv} ${prefix}google ğŸ…•
â”‚${setv} ${prefix}wikipedia ğŸ…•
â”‚${setv} ${prefix}ytsearch ğŸ…•
â”‚${setv} ${prefix}apksearch ğŸ…•
â”‚${setv} ${prefix}stickersearch ğŸ…•
â”‚${setv} ${prefix}imdb ğŸ…•
â”‚${setv} ${prefix}wanumber ğŸ…•
â”‚${setv} ${prefix}friend ğŸ…•
â”‚${setv} ${prefix}lyrics ğŸ…•
â”‚${setv} ${prefix}pixiv ğŸ…•
â•°â”€â”€â”€â”€â”€â”€â`
if (typemenu === 'v1') {
  XliconBotInc.sendMessage(m.chat, {
      image: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v2') {
  XliconBotInc.sendMessage(m.chat, {
      text: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              showAdAttribution: true,
              title: botname,
              body: ownername,
              thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
              sourceUrl: wagc,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v3') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v4') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true
  }, {
      quoted: m
  })
} else if (typemenu === 'v6') {
  XliconBotInc.relayMessage(m.chat, {
      requestPaymentMessage: {
          currencyCodeIso4217: 'USD',
          amount1000: '9999999900',
          requestFrom: m.sender,
          noteMessage: {
              extendedTextMessage: {
                  text: xmenu_oh,
                  contextInfo: {
                      externalAdReply: {
                          showAdAttribution: true
                      }
                  }
              }
          }
      }
  }, { quoted: m })
} else if (typemenu === 'v8') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      gifPlayback: true,
      caption: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              title: botname,
              body: ownername,
              thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v9') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true,
      contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          mentionedJid: [sender],
          forwardedNewsletterMessageInfo: {
              newsletterName: ownername,
              newsletterJid: "120363232303807350@newsletter",
          },
          externalAdReply: {
              showAdAttribution: true,
              title: ownername,
              body: botname,
              thumbnailUrl: "https://i.ibb.co/y0nLDSB/XLICON-IMG.jpg",
              sourceUrl: websitex,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
}
}
break

case 'downloadmenu': {
let xmenu_oh = `
â•­â”€â”€âã€Œ *GREETING* ã€â
â”œ *Hi ğŸ‘‹*
â”œ *${m.pushName}* 
â”œ *${xliconytimewisher} ğŸ˜„* 
â•°â”€â”¬â”€â”€â”€â”€â ${readmore}
â•­â”€â”´âã€Œ *GUIDE* ã€â
â”œ *ğŸ… = For Owner* 
â”œ *ğŸ…• = For Free User*
â”œ *ğŸ…Ÿ = For Premium User*
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Download* ã€â
â”‚${setv} ${prefix}itunes ğŸ…•
â”‚${setv} ${prefix}play ğŸ…•
â”‚${setv} ${prefix}ytmp3 ğŸ…•
â”‚${setv} ${prefix}ytmp4 ğŸ…•
â”‚${setv} ${prefix}yta ğŸ…•
â”‚${setv} ${prefix}ytv ğŸ…•
â”‚${setv} ${prefix}yta2 ğŸ…•
â”‚${setv} ${prefix}ytv2 ğŸ…•
â”‚${setv} ${prefix}image ğŸ…•
â”‚${setv} ${prefix}gimage ğŸ…•
â”‚${setv} ${prefix}live-wallpaper ğŸ…•
â”‚${setv} ${prefix}tiktok ğŸ…•
â”‚${setv} ${prefix}tiktokaudio ğŸ…•
â”‚${setv} ${prefix}tiktokvideo ğŸ…•
â”‚${setv} ${prefix}instagram ğŸ…•
|${setv} ${prefix}igimg ğŸ…•
â”‚${setv} ${prefix}facebook ğŸ…•
â”‚${setv} ${prefix}facebook2 ğŸ…•
â”‚${setv} ${prefix}twitter ğŸ…•
â”‚${setv} ${prefix}bilibili ğŸ…•
â”‚${setv} ${prefix}dailymotion ğŸ…•
â”‚${setv} ${prefix}apk ğŸ…•
â”‚${setv} ${prefix}modwa ğŸ…•
â”‚${setv} ${prefix}mega ğŸ…•
â”‚${setv} ${prefix}mediafire ğŸ…•
â”‚${setv} ${prefix}mediafire2 ğŸ…•
â”‚${setv} ${prefix}searchsoundcloud ğŸ…•
â”‚${setv} ${prefix}soundcloud ğŸ…•
â”‚${setv} ${prefix}google ğŸ…•
â”‚${setv} ${prefix}weather ğŸ…•
â”‚${setv} ${prefix} ğŸ…Ÿ
â”‚${setv} ${prefix}gitclone ğŸ…•
â”‚${setv} ${prefix}happymod ğŸ…•
â”‚${setv} ${prefix}gdrive ğŸ…•
â”‚${setv} ${prefix}pinterest ğŸ…•
â”‚${setv} ${prefix}ringtone ğŸ…•
â”‚${setv} ${prefix}autodownload ğŸ…
â•°â”€â”€â”€â”€â”€â”€â`
if (typemenu === 'v1') {
  XliconBotInc.sendMessage(m.chat, {
      image: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v2') {
  XliconBotInc.sendMessage(m.chat, {
      text: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              showAdAttribution: true,
              title: botname,
              body: ownername,
              thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
              sourceUrl: wagc,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v3') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v4') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true
  }, {
      quoted: m
  })
} else if (typemenu === 'v6') {
  XliconBotInc.relayMessage(m.chat, {
      requestPaymentMessage: {
          currencyCodeIso4217: 'USD',
          amount1000: '9999999900',
          requestFrom: m.sender,
          noteMessage: {
              extendedTextMessage: {
                  text: xmenu_oh,
                  contextInfo: {
                      externalAdReply: {
                          showAdAttribution: true
                      }
                  }
              }
          }
      }
  }, { quoted: m })
} else if (typemenu === 'v8') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      gifPlayback: true,
      caption: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              title: botname,
              body: ownername,
              thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v9') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true,
      contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          mentionedJid: [sender],
          forwardedNewsletterMessageInfo: {
              newsletterName: ownername,
              newsletterJid: "120363232303807350@newsletter",
          },
          externalAdReply: {
              showAdAttribution: true,
              title: ownername,
              body: botname,
              thumbnailUrl: "https://i.ibb.co/y0nLDSB/XLICON-IMG.jpg",
              sourceUrl: websitex,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
}
}
break


case 'toolmenu': {
let xmenu_oh = `
â•­â”€â”€âã€Œ *GREETING* ã€â
â”œ *Hi ğŸ‘‹*
â”œ *${m.pushName}* 
â”œ *${xliconytimewisher} ğŸ˜„* 
â•°â”€â”¬â”€â”€â”€â”€â ${readmore}
â•­â”€â”´âã€Œ *GUIDE* ã€â
â”œ *ğŸ… = For Owner* 
â”œ *ğŸ…• = For Free User*
â”œ *ğŸ…Ÿ = For Premium User*
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Tool Menu* ã€â
â”‚${setv} ${prefix}obfuscate ğŸ…•
â”‚${setv} ${prefix}styletext ğŸ…•
â”‚${setv} ${prefix}fliptext ğŸ…•
â”‚${setv} ${prefix}tts ğŸ…•
â”‚${setv} ${prefix}say ğŸ…•
â”‚${setv} ${prefix}togif ğŸ…•
â”‚${setv} ${prefix}toqr ğŸ…•
â”‚${setv} ${prefix}bass ğŸ…•
â”‚${setv} ${prefix}blown ğŸ…•
â”‚${setv} ${prefix}deep ğŸ…•
â”‚${setv} ${prefix}earrape ğŸ…•
â”‚${setv} ${prefix}fast ğŸ…•
â”‚${setv} ${prefix}fat ğŸ…•
â”‚${setv} ${prefix}nightcore ğŸ…•
â”‚${setv} ${prefix}reverse ğŸ…•
â”‚${setv} ${prefix}robot ğŸ…•
â”‚${setv} ${prefix}slow ğŸ…•
â”‚${setv} ${prefix}smooth ğŸ…•
â”‚${setv} ${prefix}squirrel ğŸ…•
â”‚${setv} ${prefix}tinyurl ğŸ…•
â”‚${setv} ${prefix}tovn ğŸ…•
â”‚${setv} ${prefix}toptv ğŸ…•
â”‚${setv} ${prefix}toaudio ğŸ…•
â”‚${setv} ${prefix}tomp3 ğŸ…•
â”‚${setv} ${prefix}tomp4ğŸ…•
â”‚${setv} ${prefix}toimg ğŸ…•
â”‚${setv} ${prefix}toonce ğŸ…•
â”‚${setv} ${prefix}toptv ğŸ…•
â”‚${setv} ${prefix}sticker ğŸ…•
â”‚${setv} ${prefix}smeme ğŸ…•
â”‚${setv} ${prefix}smeta ğŸ…•
â”‚${setv} ${prefix}take ğŸ…Ÿ
â”‚${setv} ${prefix}emojimix ğŸ…•
â”‚${setv} ${prefix}volaudio ğŸ…•
â”‚${setv} ${prefix}volvideo ğŸ…•
â”‚${setv} ${prefix}ebinary ğŸ…•
â”‚${setv} ${prefix}dbinary ğŸ…•
â”‚${setv} ${prefix}ssweb ğŸ…•
â”‚${setv} ${prefix}quoted ğŸ…•
â”‚${setv} ${prefix}translate ğŸ…•
â”‚${setv} ${prefix}get ğŸ…•
â”‚${setv} ${prefix}tourl ğŸ…•
â”‚${setv} ${prefix}write ğŸ…•
â•°â”€â”€â”€â”€â”€â”€â`
if (typemenu === 'v1') {
  XliconBotInc.sendMessage(m.chat, {
      image: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v2') {
  XliconBotInc.sendMessage(m.chat, {
      text: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              showAdAttribution: true,
              title: botname,
              body: ownername,
              thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
              sourceUrl: wagc,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v3') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v4') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true
  }, {
      quoted: m
  })
} else if (typemenu === 'v6') {
  XliconBotInc.relayMessage(m.chat, {
      requestPaymentMessage: {
          currencyCodeIso4217: 'USD',
          amount1000: '9999999900',
          requestFrom: m.sender,
          noteMessage: {
              extendedTextMessage: {
                  text: xmenu_oh,
                  contextInfo: {
                      externalAdReply: {
                          showAdAttribution: true
                      }
                  }
              }
          }
      }
  }, { quoted: m })
} else if (typemenu === 'v8') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      gifPlayback: true,
      caption: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              title: botname,
              body: ownername,
              thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v9') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true,
      contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          mentionedJid: [sender],
          forwardedNewsletterMessageInfo: {
              newsletterName: ownername,
              newsletterJid: "120363232303807350@newsletter",
          },
          externalAdReply: {
              showAdAttribution: true,
              title: ownername,
              body: botname,
              thumbnailUrl: "https://i.ibb.co/y0nLDSB/XLICON-IMG.jpg",
              sourceUrl: websitex,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
}
}
break

case 'listmenu': {
let xmenu_oh = `
â•­â”€â”€âã€Œ *GREETING* ã€â
â”œ *Hi ğŸ‘‹*
â”œ *${m.pushName}* 
â”œ *${xliconytimewisher} ğŸ˜„* 
â•°â”€â”¬â”€â”€â”€â”€â ${readmore}
â•­â”€â”´âã€Œ *GUIDE* ã€â
â”œ *ğŸ… = For Owner* 
â”œ *ğŸ…• = For Free User*
â”œ *ğŸ…Ÿ = For Premium User*
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *List Menu* ã€â
â”‚${setv} ${prefix}listprem ğŸ…•
â”‚${setv} ${prefix}listowner ğŸ…•
â”‚${setv} ${prefix}liststicker ğŸ…•
â”‚${setv} ${prefix}listimage ğŸ…•
â”‚${setv} ${prefix}listvideo ğŸ…•
â”‚${setv} ${prefix}listvn ğŸ…•
â”‚${setv} ${prefix}listapk ğŸ…•
â”‚${setv} ${prefix}listzip ğŸ…•
â”‚${setv} ${prefix}listpdf ğŸ…•
â”‚${setv} ${prefix}listbadword ğŸ…•
â”‚${setv} ${prefix}listpc ğŸ…•
â”‚${setv} ${prefix}listgc ğŸ…•
â•°â”€â”€â”€â”€â”€â”€â`
if (typemenu === 'v1') {
  XliconBotInc.sendMessage(m.chat, {
      image: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v2') {
  XliconBotInc.sendMessage(m.chat, {
      text: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              showAdAttribution: true,
              title: botname,
              body: ownername,
              thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
              sourceUrl: wagc,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v3') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v4') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true
  }, {
      quoted: m
  })
} else if (typemenu === 'v6') {
  XliconBotInc.relayMessage(m.chat, {
      requestPaymentMessage: {
          currencyCodeIso4217: 'USD',
          amount1000: '9999999900',
          requestFrom: m.sender,
          noteMessage: {
              extendedTextMessage: {
                  text: xmenu_oh,
                  contextInfo: {
                      externalAdReply: {
                          showAdAttribution: true
                      }
                  }
              }
          }
      }
  }, { quoted: m })
} else if (typemenu === 'v8') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      gifPlayback: true,
      caption: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              title: botname,
              body: ownername,
              thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v9') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true,
      contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          mentionedJid: [sender],
          forwardedNewsletterMessageInfo: {
              newsletterName: ownername,
              newsletterJid: "120363232303807350@newsletter",
          },
          externalAdReply: {
              showAdAttribution: true,
              title: ownername,
              body: botname,
              thumbnailUrl: "https://i.ibb.co/y0nLDSB/XLICON-IMG.jpg",
              sourceUrl: websitex,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
}
}
break

case 'randomphotomenu': {
let xmenu_oh = `
â•­â”€â”€âã€Œ *GREETING* ã€â
â”œ *Hi ğŸ‘‹*
â”œ *${m.pushName}* 
â”œ *${xliconytimewisher} ğŸ˜„* 
â•°â”€â”¬â”€â”€â”€â”€â ${readmore}
â•­â”€â”´âã€Œ *GUIDE* ã€â
â”œ *ğŸ… = For Owner* 
â”œ *ğŸ…• = For Free User*
â”œ *ğŸ…Ÿ = For Premium User*
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Random Photo* ã€â
â”‚${setv} ${prefix}aesthetic ğŸ…•
â”‚${setv} ${prefix}coffee ğŸ…•
â”‚${setv} ${prefix}wikimedia ğŸ…•
â”‚${setv} ${prefix}wallpaper ğŸ…•
â”‚${setv} ${prefix}art ğŸ…•
â”‚${setv} ${prefix}bts ğŸ…•
â”‚${setv} ${prefix}dogwoof ğŸ…•
â”‚${setv} ${prefix}catmeow ğŸ…•
â”‚${setv} ${prefix}lizardpic ğŸ…•
â”‚${setv} ${prefix}goosebird ğŸ…•
â”‚${setv} ${prefix}8ballpool ğŸ…•
â”‚${setv} ${prefix}cosplay ğŸ…•
â”‚${setv} ${prefix}hacker ğŸ…•
â”‚${setv} ${prefix}cyber ğŸ…•
â”‚${setv} ${prefix}gamewallpaper ğŸ…•
â”‚${setv} ${prefix}islamic ğŸ…•
â”‚${setv} ${prefix}jennie ğŸ…•
â”‚${setv} ${prefix}jiso ğŸ…•
â”‚${setv} ${prefix}satanic ğŸ…•
â”‚${setv} ${prefix}justina ğŸ…•
â”‚${setv} ${prefix}cartoon ğŸ…•
â”‚${setv} ${prefix}pentol ğŸ…•
â”‚${setv} ${prefix}cat ğŸ…•
â”‚${setv} ${prefix}kpop ğŸ…•
â”‚${setv} ${prefix}exo ğŸ…•
â”‚${setv} ${prefix}lisa ğŸ…•
â”‚${setv} ${prefix}space ğŸ…•
â”‚${setv} ${prefix}car ğŸ…•
â”‚${setv} ${prefix}technology ğŸ…•
â”‚${setv} ${prefix}bike ğŸ…•
â”‚${setv} ${prefix}shortquote ğŸ…•
â”‚${setv} ${prefix}antiwork ğŸ…•
â”‚${setv} ${prefix}hacking ğŸ…•
â”‚${setv} ${prefix}boneka ğŸ…•
â”‚${setv} ${prefix}rose ğŸ…•
â”‚${setv} ${prefix}ryujin ğŸ…•
â”‚${setv} ${prefix}ulzzangboy ğŸ…•
â”‚${setv} ${prefix}ulzzanggirl ğŸ…•
â”‚${setv} ${prefix}wallml ğŸ…•
â”‚${setv} ${prefix}wallphone ğŸ…•
â”‚${setv} ${prefix}mountain ğŸ…•
â”‚${setv} ${prefix}goose ğŸ…•
â”‚${setv} ${prefix}profilepic ğŸ…•
â”‚${setv} ${prefix}couplepp ğŸ…•
â”‚${setv} ${prefix}programming ğŸ…•
â”‚${setv} ${prefix}pubg ğŸ…•
â”‚${setv} ${prefix}blackpink ğŸ…•
â”‚${setv} ${prefix}randomboy ğŸ…•  
â”‚${setv} ${prefix}randomgirl ğŸ…•
â”‚${setv} ${prefix}hijab ğŸ…•  
â”‚${setv} ${prefix}chinese ğŸ…•
â”‚${setv} ${prefix}indo ğŸ…•
â”‚${setv} ${prefix}japanese ğŸ…•
â”‚${setv} ${prefix}korean ğŸ…•
â”‚${setv} ${prefix}malay ğŸ…•
â”‚${setv} ${prefix}thai ğŸ…•
â”‚${setv} ${prefix}vietnamese ğŸ…•
â•°â”€â”€â”€â”€â”€â”€â`
if (typemenu === 'v1') {
  XliconBotInc.sendMessage(m.chat, {
      image: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v2') {
  XliconBotInc.sendMessage(m.chat, {
      text: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              showAdAttribution: true,
              title: botname,
              body: ownername,
              thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
              sourceUrl: wagc,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v3') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v4') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true
  }, {
      quoted: m
  })
} else if (typemenu === 'v6') {
  XliconBotInc.relayMessage(m.chat, {
      requestPaymentMessage: {
          currencyCodeIso4217: 'USD',
          amount1000: '9999999900',
          requestFrom: m.sender,
          noteMessage: {
              extendedTextMessage: {
                  text: xmenu_oh,
                  contextInfo: {
                      externalAdReply: {
                          showAdAttribution: true
                      }
                  }
              }
          }
      }
  }, { quoted: m })
} else if (typemenu === 'v8') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      gifPlayback: true,
      caption: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              title: botname,
              body: ownername,
              thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v9') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true,
      contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          mentionedJid: [sender],
          forwardedNewsletterMessageInfo: {
              newsletterName: ownername,
              newsletterJid: "120363232303807350@newsletter",
          },
          externalAdReply: {
              showAdAttribution: true,
              title: ownername,
              body: botname,
              thumbnailUrl: "https://i.ibb.co/y0nLDSB/XLICON-IMG.jpg",
              sourceUrl: websitex,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
}
}
break

case 'randomvideomenu': {
let xmenu_oh = `
â•­â”€â”€âã€Œ *GREETING* ã€â
â”œ *Hi ğŸ‘‹*
â”œ *${m.pushName}* 
â”œ *${xliconytimewisher} ğŸ˜„* 
â•°â”€â”¬â”€â”€â”€â”€â ${readmore}
â•­â”€â”´âã€Œ *GUIDE* ã€â
â”œ *ğŸ… = For Owner* 
â”œ *ğŸ…• = For Free User*
â”œ *ğŸ…Ÿ = For Premium User*
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Random Video* ã€â
â”‚${setv} ${prefix}tiktokgirl ğŸ…•
â”‚${setv} ${prefix}tiktoknukthy ğŸ…•
â”‚${setv} ${prefix}tiktokkayes ğŸ…•
â”‚${setv} ${prefix}tiktokpanrika ğŸ…•
â”‚${setv} ${prefix}tiktoknotnot ğŸ…•
â”‚${setv} ${prefix}tiktokghea ğŸ…•
â”‚${setv} ${prefix}tiktoksantuy ğŸ…•
â”‚${setv} ${prefix}tiktokbocil ğŸ…•
â•°â”€â”€â”€â”€â”€â”€â`
if (typemenu === 'v1') {
  XliconBotInc.sendMessage(m.chat, {
      image: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v2') {
  XliconBotInc.sendMessage(m.chat, {
      text: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              showAdAttribution: true,
              title: botname,
              body: ownername,
              thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
              sourceUrl: wagc,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v3') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v4') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true
  }, {
      quoted: m
  })
} else if (typemenu === 'v6') {
  XliconBotInc.relayMessage(m.chat, {
      requestPaymentMessage: {
          currencyCodeIso4217: 'USD',
          amount1000: '9999999900',
          requestFrom: m.sender,
          noteMessage: {
              extendedTextMessage: {
                  text: xmenu_oh,
                  contextInfo: {
                      externalAdReply: {
                          showAdAttribution: true
                      }
                  }
              }
          }
      }
  }, { quoted: m })
} else if (typemenu === 'v8') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      gifPlayback: true,
      caption: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              title: botname,
              body: ownername,
              thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v9') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true,
      contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          mentionedJid: [sender],
          forwardedNewsletterMessageInfo: {
              newsletterName: ownername,
              newsletterJid: "120363232303807350@newsletter",
          },
          externalAdReply: {
              showAdAttribution: true,
              title: ownername,
              body: botname,
              thumbnailUrl: "https://i.ibb.co/y0nLDSB/XLICON-IMG.jpg",
              sourceUrl: websitex,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
}
}
break

case 'stalkermenu': {
let xmenu_oh = `
â•­â”€â”€âã€Œ *GREETING* ã€â
â”œ *Hi ğŸ‘‹*
â”œ *${m.pushName}* 
â”œ *${xliconytimewisher} ğŸ˜„* 
â•°â”€â”¬â”€â”€â”€â”€â ${readmore}
â•­â”€â”´âã€Œ *GUIDE* ã€â
â”œ *ğŸ… = For Owner* 
â”œ *ğŸ…• = For Free User*
â”œ *ğŸ…Ÿ = For Premium User*
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Stalker* ã€â
â”‚${setv} ${prefix}tiktokstalk ğŸ…•
â”‚${setv} ${prefix}mlstalk ğŸ…•
â”‚${setv} ${prefix}npmstalk ğŸ…•
â”‚${setv} ${prefix}ghstalk ğŸ…•
â”‚${setv} ${prefix}telestalk ğŸ…•
â”‚${setv} ${prefix}wachannelstalk ğŸ…•
â•°â”€â”€â”€â”€â”€â”€â`
if (typemenu === 'v1') {
  XliconBotInc.sendMessage(m.chat, {
      image: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v2') {
  XliconBotInc.sendMessage(m.chat, {
      text: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              showAdAttribution: true,
              title: botname,
              body: ownername,
              thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
              sourceUrl: wagc,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v3') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v4') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true
  }, {
      quoted: m
  })
} else if (typemenu === 'v6') {
  XliconBotInc.relayMessage(m.chat, {
      requestPaymentMessage: {
          currencyCodeIso4217: 'USD',
          amount1000: '9999999900',
          requestFrom: m.sender,
          noteMessage: {
              extendedTextMessage: {
                  text: xmenu_oh,
                  contextInfo: {
                      externalAdReply: {
                          showAdAttribution: true
                      }
                  }
              }
          }
      }
  }, { quoted: m })
} else if (typemenu === 'v8') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      gifPlayback: true,
      caption: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              title: botname,
              body: ownername,
              thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v9') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true,
      contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          mentionedJid: [sender],
          forwardedNewsletterMessageInfo: {
              newsletterName: ownername,
              newsletterJid: "120363232303807350@newsletter",
          },
          externalAdReply: {
              showAdAttribution: true,
              title: ownername,
              body: botname,
              thumbnailUrl: "https://i.ibb.co/y0nLDSB/XLICON-IMG.jpg",
              sourceUrl: websitex,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
}
}
break

case 'aimenu': {
let xmenu_oh = `
â•­â”€â”€âã€Œ *GREETING* ã€â
â”œ *Hi ğŸ‘‹*
â”œ *${m.pushName}* 
â”œ *${xliconytimewisher} ğŸ˜„* 
â•°â”€â”¬â”€â”€â”€â”€â ${readmore}
â•­â”€â”´âã€Œ *GUIDE* ã€â
â”œ *ğŸ… = For Owner* 
â”œ *ğŸ…• = For Free User*
â”œ *ğŸ…Ÿ = For Premium User*
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *OpenAI* ã€â
â”‚${setv} ${prefix}blackboxai ğŸ…•
â”‚${setv} ${prefix}travel-assistant ğŸ…•
â”‚${setv} ${prefix}realistic ğŸ…•
â”‚${setv} ${prefix}mangaimg ğŸ…•
â”‚${setv} ${prefix}animeimg ğŸ…•
â”‚${setv} ${prefix}lexica ğŸ…•
â”‚${setv} ${prefix}chechkgpt ğŸ…•
â”‚${setv} ${prefix}3dmodel ğŸ…•
â”‚${setv} ${prefix}photoleap ğŸ…•
â”‚${setv} ${prefix}chatgpt4 ğŸ…•
â”‚${setv} ${prefix}darky ğŸ…•
â”‚${setv} ${prefix}bing ğŸ…•
â”‚${setv} ${prefix}mathsai ğŸ…•
â”‚${setv} ${prefix}openai ğŸ…•
â”‚${setv} ${prefix}dalle ğŸ…•
â”‚${setv} ${prefix}stablediffusion ğŸ…•
â”‚${setv} ${prefix}ai ğŸ…•
â”‚${setv} ${prefix}remini ğŸ…•
â•°â”€â”€â”€â”€â”€â”€â`
if (typemenu === 'v1') {
  XliconBotInc.sendMessage(m.chat, {
      image: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v2') {
  XliconBotInc.sendMessage(m.chat, {
      text: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              showAdAttribution: true,
              title: botname,
              body: ownername,
              thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
              sourceUrl: wagc,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v3') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v4') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true
  }, {
      quoted: m
  })
} else if (typemenu === 'v6') {
  XliconBotInc.relayMessage(m.chat, {
      requestPaymentMessage: {
          currencyCodeIso4217: 'USD',
          amount1000: '9999999900',
          requestFrom: m.sender,
          noteMessage: {
              extendedTextMessage: {
                  text: xmenu_oh,
                  contextInfo: {
                      externalAdReply: {
                          showAdAttribution: true
                      }
                  }
              }
          }
      }
  }, { quoted: m })
} else if (typemenu === 'v8') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      gifPlayback: true,
      caption: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              title: botname,
              body: ownername,
              thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v9') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true,
      contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          mentionedJid: [sender],
          forwardedNewsletterMessageInfo: {
              newsletterName: ownername,
              newsletterJid: "120363232303807350@newsletter",
          },
          externalAdReply: {
              showAdAttribution: true,
              title: ownername,
              body: botname,
              thumbnailUrl: "https://i.ibb.co/y0nLDSB/XLICON-IMG.jpg",
              sourceUrl: websitex,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
}
}
break

case 'gamemenu': {
let xmenu_oh = `
â•­â”€â”€âã€Œ *GREETING* ã€â
â”œ *Hi ğŸ‘‹*
â”œ *${m.pushName}* 
â”œ *${xliconytimewisher} ğŸ˜„* 
â•°â”€â”¬â”€â”€â”€â”€â ${readmore}
â•­â”€â”´âã€Œ *GUIDE* ã€â
â”œ *ğŸ… = For Owner* 
â”œ *ğŸ…• = For Free User*
â”œ *ğŸ…Ÿ = For Premium User*
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Game* ã€â
â”‚${setv} ${prefix}truth ğŸ…•
â”‚${setv} ${prefix}dare ğŸ…•
â”‚${setv} ${prefix}suit ğŸ…•
â”‚${setv} ${prefix}tictactoe ğŸ…•
â”‚${setv} ${prefix}math ğŸ…•
â”‚${setv} ${prefix}playbomb ğŸ…•
â”‚${setv} ${prefix}casino ğŸ…•
â”‚${setv} ${prefix}rob ğŸ…•
â”‚${setv} ${prefix}slot ğŸ…•
â”‚${setv} ${prefix}dice ğŸ…• 
â”‚${setv} ${prefix} profile ğŸ…•
â”‚${setv} ${prefix} claim ğŸ…•
â”‚${setv} ${prefix} tmoney ğŸ…•
â”‚${setv} ${prefix} tflimit ğŸ…•
â•°â”€â”€â”€â”€â”€â”€â`
if (typemenu === 'v1') {
  XliconBotInc.sendMessage(m.chat, {
      image: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v2') {
  XliconBotInc.sendMessage(m.chat, {
      text: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              showAdAttribution: true,
              title: botname,
              body: ownername,
              thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
              sourceUrl: wagc,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v3') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v4') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true
  }, {
      quoted: m
  })
} else if (typemenu === 'v6') {
  XliconBotInc.relayMessage(m.chat, {
      requestPaymentMessage: {
          currencyCodeIso4217: 'USD',
          amount1000: '9999999900',
          requestFrom: m.sender,
          noteMessage: {
              extendedTextMessage: {
                  text: xmenu_oh,
                  contextInfo: {
                      externalAdReply: {
                          showAdAttribution: true
                      }
                  }
              }
          }
      }
  }, { quoted: m })
} else if (typemenu === 'v8') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      gifPlayback: true,
      caption: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              title: botname,
              body: ownername,
              thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v9') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true,
      contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          mentionedJid: [sender],
          forwardedNewsletterMessageInfo: {
              newsletterName: ownername,
              newsletterJid: "120363232303807350@newsletter",
          },
          externalAdReply: {
              showAdAttribution: true,
              title: ownername,
              body: botname,
              thumbnailUrl: "https://i.ibb.co/y0nLDSB/XLICON-IMG.jpg",
              sourceUrl: websitex,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
}
}
break


case 'funmenu': {
let xmenu_oh = `
â•­â”€â”€âã€Œ *GREETING* ã€â
â”œ *Hi ğŸ‘‹*
â”œ *${m.pushName}* 
â”œ *${xliconytimewisher} ğŸ˜„* 
â•°â”€â”¬â”€â”€â”€â”€â ${readmore}
â•­â”€â”´âã€Œ *GUIDE* ã€â
â”œ *ğŸ… = For Owner* 
â”œ *ğŸ…• = For Free User*
â”œ *ğŸ…Ÿ = For Premium User*
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Fun* ã€â
â”‚${setv} ${prefix}define ğŸ…•
â”‚${setv} ${prefix}readmore ğŸ…•
â”‚${setv} ${prefix}yomamajoke ğŸ…•
â”‚${setv} ${prefix}fact ğŸ…•
â”‚${setv} ${prefix}couple ğŸ…•
â”‚${setv} ${prefix}soulmate ğŸ…•
â”‚${setv} ${prefix}stupidcheck ğŸ…•
â”‚${setv} ${prefix}handsomecheck ğŸ…•
â”‚${setv} ${prefix}uncleancheck ğŸ…•
â”‚${setv} ${prefix}hotcheck ğŸ…•
â”‚${setv} ${prefix}smartcheck ğŸ…•
â”‚${setv} ${prefix}greatcheck ğŸ…•
â”‚${setv} ${prefix}evilcheck ğŸ…•
â”‚${setv} ${prefix}dogcheck ğŸ…•
â”‚${setv} ${prefix}coolcheck ğŸ…•
â”‚${setv} ${prefix}waifucheck ğŸ…•
â”‚${setv} ${prefix}awesomecheck ğŸ…•
â”‚${setv} ${prefix}gaycheck ğŸ…•
â”‚${setv} ${prefix}cutecheck ğŸ…•
â”‚${setv} ${prefix}lesbiancheck ğŸ…•
â”‚${setv} ${prefix}hornycheck ğŸ…•
â”‚${setv} ${prefix}prettycheck ğŸ…•
â”‚${setv} ${prefix}lovelycheck ğŸ…•
â”‚${setv} ${prefix}uglycheck ğŸ…•
â”‚${setv} ${prefix}pick ğŸ…•
â”‚${setv} ${prefix}pickupline ğŸ…•
â”‚${setv} ${prefix}quotes ğŸ…•
â”‚${setv} ${prefix}can ğŸ…•
â”‚${setv} ${prefix}is ğŸ…•
â”‚${setv} ${prefix}when ğŸ…•
â”‚${setv} ${prefix}where ğŸ…•
â”‚${setv} ${prefix}what ğŸ…•
â”‚${setv} ${prefix}how ğŸ…•
â”‚${setv} ${prefix}rate ğŸ…•
â”‚${setv} ${prefix}cry ğŸ…•
â”‚${setv} ${prefix}kill ğŸ…•
â”‚${setv} ${prefix}hug ğŸ…•
â”‚${setv} ${prefix}pat ğŸ…•
â”‚${setv} ${prefix}lick ğŸ…• 
â”‚${setv} ${prefix}kiss ğŸ…•
â”‚${setv} ${prefix}bite ğŸ…•
â”‚${setv} ${prefix}yeet ğŸ…•
â”‚${setv} ${prefix}bully ğŸ…•
â”‚${setv} ${prefix}bonk ğŸ…•
â”‚${setv} ${prefix}wink ğŸ…•
â”‚${setv} ${prefix}poke ğŸ…•
â”‚${setv} ${prefix}nom ğŸ…•
â”‚${setv} ${prefix}slap ğŸ…•
â”‚${setv} ${prefix}smile ğŸ…• 
â”‚${setv} ${prefix}wave ğŸ…•
â”‚${setv} ${prefix}awoo ğŸ…•
â”‚${setv} ${prefix}blush ğŸ…•
â”‚${setv} ${prefix}smug ğŸ…•
â”‚${setv} ${prefix}glomp ğŸ…• 
â”‚${setv} ${prefix}happy ğŸ…•
â”‚${setv} ${prefix}dance ğŸ…•
â”‚${setv} ${prefix}cringe ğŸ…•
â”‚${setv} ${prefix}cuddle ğŸ…•
â”‚${setv} ${prefix}highfive ğŸ…• 
â”‚${setv} ${prefix}handhold ğŸ…•
â”‚${setv} ${prefix}spank ğŸ…•
â”‚${setv} ${prefix}tickle ğŸ…•
â”‚${setv} ${prefix}feed ğŸ…•
â”‚${setv} ${prefix}checkme ğŸ…•
â”‚${setv} ${prefix}sound1 - sound161 ğŸ…•
â•°â”€â”€â”€â”€â”€â”€â`
if (typemenu === 'v1') {
  XliconBotInc.sendMessage(m.chat, {
      image: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v2') {
  XliconBotInc.sendMessage(m.chat, {
      text: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              showAdAttribution: true,
              title: botname,
              body: ownername,
              thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
              sourceUrl: wagc,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v3') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v4') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true
  }, {
      quoted: m
  })
} else if (typemenu === 'v6') {
  XliconBotInc.relayMessage(m.chat, {
      requestPaymentMessage: {
          currencyCodeIso4217: 'USD',
          amount1000: '9999999900',
          requestFrom: m.sender,
          noteMessage: {
              extendedTextMessage: {
                  text: xmenu_oh,
                  contextInfo: {
                      externalAdReply: {
                          showAdAttribution: true
                      }
                  }
              }
          }
      }
  }, { quoted: m })
} else if (typemenu === 'v8') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      gifPlayback: true,
      caption: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              title: botname,
              body: ownername,
              thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v9') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true,
      contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          mentionedJid: [sender],
          forwardedNewsletterMessageInfo: {
              newsletterName: ownername,
              newsletterJid: "120363232303807350@newsletter",
          },
          externalAdReply: {
              showAdAttribution: true,
              title: ownername,
              body: botname,
              thumbnailUrl: "https://i.ibb.co/y0nLDSB/XLICON-IMG.jpg",
              sourceUrl: websitex,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
}
}
break

case 'stickermenu': {
let xmenu_oh = `
â•­â”€â”€âã€Œ *GREETING* ã€â
â”œ *Hi ğŸ‘‹*
â”œ *${m.pushName}* 
â”œ *${xliconytimewisher} ğŸ˜„* 
â•°â”€â”¬â”€â”€â”€â”€â ${readmore}
â•­â”€â”´âã€Œ *GUIDE* ã€â
â”œ *ğŸ… = For Owner* 
â”œ *ğŸ…• = For Free User*
â”œ *ğŸ…Ÿ = For Premium User*
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Sticker* ã€â
â”‚${setv} ${prefix}goose ğŸ…•
â”‚${setv} ${prefix}woof ğŸ…•
â”‚${setv} ${prefix}8ball ğŸ…•
â”‚${setv} ${prefix}lizard ğŸ…•
â”‚${setv} ${prefix}meow ğŸ…•
â”‚${setv} ${prefix}gura ğŸ…•
â”‚${setv} ${prefix}telestick ğŸ…•
â•°â”€â”€â”€â”€â”€â”€â`
if (typemenu === 'v1') {
  XliconBotInc.sendMessage(m.chat, {
      image: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v2') {
  XliconBotInc.sendMessage(m.chat, {
      text: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              showAdAttribution: true,
              title: botname,
              body: ownername,
              thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
              sourceUrl: wagc,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v3') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v4') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true
  }, {
      quoted: m
  })
} else if (typemenu === 'v6') {
  XliconBotInc.relayMessage(m.chat, {
      requestPaymentMessage: {
          currencyCodeIso4217: 'USD',
          amount1000: '9999999900',
          requestFrom: m.sender,
          noteMessage: {
              extendedTextMessage: {
                  text: xmenu_oh,
                  contextInfo: {
                      externalAdReply: {
                          showAdAttribution: true
                      }
                  }
              }
          }
      }
  }, { quoted: m })
} else if (typemenu === 'v8') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      gifPlayback: true,
      caption: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              title: botname,
              body: ownername,
              thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v9') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true,
      contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          mentionedJid: [sender],
          forwardedNewsletterMessageInfo: {
              newsletterName: ownername,
              newsletterJid: "120363232303807350@newsletter",
          },
          externalAdReply: {
              showAdAttribution: true,
              title: ownername,
              body: botname,
              thumbnailUrl: "https://i.ibb.co/y0nLDSB/XLICON-IMG.jpg",
              sourceUrl: websitex,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
}
}
break

case 'animemenu': {
let xmenu_oh = `
â•­â”€â”€âã€Œ *GREETING* ã€â
â”œ *Hi ğŸ‘‹*
â”œ *${m.pushName}* 
â”œ *${xliconytimewisher} ğŸ˜„* 
â•°â”€â”¬â”€â”€â”€â”€â ${readmore}
â•­â”€â”´âã€Œ *GUIDE* ã€â
â”œ *ğŸ… = For Owner* 
â”œ *ğŸ…• = For Free User*
â”œ *ğŸ…Ÿ = For Premium User*
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Anime* ã€â
â”‚${setv} ${prefix}searchanime ğŸ…•
â”‚${setv} ${prefix}animeinfo ğŸ…•
â”‚${setv} ${prefix}animeid ğŸ…•
â”‚${setv} ${prefix}animedl ğŸ…•
â”‚${setv} ${prefix}mangainfo ğŸ…•
â”‚${setv} ${prefix}searchchapter ğŸ…•
â”‚â”‚${setv} ${prefix}mangachapter ğŸ…•
â”‚â”‚${setv} ${prefix}randommanga ğŸ…•
â”‚${setv} ${prefix}amv ğŸ…•
â”‚${setv} ${prefix}stickhandhold ğŸ…•
â”‚${setv} ${prefix}stickshinobu ğŸ…•
â”‚${setv} ${prefix}stickcuddle ğŸ…•
â”‚${setv} ${prefix}stickhighfive ğŸ…•
â”‚${setv} ${prefix}stickdance ğŸ…•
â”‚${setv} ${prefix}stickcringe ğŸ…•
â”‚${setv} ${prefix}stickhappy ğŸ…•
â”‚${setv} ${prefix}stickglomp ğŸ…•
â”‚${setv} ${prefix}sticksmug ğŸ…•
â”‚${setv} ${prefix}stickblush ğŸ…•
â”‚${setv} ${prefix}stickawoo ğŸ…•
â”‚${setv} ${prefix}stickwave ğŸ…•
â”‚${setv} ${prefix}sticksmile ğŸ…•
â”‚${setv} ${prefix}stickslap ğŸ…•
â”‚${setv} ${prefix}stickpoke ğŸ…•
â”‚${setv} ${prefix}stickwink ğŸ…•
â”‚${setv} ${prefix}stickbonk ğŸ…•
â”‚${setv} ${prefix}stickbully ğŸ…•
â”‚${setv} ${prefix}stickyeet ğŸ…•
â”‚${setv} ${prefix}stickbike ğŸ…•
â”‚${setv} ${prefix}stickkiss ğŸ…•
â”‚${setv} ${prefix}sticklick ğŸ…•
â”‚${setv} ${prefix}stickpat ğŸ…•
â”‚${setv} ${prefix}stickhug ğŸ…•
â”‚${setv} ${prefix}stickkill ğŸ…•
â”‚${setv} ${prefix}stickcry ğŸ…•
â”‚${setv} ${prefix}stickspank ğŸ…•
â”‚${setv} ${prefix}sticktickle ğŸ…•
â”‚${setv} ${prefix}traceanime ğŸ…•
â”‚${setv} ${prefix}akira ğŸ…•
â”‚${setv} ${prefix}akiyama ğŸ…•
â”‚${setv} ${prefix}ana ğŸ…•
â”‚${setv} ${prefix}asuna ğŸ…•
â”‚${setv} ${prefix}ayuzawa ğŸ…•
â”‚${setv} ${prefix}boruto ğŸ…•
â”‚${setv} ${prefix}chiho ğŸ…•
â”‚${setv} ${prefix}chitoge ğŸ…•
â”‚${setv} ${prefix}cosplayloli ğŸ…•
â”‚${setv} ${prefix}cosplaysagiri ğŸ…•
â”‚${setv} ${prefix}deidara ğŸ…•
â”‚${setv} ${prefix}doraemon ğŸ…•
â”‚${setv} ${prefix}elaina ğŸ…•
â”‚${setv} ${prefix}emilia ğŸ…•
â”‚${setv} ${prefix}erza ğŸ…•
â”‚${setv} ${prefix}gremory ğŸ…•
â”‚${setv} ${prefix}hestia ğŸ…•
â”‚${setv} ${prefix}husbu ğŸ…•
â”‚${setv} ${prefix}inori ğŸ…•
â”‚${setv} ${prefix}isuzu ğŸ…•
â”‚${setv} ${prefix}itachi ğŸ…•
â”‚${setv} ${prefix}itori ğŸ…•
â”‚${setv} ${prefix}kaga ğŸ…•
â”‚${setv} ${prefix}kagura ğŸ…•
â”‚${setv} ${prefix}kakasih ğŸ…•
â”‚${setv} ${prefix}kaori ğŸ…•
â”‚${setv} ${prefix}keneki ğŸ…•
â”‚${setv} ${prefix}kotori ğŸ…•
â”‚${setv} ${prefix}kurumi ğŸ…•
â”‚${setv} ${prefix}loli ğŸ…•
â”‚${setv} ${prefix}loli2 ğŸ…•
â”‚${setv} ${prefix}madara ğŸ…•
â”‚${setv} ${prefix}megumin ğŸ…•
â”‚${setv} ${prefix}mikasa ğŸ…•
â”‚${setv} ${prefix}mikey ğŸ…•
â”‚${setv} ${prefix}miku ğŸ…•
â”‚${setv} ${prefix}minato ğŸ…•
â”‚${setv} ${prefix}naruto ğŸ…•
â”‚${setv} ${prefix}neko ğŸ…•
â”‚${setv} ${prefix}nekonime ğŸ…•
â”‚${setv} ${prefix}nezuko ğŸ…•
â”‚${setv} ${prefix}onepiece ğŸ…•
â”‚${setv} ${prefix}pokemon ğŸ…•
â”‚${setv} ${prefix}randomnime ğŸ…•
â”‚${setv} ${prefix}randomnime2 ğŸ…•
â”‚${setv} ${prefix}rize ğŸ…•
â”‚${setv} ${prefix}sagiri ğŸ…•
â”‚${setv} ${prefix}sakura ğŸ…•
â”‚${setv} ${prefix}sasuke ğŸ…•
â”‚${setv} ${prefix}shina ğŸ…•
â”‚${setv} ${prefix}shinka ğŸ…•
â”‚${setv} ${prefix}shinomiya ğŸ…•
â”‚${setv} ${prefix}shizuka ğŸ…•
â”‚${setv} ${prefix}shota ğŸ…•
â”‚${setv} ${prefix}tejina ğŸ…•
â”‚${setv} ${prefix}toukachan ğŸ…•
â”‚${setv} ${prefix}tsunade ğŸ…•
â”‚${setv} ${prefix}waifu ğŸ…•
â”‚${setv} ${prefix}waifu2 ğŸ…•
â”‚${setv} ${prefix}animewall ğŸ…•
â”‚${setv} ${prefix}yotsuba ğŸ…•
â”‚${setv} ${prefix}yuki ğŸ…•
â”‚${setv} ${prefix}yulibocil ğŸ…•
â”‚${setv} ${prefix}yumeko ğŸ…•
â”‚${setv} ${prefix}8ball ğŸ…•
â”‚${setv} ${prefix}animeawoo ğŸ…•
â”‚${setv} ${prefix}animemegumin ğŸ…•
â”‚${setv} ${prefix}animeshinobu ğŸ…•
â”‚${setv} ${prefix}animehandhold ğŸ…•
â”‚${setv} ${prefix}animehighfive ğŸ…•
â”‚${setv} ${prefix}animecringe ğŸ…•
â”‚${setv} ${prefix}animedance ğŸ…•
â”‚${setv} ${prefix}animehappy ğŸ…•
â”‚${setv} ${prefix}animeglomp ğŸ…•
â”‚${setv} ${prefix}animeblush ğŸ…•
â”‚${setv} ${prefix}animesmug ğŸ…•
â”‚${setv} ${prefix}animewave ğŸ…•
â”‚${setv} ${prefix}animesmille ğŸ…•
â”‚${setv} ${prefix}animepoke ğŸ…•
â”‚${setv} ${prefix}animewink ğŸ…•
â”‚${setv} ${prefix}animebonk ğŸ…•
â”‚${setv} ${prefix}animebully ğŸ…•
â”‚${setv} ${prefix}animeyeet ğŸ…•
â”‚${setv} ${prefix}animebite ğŸ…•
â”‚${setv} ${prefix}animelick ğŸ…•
â”‚${setv} ${prefix}animekill ğŸ…•
â”‚${setv} ${prefix}animecry ğŸ…•
â”‚${setv} ${prefix}animewlp ğŸ…•
â”‚${setv} ${prefix}animekiss ğŸ…•
â”‚${setv} ${prefix}animehug ğŸ…•
â”‚${setv} ${prefix}animeneko ğŸ…•
â”‚${setv} ${prefix}animepat ğŸ…•
â”‚${setv} ${prefix}animeslap ğŸ…•
â”‚${setv} ${prefix}animecuddle ğŸ…•
â”‚${setv} ${prefix}animewaifu ğŸ…•
â”‚${setv} ${prefix}animenom ğŸ…•
â”‚${setv} ${prefix}animefoxgirl ğŸ…•
â”‚${setv} ${prefix}animegecg ğŸ…•
â”‚${setv} ${prefix}animetickle ğŸ…•
â”‚${setv} ${prefix}animefeed ğŸ…•
â”‚${setv} ${prefix}animeavatar ğŸ…•
â”‚${setv} ${prefix}anime ğŸ…•
â”‚${setv} ${prefix}avatar ğŸ…•
â”‚${setv} ${prefix}shinobu ğŸ…•
â”‚${setv} ${prefix}fox_girl ğŸ…•
â”‚${setv} ${prefix}gecg ğŸ…•
â•°â”€â”€â”€â”€â”€â”€â`
if (typemenu === 'v1') {
  XliconBotInc.sendMessage(m.chat, {
      image: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v2') {
  XliconBotInc.sendMessage(m.chat, {
      text: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              showAdAttribution: true,
              title: botname,
              body: ownername,
              thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
              sourceUrl: wagc,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v3') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v4') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true
  }, {
      quoted: m
  })
} else if (typemenu === 'v6') {
  XliconBotInc.relayMessage(m.chat, {
      requestPaymentMessage: {
          currencyCodeIso4217: 'USD',
          amount1000: '9999999900',
          requestFrom: m.sender,
          noteMessage: {
              extendedTextMessage: {
                  text: xmenu_oh,
                  contextInfo: {
                      externalAdReply: {
                          showAdAttribution: true
                      }
                  }
              }
          }
      }
  }, { quoted: m })
} else if (typemenu === 'v8') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      gifPlayback: true,
      caption: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              title: botname,
              body: ownername,
              thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v9') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true,
      contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          mentionedJid: [sender],
          forwardedNewsletterMessageInfo: {
              newsletterName: ownername,
              newsletterJid: "120363232303807350@newsletter",
          },
          externalAdReply: {
              showAdAttribution: true,
              title: ownername,
              body: botname,
              thumbnailUrl: "https://i.ibb.co/y0nLDSB/XLICON-IMG.jpg",
              sourceUrl: websitex,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
}
}
break


case 'nsfwmenu': {
let xmenu_oh = `
â•­â”€â”€âã€Œ *GREETING* ã€â
â”œ *Hi ğŸ‘‹*
â”œ *${m.pushName}* 
â”œ *${xliconytimewisher} ğŸ˜„* 
â•°â”€â”¬â”€â”€â”€â”€â ${readmore}
â•­â”€â”´âã€Œ *GUIDE* ã€â
â”œ *ğŸ… = For Owner* 
â”œ *ğŸ…• = For Free User*
â”œ *ğŸ…Ÿ = For Premium User*
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Anime NSFW* ã€â
â”‚${setv} ${prefix}hentai ğŸ…•
â”‚${setv} ${prefix}xnxxsearch ğŸ…•
â”‚${setv} ${prefix}xvideosearch ğŸ…•
â”‚${setv} ${prefix}xnxxdl ğŸ…•
â”‚${setv} ${prefix}xvideodl ğŸ…•
â”‚${setv} ${prefix}gifblowjob ğŸ…•
â”‚${setv} ${prefix}hentaivid ğŸ…•
â”‚${setv} ${prefix}hneko ğŸ…•
â”‚${setv} ${prefix}nwaifu ğŸ…•
â”‚${setv} ${prefix}animespank ğŸ…•
â”‚${setv} ${prefix}trap ğŸ…•
â”‚${setv} ${prefix}blowjob ğŸ…•
â”‚${setv} ${prefix}cuckold ğŸ…•
â”‚${setv} ${prefix}milf ğŸ…•
â”‚${setv} ${prefix}eba ğŸ…•
â”‚${setv} ${prefix}pussy ğŸ…•
â”‚${setv} ${prefix}yuri ğŸ…•
â”‚${setv} ${prefix}zettai ğŸ…•
â•°â”€â”€â”€â”€â”€â”€â`
if (typemenu === 'v1') {
  XliconBotInc.sendMessage(m.chat, {
      image: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v2') {
  XliconBotInc.sendMessage(m.chat, {
      text: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              showAdAttribution: true,
              title: botname,
              body: ownername,
              thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
              sourceUrl: wagc,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v3') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v4') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true
  }, {
      quoted: m
  })
} else if (typemenu === 'v6') {
  XliconBotInc.relayMessage(m.chat, {
      requestPaymentMessage: {
          currencyCodeIso4217: 'USD',
          amount1000: '9999999900',
          requestFrom: m.sender,
          noteMessage: {
              extendedTextMessage: {
                  text: xmenu_oh,
                  contextInfo: {
                      externalAdReply: {
                          showAdAttribution: true
                      }
                  }
              }
          }
      }
  }, { quoted: m })
} else if (typemenu === 'v8') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      gifPlayback: true,
      caption: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              title: botname,
              body: ownername,
              thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v9') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true,
      contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          mentionedJid: [sender],
          forwardedNewsletterMessageInfo: {
              newsletterName: ownername,
              newsletterJid: "120363232303807350@newsletter",
          },
          externalAdReply: {
              showAdAttribution: true,
              title: ownername,
              body: botname,
              thumbnailUrl: "https://i.ibb.co/y0nLDSB/XLICON-IMG.jpg",
              sourceUrl: websitex,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
}
}
break


case 'databasemenu': {
let xmenu_oh = `
â•­â”€â”€âã€Œ *GREETING* ã€â
â”œ *Hi ğŸ‘‹*
â”œ *${m.pushName}* 
â”œ *${xliconytimewisher} ğŸ˜„* 
â•°â”€â”¬â”€â”€â”€â”€â ${readmore}
â•­â”€â”´âã€Œ *GUIDE* ã€â
â”œ *ğŸ… = For Owner* 
â”œ *ğŸ…• = For Free User*
â”œ *ğŸ…Ÿ = For Premium User*
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Database* ã€â
â”‚${setv} ${prefix}setcmd ğŸ…
â”‚${setv} ${prefix}delcmd ğŸ…
â”‚${setv} ${prefix}listcmd ğŸ…•
â”‚${setv} ${prefix}lockcmd ğŸ…
â”‚${setv} ${prefix}addmsg ğŸ…
â”‚${setv} ${prefix}delmsg ğŸ…
â”‚${setv} ${prefix}getmsg ğŸ…•
â”‚${setv} ${prefix}listmsg ğŸ…•
â•°â”€â”€â”€â”€â”€â”€â`
if (typemenu === 'v1') {
  XliconBotInc.sendMessage(m.chat, {
      image: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v2') {
  XliconBotInc.sendMessage(m.chat, {
      text: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              showAdAttribution: true,
              title: botname,
              body: ownername,
              thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
              sourceUrl: wagc,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v3') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v4') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true
  }, {
      quoted: m
  })
} else if (typemenu === 'v6') {
  XliconBotInc.relayMessage(m.chat, {
      requestPaymentMessage: {
          currencyCodeIso4217: 'USD',
          amount1000: '9999999900',
          requestFrom: m.sender,
          noteMessage: {
              extendedTextMessage: {
                  text: xmenu_oh,
                  contextInfo: {
                      externalAdReply: {
                          showAdAttribution: true
                      }
                  }
              }
          }
      }
  }, { quoted: m })
} else if (typemenu === 'v8') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      gifPlayback: true,
      caption: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              title: botname,
              body: ownername,
              thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v9') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true,
      contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          mentionedJid: [sender],
          forwardedNewsletterMessageInfo: {
              newsletterName: ownername,
              newsletterJid: "120363232303807350@newsletter",
          },
          externalAdReply: {
              showAdAttribution: true,
              title: ownername,
              body: botname,
              thumbnailUrl: "https://i.ibb.co/y0nLDSB/XLICON-IMG.jpg",
              sourceUrl: websitex,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
}
}
break

case 'storemenu': {
let xmenu_oh = `
â•­â”€â”€âã€Œ *GREETING* ã€â
â”œ *Hi ğŸ‘‹*
â”œ *${m.pushName}* 
â”œ *${xliconytimewisher} ğŸ˜„* 
â•°â”€â”¬â”€â”€â”€â”€â ${readmore}
â•­â”€â”´âã€Œ *GUIDE* ã€â
â”œ *ğŸ… = For Owner* 
â”œ *ğŸ…• = For Free User*
â”œ *ğŸ…Ÿ = For Premium User*
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Store* ã€â
â”‚${setv} ${prefix}list ğŸ…•
â”‚${setv} ${prefix}store ğŸ…•
â”‚${setv} ${prefix}shop ğŸ…•
â”‚${setv} ${prefix}addlist ğŸ…
â”‚${setv} ${prefix}dellist ğŸ…
â•°â”€â”€â”€â”€â”€â”€â`
if (typemenu === 'v1') {
  XliconBotInc.sendMessage(m.chat, {
      image: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v2') {
  XliconBotInc.sendMessage(m.chat, {
      text: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              showAdAttribution: true,
              title: botname,
              body: ownername,
              thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
              sourceUrl: wagc,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v3') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v4') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true
  }, {
      quoted: m
  })
} else if (typemenu === 'v6') {
  XliconBotInc.relayMessage(m.chat, {
      requestPaymentMessage: {
          currencyCodeIso4217: 'USD',
          amount1000: '9999999900',
          requestFrom: m.sender,
          noteMessage: {
              extendedTextMessage: {
                  text: xmenu_oh,
                  contextInfo: {
                      externalAdReply: {
                          showAdAttribution: true
                      }
                  }
              }
          }
      }
  }, { quoted: m })
} else if (typemenu === 'v8') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      gifPlayback: true,
      caption: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              title: botname,
              body: ownername,
              thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v9') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true,
      contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          mentionedJid: [sender],
          forwardedNewsletterMessageInfo: {
              newsletterName: ownername,
              newsletterJid: "120363232303807350@newsletter",
          },
          externalAdReply: {
              showAdAttribution: true,
              title: ownername,
              body: botname,
              thumbnailUrl: "https://i.ibb.co/y0nLDSB/XLICON-IMG.jpg",
              sourceUrl: websitex,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
}
}
break


case 'religionmenu': {
let xmenu_oh = `
â•­â”€â”€âã€Œ *GREETING* ã€â
â”œ *Hi ğŸ‘‹*
â”œ *${m.pushName}* 
â”œ *${xliconytimewisher} ğŸ˜„* 
â•°â”€â”¬â”€â”€â”€â”€â ${readmore}
â•­â”€â”´âã€Œ *GUIDE* ã€â
â”œ *ğŸ… = For Owner* 
â”œ *ğŸ…• = For Free User*
â”œ *ğŸ…Ÿ = For Premium User*
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Religon* ã€â
â”‚${setv} ${prefix}bible ğŸ…•
â”‚${setv} ${prefix}quran ğŸ…•
â”‚${setv} ${prefix}gita ğŸ…•
â”‚${setv} ${prefix}namazchk ğŸ…•
â”‚${setv} ${prefix}prophetname ğŸ…•
â”‚${setv} ${prefix}prayertime ğŸ…•
â”‚${setv} ${prefix}sahihbukhari ğŸ…•
â”‚${setv} ${prefix}jamiattirmidhi ğŸ…•
â”‚${setv} ${prefix}sunanannasai ğŸ…•
â”‚${setv} ${prefix}sunanibnmajah ğŸ…•
â”‚${setv} ${prefix}sunanabudawud ğŸ…•
â”‚${setv} ${prefix}kisahnabi ğŸ…•
â”‚${setv} ${prefix}asmaulhusna ğŸ…•
â”‚${setv} ${prefix}duas ğŸ…•
â”‚${setv} ${prefix}namaz ğŸ…•
â”‚${setv} ${prefix}masnoonduas ğŸ…•
â”‚${setv} ${prefix}ayatalkursi ğŸ…•
â”‚${setv} ${prefix}niyatnamaz ğŸ…•
â”‚${setv} ${prefix}quotesislami ğŸ…•
â”‚${setv} ${prefix}assalamualaikum ğŸ…•
â•°â”€â”€â”€â”€â”€â”€â`
if (typemenu === 'v1') {
  XliconBotInc.sendMessage(m.chat, {
      image: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v2') {
  XliconBotInc.sendMessage(m.chat, {
      text: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              showAdAttribution: true,
              title: botname,
              body: ownername,
              thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
              sourceUrl: wagc,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v3') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v4') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true
  }, {
      quoted: m
  })
} else if (typemenu === 'v6') {
  XliconBotInc.relayMessage(m.chat, {
      requestPaymentMessage: {
          currencyCodeIso4217: 'USD',
          amount1000: '9999999900',
          requestFrom: m.sender,
          noteMessage: {
              extendedTextMessage: {
                  text: xmenu_oh,
                  contextInfo: {
                      externalAdReply: {
                          showAdAttribution: true
                      }
                  }
              }
          }
      }
  }, { quoted: m })
} else if (typemenu === 'v8') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      gifPlayback: true,
      caption: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              title: botname,
              body: ownername,
              thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v9') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true,
      contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          mentionedJid: [sender],
          forwardedNewsletterMessageInfo: {
              newsletterName: ownername,
              newsletterJid: "120363232303807350@newsletter",
          },
          externalAdReply: {
              showAdAttribution: true,
              title: ownername,
              body: botname,
              thumbnailUrl: "https://i.ibb.co/y0nLDSB/XLICON-IMG.jpg",
              sourceUrl: websitex,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
}
}
break



case 'othermenu': {
let xmenu_oh = `
â•­â”€â”€âã€Œ *GREETING* ã€â
â”œ *Hi ğŸ‘‹*
â”œ *${m.pushName}* 
â”œ *${xliconytimewisher} ğŸ˜„* 
â•°â”€â”¬â”€â”€â”€â”€â ${readmore}
â•­â”€â”´âã€Œ *GUIDE* ã€â
â”œ *ğŸ… = For Owner* 
â”œ *ğŸ…• = For Free User*
â”œ *ğŸ…Ÿ = For Premium User*
â•°â”€â”¬â”€â”€â”€â”€â
â•­â”€â”´âã€Œ *Other* ã€â
â”‚${setv} ${prefix}update ğŸ…•
â”‚${setv} ${prefix}cricket ğŸ…•
â”‚${setv} ${prefix}score ğŸ…•
â”‚${setv} ${prefix}ping ğŸ…•
â”‚${setv} ${prefix}menu ğŸ…•
â”‚${setv} ${prefix}myip ğŸ…•
â”‚${setv} ${prefix}repo ğŸ…•
â”‚${setv} ${prefix}reportbug ğŸ…•
â”‚${setv} ${prefix}idgroup ğŸ…•
â”‚${setv} ${prefix}owner ğŸ…•
â”‚${setv} ${prefix}rentbot ğŸ…•
â”‚${setv} ${prefix}donate ğŸ…•
â”‚${setv} ${prefix}runtime ğŸ…•
â”‚${setv} ${prefix}confess ğŸ…•
â”‚${setv} ${prefix}react ğŸ…•
â”‚${setv} ${prefix}q ğŸ…•
â”‚${setv} ${prefix}inspect ğŸ…•
â”‚${setv} ${prefix}tagme ğŸ…•
â”‚${setv} ${prefix}nowa ğŸ…•
â”‚${setv} ${prefix}truecaller ğŸ…•
â•°â”€â”€â”€â”€â”€â”€â`
if (typemenu === 'v1') {
  XliconBotInc.sendMessage(m.chat, {
      image: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v2') {
  XliconBotInc.sendMessage(m.chat, {
      text: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              showAdAttribution: true,
              title: botname,
              body: ownername,
              thumbnail: fs.readFileSync('./XliconMedia/theme/XliconPic.jpg'),
              sourceUrl: wagc,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v3') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh
  }, {
      quoted: m
  })
} else if (typemenu === 'v4') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true
  }, {
      quoted: m
  })
} else if (typemenu === 'v6') {
  XliconBotInc.relayMessage(m.chat, {
      requestPaymentMessage: {
          currencyCodeIso4217: 'USD',
          amount1000: '9999999900',
          requestFrom: m.sender,
          noteMessage: {
              extendedTextMessage: {
                  text: xmenu_oh,
                  contextInfo: {
                      externalAdReply: {
                          showAdAttribution: true
                      }
                  }
              }
          }
      }
  }, { quoted: m })
} else if (typemenu === 'v8') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      gifPlayback: true,
      caption: xmenu_oh,
      contextInfo: {
          externalAdReply: {
              title: botname,
              body: ownername,
              thumbnailUrl: 'https://i.ibb.co/yhgtCXh/68747470733a2f2f69696c692e696f2f64455433756b582e6d642e706e67.png',
              sourceUrl: ``,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
} else if (typemenu === 'v9') {
  XliconBotInc.sendMessage(m.chat, {
      video: fs.readFileSync('./XliconMedia/theme/Xlicon-Video.mp4'),
      caption: xmenu_oh,
      gifPlayback: true,
      contextInfo: {
          forwardingScore: 999,
          isForwarded: true,
          mentionedJid: [sender],
          forwardedNewsletterMessageInfo: {
              newsletterName: ownername,
              newsletterJid: "120363232303807350@newsletter",
          },
          externalAdReply: {
              showAdAttribution: true,
              title: ownername,
              body: botname,
              thumbnailUrl: "https://i.ibb.co/y0nLDSB/XLICON-IMG.jpg",
              sourceUrl: websitex,
              mediaType: 1,
              renderLargerThumbnail: true
          }
      }
  }, {
      quoted: m
  })
}
}
break
//ALL MENUS CODE END AT HERE


default:
  if (budy.startsWith('>')) {
    if (!XliconTheCreator) return; // Ensure only the bot creator can run this command
    const codeToEvaluate = budy.slice(2).trim(); // Slice and trim the code after the '>' symbol
    if (!codeToEvaluate) return m.reply("âŒ No code provided for evaluation.");
  
    try {
      let evaled = await eval(codeToEvaluate); // Evaluate the code synchronously
      if (typeof evaled !== 'string') evaled = require('util').inspect(evaled); // Ensure the result is a string
      await m.reply(evaled); // Send the evaluation result back
    } catch (err) {
      console.error(err); // Log the error for debugging
      await m.reply(`âŒ Error in evaluation: ${String(err)}`); // Return the error message to the user
    }
  }
  
  if (budy.startsWith('=>')) {
    if (!XliconTheCreator) return; // Ensure only the bot creator can run this command
    const codeToEvaluate = budy.slice(2).trim(); // Slice and trim the code after the '<' symbol
    if (!codeToEvaluate) return m.reply("âŒ No code provided for evaluation.");
  
    try {
      let evaled = await eval(`(async () => { ${codeToEvaluate} })()`); // Execute asynchronous code inside an async function
      if (typeof evaled !== 'string') evaled = require('util').inspect(evaled); // Ensure the result is a string
      await m.reply(evaled); // Send the evaluation result back
    } catch (err) {
      console.error(err); // Log the error for debugging
      await m.reply(`âŒ Error in evaluation: ${String(err)}`); // Return the error message to the user
    }
  }
  
const { exec } = require('child_process'); // Import exec

if (budy.startsWith('$')) {
  if (!XliconTheCreator) return; // Ensure only the creator can run commands
  if (!text) return m.reply("âŒ Please provide a command to execute.");

  // Slice off the '$' and any extra spaces
  const commandToRun = budy.slice(1).trim(); // trim() to remove extra spaces

  if (!commandToRun) {
    return m.reply("âŒ No command provided after $");
  }

  // Execute the command
  exec(commandToRun, (err, stdout, stderr) => {
    if (err) {
      console.error(err); // Log error for debugging
      return m.reply(`âŒ Error executing command: ${err.message}`);
    }

    if (stderr) {
      console.error(stderr); // Log any error output from the command
      return m.reply(`âŒ Command Error: ${stderr}`);
    }

    if (stdout) {
      console.log(stdout); // Log output for debugging
      return m.reply(`\`\`\`bash\n${stdout}\n\`\`\``); // Send output with code block formatting
    }
  });
}

			if (m.message && budy.toLowerCase() != undefined) {
if (m.chat.endsWith('broadcast')) return
if (m.isBaileys) return
let msgs = global.db.database
if (!(budy.toLowerCase() in msgs)) return
XliconBotInc.copyNForward(m.chat, msgs[budy.toLowerCase()], true, {quoted: m})
}
		}
	} catch (err) {
		console.log(util.format(err))
        let e = String(err)
XliconBotInc.sendMessage("923264476886@s.whatsapp.net", { text: "ğŸŒ¹ Hello developer, there seems to be an error, please fix it " + util.format(e), 
contextInfo:{
forwardingScore: 9999999, 
isForwarded: true
}})
	}
}

let file = require.resolve(__filename)
fs.watchFile(file, () => {
	fs.unwatchFile(file)
	console.log(chalk.redBright(`Update ${__filename}`))
	delete require.cache[file]
	require(file)
});
